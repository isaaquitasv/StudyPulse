<!DOCTYPE html>




<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="#0B1020" name="theme-color"/>
<title>StudyPulse</title>
<style>
    :root{
      --bg0:#070A12;
      --bg1:#0B1020;
      --card:#0D142A;
      --card2:#0B1226;
      --ink:#EAF0FF;
      --muted:#9AA7C7;
      --muted2:#7282AA;
      --line:rgba(255,255,255,.08);
      --shadow: 0 20px 70px rgba(0,0,0,.55);
      --shadow2: 0 10px 40px rgba(0,0,0,.45);
      --r:22px;
      --accent:#7C5CFF;
      --accent2:#26D5C6;

      /* Theme-derived glow/gradient helpers (overridden per theme) */
      --glow1: rgba(124,92,255,.22);
      --glow2: rgba(38,213,198,.18);
      --glow3: rgba(255,176,32,.08);
      --gradA: rgba(124,92,255,.35);
      --gradB: rgba(38,213,198,.18);
      --bannerA: rgba(124,92,255,.42);
      --bannerB: rgba(38,213,198,.10);
      --primaryBtnA: rgba(124,92,255,.70);
      --primaryBtnB: rgba(124,92,255,.25);
      --accentBright: rgba(124,92,255,.95);
      --accentSoft: rgba(124,92,255,.22);
      --accentSoft2: rgba(124,92,255,.30);
      --pillActiveBg: rgba(124,92,255,.18);
      --pillActiveBorder: rgba(124,92,255,.35);
      --good:#A3FF2F;
      --warn:#FFB020;
      --bad:#FF4D6D;
      --chip:rgba(255,255,255,.06);
      --glass: rgba(255,255,255,.06);
      --glass2: rgba(255,255,255,.04);
      --blur: 16px;

      /* Readiness ring dynamic gradient stops (set via JS) */
      --rgA: hsl(110 92% 58%);
      --rgB: hsl(120 92% 58%);
      --rgGlowA: hsla(110 92% 58% / .20);
      --rgGlowB: hsla(120 92% 58% / .12);

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    /* Themes */
    [data-theme="midnight"]{
      --bg0:#05060A; --bg1:#0A0D16; --card:#0D1327; --card2:#0A0F22;
      --accent:#6F63FF; --accent2:#2ACFC2;

      --glow1: rgba(111,99,255,.22);
      --glow2: rgba(42,207,194,.16);
      --glow3: rgba(255,176,32,.06);

      --gradA: rgba(111,99,255,.35);
      --gradB: rgba(42,207,194,.18);
      --bannerA: rgba(111,99,255,.42);
      --bannerB: rgba(42,207,194,.12);

      --primaryBtnA: rgba(111,99,255,.78);
      --primaryBtnB: rgba(111,99,255,.25);

      --accentBright: rgba(111,99,255,.95);
      --accentSoft: rgba(111,99,255,.22);
      --accentSoft2: rgba(111,99,255,.30);

      --pillActiveBg: rgba(111,99,255,.18);
      --pillActiveBorder: rgba(111,99,255,.35);
    }
    [data-theme="aurora"]{
      --bg0:#030815; --bg1:#07162F; --card:#081E36; --card2:#06152B;
      --accent:#00F0B5; --accent2:#5D6CFF;

      --glow1: rgba(0,240,181,.18);
      --glow2: rgba(93,108,255,.22);
      --glow3: rgba(255,255,255,.04);

      --gradA: rgba(0,240,181,.30);
      --gradB: rgba(93,108,255,.22);
      --bannerA: rgba(0,240,181,.30);
      --bannerB: rgba(93,108,255,.14);

      --primaryBtnA: rgba(0,240,181,.62);
      --primaryBtnB: rgba(93,108,255,.22);

      --accentBright: rgba(0,240,181,.95);
      --accentSoft: rgba(0,240,181,.18);
      --accentSoft2: rgba(0,240,181,.26);

      --pillActiveBg: rgba(0,240,181,.16);
      --pillActiveBorder: rgba(0,240,181,.32);
    }
    [data-theme="ember"]{
      --bg0:#0B0605; --bg1:#1A0D0C; --card:#24100E; --card2:#160A09;
      --accent:#FF5A2A; --accent2:#FFC247;

      --glow1: rgba(255,90,42,.22);
      --glow2: rgba(255,194,71,.16);
      --glow3: rgba(181,108,255,.06);

      --gradA: rgba(255,90,42,.34);
      --gradB: rgba(255,194,71,.18);
      --bannerA: rgba(255,90,42,.42);
      --bannerB: rgba(255,194,71,.14);

      --primaryBtnA: rgba(255,90,42,.70);
      --primaryBtnB: rgba(255,194,71,.26);

      --accentBright: rgba(255,90,42,.95);
      --accentSoft: rgba(255,90,42,.20);
      --accentSoft2: rgba(255,90,42,.28);

      --pillActiveBg: rgba(255,90,42,.16);
      --pillActiveBorder: rgba(255,90,42,.32);
    }

    html,body{height:100%; overflow-x:hidden; overflow-y:auto; overscroll-behavior:none; background: linear-gradient(180deg, var(--bg1), var(--bg0));}
    html{ background: linear-gradient(180deg, var(--bg1), var(--bg0)); }
    body{margin:0;
      font-family:var(--font);
      color:var(--ink);
      background:
        radial-gradient(1200px 600px at 20% 10%, var(--glow1), transparent 55%),
        radial-gradient(1000px 700px at 80% 10%, var(--glow2), transparent 55%),
        radial-gradient(900px 700px at 40% 80%, var(--glow3), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      background-attachment: fixed;
      overflow-x:hidden; overflow-y:auto;
      overscroll-behavior: none;
      min-height:100%;
    }

    *{box-sizing:border-box;}
    button, input, select, textarea{font-family:inherit;}

    .wrap{max-width:min(1280px, 96vw); margin:24px auto; padding:0 18px;}
    /* Responsive layout tuning */
    @media (min-width: 1500px){
      .wrap{max-width:min(1520px, 94vw);}
      .grid{gap:16px;}
    }
    @media (max-width: 720px){
      .wrap{margin:16px auto; padding:0 12px;}
      .topbar{padding:14px 14px; border-radius:22px; flex-wrap:wrap;}
      .topbar .brand{gap:10px;}
      .tabbar{padding:8px; gap:8px; overflow-x:auto; -webkit-overflow-scrolling:touch; scroll-snap-type:x mandatory;}
      .tabbtn{flex:0 0 auto; scroll-snap-align:start;}
    }
    @media (max-width: 520px){
      .grid{grid-template-columns: repeat(4, 1fr); gap:12px;}
      .card{grid-column: span 4;}
      .span-3,.span-4,.span-6,.span-12{grid-column: span 4;}
      .form{grid-template-columns: repeat(2, 1fr);}
      .field{grid-column: span 2;}
      .timerBtns{flex-wrap:wrap;}
    }


    /* Header */
    .topbar{
      display:flex; align-items:center; gap:16px;
      padding:18px 18px;
      border-radius:28px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: var(--shadow2);
      backdrop-filter: blur(var(--blur));
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      min-width: 220px;
    }
    .logo{
      width:34px; height:34px; border-radius:14px;
      background:
        radial-gradient(18px 18px at 30% 25%, rgba(255,255,255,.35), transparent 55%),
        linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .brand h1{
      margin:0;
      letter-spacing:.10em;
      font-size:16px;
      font-weight:850;
      text-transform:uppercase;
      color:rgba(234,240,255,.92);
    }

    .stats-mini{
      display:flex; align-items:center; gap:18px;
      margin-left:auto;
      color:rgba(234,240,255,.82);
    }
    .mini{
      display:flex; flex-direction:column; gap:4px;
      padding-left:18px;
      border-left:1px solid rgba(255,255,255,.10);
      min-width: 92px;
      text-align:right;
    }
    .mini .v{font-weight:800; font-size:18px;}
    .mini .k{font-size:11px; color:var(--muted2); letter-spacing:.12em; text-transform:uppercase;}

    /* Tabs */
    /* PATCH: Center tabs */
    .tabbar{ justify-content:center; }
    .tabbar .spacer{ display:none !important; }

    .tabbar{
      position:relative;
      margin-top:14px;
      display:flex; align-items:center; gap:10px;
      padding:10px;
      border-radius: 18px;
      background: rgba(255,255,255,.04);
      backdrop-filter: blur(var(--blur));
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    .tabbtn{
      appearance:none; border:0; cursor:pointer;
      color:rgba(234,240,255,.80);
      background: transparent;
      padding:10px 14px;
      border-radius: 14px;
      font-weight:700;
      letter-spacing:.02em;
      display:flex; align-items:center; gap:8px;
      transition: transform .12s ease, background .12s ease, color .12s ease;
      white-space:nowrap;
    }
    .tabbtn:hover{transform: translateY(-1px); background: rgba(255,255,255,.05);}
    .tabbtn.active{
      color:rgba(255,255,255,.95);
      background: linear-gradient(135deg, var(--gradA), var(--gradB));
      box-shadow: 0 16px 40px rgba(0,0,0,.35);
    }

    .tabbar .spacer{flex:1;}
    .pill{
      display:flex; align-items:center; gap:10px;
    }
    .pill button{
      border:0; cursor:pointer;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      color: rgba(234,240,255,.88);
      font-weight:700;
      transition: transform .12s ease, background .12s ease;
    }
    .pill button:hover{transform: translateY(-1px); background: rgba(255,255,255,.07);}
    .pill button.primary{
      background: linear-gradient(135deg, var(--primaryBtnA), var(--primaryBtnB));
    }



    /* === Micro-animations === */

    .page{display:none; margin-top:18px; will-change: transform, opacity;}
    .page.active{display:block;}
    .page.is-enter{ animation: pageEnter 200ms ease-out; }
    .page.is-leave{ animation: pageLeave 180ms ease-out; }
    @keyframes pageEnter{ from{opacity:0; transform:translate3d(0,10px,0);} to{opacity:1; transform:translate3d(0,0,0);} }
    @keyframes pageLeave{ from{opacity:1; transform:translate3d(0,0,0);} to{opacity:0; transform:translate3d(0,-6px,0);} }

    .card{ transition: transform 180ms cubic-bezier(.2,.8,.2,1), box-shadow 180ms cubic-bezier(.2,.8,.2,1); }
    .card:hover,.card:focus-within{ transform: translateY(-2px); box-shadow: 0 16px 52px rgba(0,0,0,.45); }

    @keyframes valuePulse{
      0%{ transform: scale(1); filter:none; }
      45%{ transform: scale(1.03); filter: drop-shadow(0 0 10px rgba(255,255,255,.14)); }
      100%{ transform: scale(1); filter:none; }
    }
    .value-pulse{ animation: valuePulse 280ms cubic-bezier(.2,.8,.2,1); }

    #readinessArc{ transition: stroke-dashoffset 700ms ease-out; }

    @keyframes barSettle{
      0%{ width: var(--from, 0%); }
      65%{ width: calc(var(--to, 0%) + 1%); }
      100%{ width: var(--to, 0%); }
    }
    .barFill{ will-change: width; transition: width 420ms cubic-bezier(.2,.9,.2,1); }

    /* Analytics value + delta indicator */
    .valDelta{ display:flex; align-items:center; gap:8px; justify-content:flex-end; }
    .deltaPill{
      font-size:12px;
      font-weight:950;
      padding:3px 8px;
      border-radius:999px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.08);
      color: rgba(234,240,255,.78);
      min-width: 56px;
      text-align:center;
    }
    .deltaPill.up{ color: var(--good); border-color: rgba(163,255,47,.22); background: rgba(163,255,47,.06); }
    .deltaPill.down{ color: var(--bad); border-color: rgba(255,77,109,.22); background: rgba(255,77,109,.06); }
    .deltaPill.neutral{ color: rgba(234,240,255,.70); }

    /* Smooth overview bar settle animation (no jitter) */
    .barFill.bar-anim{ transition:none !important; animation: barSettle 520ms cubic-bezier(.2,.9,.2,1); }

.timerActive{ border: 1px solid var(--accentSoft) !important; box-shadow: 0 18px 56px rgba(0,0,0,.50) !important; position:relative; }
    .timerActive::after{ content:""; position:absolute; inset:-2px; border-radius: inherit;
      background: radial-gradient(500px 180px at 20% 0%, var(--accentSoft), transparent 60%); pointer-events:none; opacity:.8; }

    @keyframes microShake{ 0%{transform:translateX(0);} 20%{transform:translateX(-3px);} 40%{transform:translateX(3px);} 60%{transform:translateX(-2px);} 80%{transform:translateX(2px);} 100%{transform:translateX(0);} }
    .shake{ animation: microShake 160ms ease-out; }

    /* Coach break popup (top-left) */
    .coachToast{ position:fixed; left:18px; top:18px; z-index:95; width:min(460px, calc(100% - 36px));
      border-radius:18px; padding:12px 14px;
      background: radial-gradient(900px 260px at 10% 0%, rgba(255,255,255,.10), transparent 60%),
                  linear-gradient(135deg, rgba(38,213,198,.26), rgba(124,92,255,.22));
      border:1px solid rgba(255,255,255,.10); box-shadow: var(--shadow2); backdrop-filter: blur(18px);
      opacity:0; pointer-events:none; transform: translateY(-12px); filter: blur(6px);
      transition: opacity 240ms cubic-bezier(.2,.8,.2,1), transform 240ms cubic-bezier(.2,.8,.2,1), filter 240ms cubic-bezier(.2,.8,.2,1); }
.tourDoneToast{ width:min(360px, calc(100% - 36px)); padding:12px 14px; }
    .tourDoneToast .meta{ margin-top:8px; }
    .tourDoneToast .actions{ margin-top:22px; gap:10px; }

    .coachToast.show{ opacity:1; pointer-events:auto; transform: translateY(0); filter: blur(0); }
    .coachToast .t{ font-weight:950; letter-spacing:.04em; }
    .coachToast .m{ margin-top:6px; color: rgba(234,240,255,.90); font-weight:750; line-height:1.25; }
    .coachToast .meta{ margin-top:6px; font-size:12px; color: rgba(234,240,255,.82); font-weight:750; }
    .coachToast .actions{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .coachToast .actions button{ border:0; cursor:pointer; padding:8px 10px; border-radius:14px;
      background: rgba(255,255,255,.08); color: rgba(234,240,255,.92); font-weight:850;
      transition: transform .12s ease, background .12s ease; }
    .coachToast .actions button:hover{ transform: translateY(-1px); background: rgba(255,255,255,.11); }
    /* PATCH: Coach toast layout (keep info, improve hierarchy) */
    .coachToast .coachTop{ display:flex; justify-content:space-between; align-items:flex-start; gap:12px; }
    .coachToast .coachHdr{ display:flex; flex-direction:column; gap:4px; }
    .coachToast .coachHint{ opacity:.78; letter-spacing:.12em; text-transform:uppercase; font-weight:900; }
    .coachToast .actions{ margin-top:0; }
    .coachToast .actions button{ padding:8px 12px; }


    /* Delight: streak ripple */
    @keyframes ringRipple{ 0%{opacity:0; transform:scale(.9);} 25%{opacity:.55;} 100%{opacity:0; transform:scale(1.35);} }
    .ripple{ position:absolute; inset:-8px; border-radius:999px; border:2px solid rgba(255,255,255,.22);
      pointer-events:none; animation: ringRipple 650ms ease-out; }

    /* Milestone tick */
    .milestoneTick{ position:absolute; right:14px; top:14px; width:26px; height:26px; border-radius:12px;
      background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.10); display:grid; place-items:center;
      opacity:0; transform:scale(.96); transition: opacity 180ms ease, transform 180ms ease; pointer-events:none; }
    .milestoneTick.show{ opacity:1; transform: scale(1); }
    .milestoneTick svg{ width:16px; height:16px; }

    /* Goal celebration confetti (card-contained) */
    .confettiPiece{
      position:absolute;
      left:50%; top:44%;
      width:7px; height:11px;
      border-radius:2px;
      opacity:0;
      transform: translate(-50%,-50%) rotate(0deg);
      pointer-events:none;
      animation: confettiPop 920ms cubic-bezier(.16,.84,.24,1) forwards;
      will-change: transform, opacity;
      mix-blend-mode: screen;
    }
    @keyframes confettiPop{
      0%{ opacity:0; transform: translate(-50%,-50%) rotate(0deg) scale(.85); }
      12%{ opacity:1; }
      100%{ opacity:0; transform: translate(calc(-50% + var(--dx,0px)), calc(-50% + var(--dy,0px))) rotate(var(--rot,0deg)) scale(1); }
    }
    @media (prefers-reduced-motion: reduce){
      .confettiPiece{ animation: none !important; display:none !important; }
      .barFill, .bar-anim{ animation: none !important; transition: none !important; }
      .page.is-enter, .page.is-leave{ animation: none !important; }
    }

    /* Tactile press feedback (buttons) */
    button:active, .btn:active{ transform: scale(.98); filter: brightness(.92); }

    /* Cards + grid (Overview) */
    .grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:16px;
      align-items:stretch;
    }
    .card{
      grid-column: span 4;
      border-radius: var(--r);
      background:
        radial-gradient(900px 400px at 50% 0%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow: var(--shadow2);
      backdrop-filter: blur(var(--blur));
      padding:16px;
      position:relative;
      overflow:hidden;
      min-height: 152px;
    }
    .card.big{min-height: 210px;}
    .card.tall{min-height: 200px;}
    .card .head{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      margin-bottom:10px;
    }
    .title{
      display:flex; flex-direction:column; gap:4px;
      max-width: 85%;
    }
    .title .t{
      font-size:13px;
      letter-spacing:.12em;
      text-transform:uppercase;
      font-weight:900;
      color: rgba(234,240,255,.80);
    }
    .title .s{
      font-size:12px;
      color: var(--muted2);
      font-weight:600;
    }
    .info{
      width:34px; height:34px;
      border-radius: 12px;
      display:grid; place-items:center;
      background: rgba(255,255,255,.04);
      cursor:help;
      user-select:none;
      font-weight:900;
      color: rgba(234,240,255,.85);
      border: 1px solid rgba(255,255,255,.06);
      flex: 0 0 auto;
    }
    .metric{
      display:flex; align-items:flex-end; justify-content:space-between;
      gap:14px;
      margin-top: 8px;
    }
    .metric .num{
      font-size:44px;
      font-weight:900;
      letter-spacing:-.02em;
      line-height:1;
    }
    .metric .sub{
      margin-top:8px;
      color: var(--muted);
      font-weight:650;
      font-size:13px;
    }

    .metricCenter{
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 8px;
    }

    #cardTodayTarget .metric{ margin-top:14px; gap:12px; }
    #cardTodayTarget .big{ line-height:1.05; }
    #cardTodayTarget .bar{ margin-top:18px; }


    .minirow{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      margin-top: 12px;
      color: var(--muted);
      font-weight:650;
    }
    .bar{
      height:10px; width:100%;
      border-radius: 99px;
      background: rgba(255,255,255,.06);
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .bar > i{
      display:block; height:100%;
      width:0%;
      border-radius: 99px;
      background: linear-gradient(90deg, hsl(105 92% 58%), hsl(115 92% 58%));
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }

    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      color: rgba(234,240,255,.88);
      font-weight:800;
      border: 1px solid rgba(255,255,255,.06);
    }
    .chip.selected{
      background: linear-gradient(135deg, var(--pillActiveBg), rgba(255,255,255,.03));
      border-color: var(--pillActiveBorder);
      box-shadow: 0 12px 34px rgba(0,0,0,.35), 0 0 0 1px rgba(255,255,255,.06) inset;
      color: var(--ink);
    }
    .ciEventRow{ margin-top:10px; }
    .ciEventBtn{ padding:10px 14px; }

    .ciMatchChip{
      background: rgba(124,92,255,.18);
      border-color: rgba(124,92,255,.55);
      color: rgba(234,240,255,.96);
    }
    .ciInputMatch{
      outline: none;
      box-shadow: 0 0 0 2px rgba(124,92,255,.55), 0 12px 30px rgba(0,0,0,.35);
      border-color: rgba(124,92,255,.55);
    }


    .btn{
      border:0; cursor:pointer;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      color: rgba(234,240,255,.92);
      font-weight:800;
      transition: transform .12s ease, background .12s ease;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.07);}
    .btn.primary{
      background: linear-gradient(135deg, var(--primaryBtnA), var(--primaryBtnB));
      box-shadow: 0 16px 40px rgba(0,0,0,.35);
    }
    .btn.finishTint{
      background: linear-gradient(135deg, rgba(38,213,198,.22), rgba(163,255,47,.16));
      border-color: rgba(38,213,198,.28);
    }
    .btn.finishTint:hover{ filter: brightness(1.05); }

    .btn.danger{
      background: linear-gradient(135deg, rgba(255,77,109,.55), rgba(255,77,109,.22));
    }

    /* Ring */
    .ringWrap{
      display:grid;
      place-items:center;
      padding-top: 6px;
    }
    .ring{
      width:min(220px, 100%);
      height:min(220px, 100%);
      position:relative;
      display:grid;
      place-items:center;
    }
    .ring svg{transform: rotate(-90deg); width:100%; height:100%;}

    .ring .center{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      transform: none;
    }
    .ring .center .val{
      font-size:48px;
      font-weight:950;
      letter-spacing:-.02em;
      line-height:1;
      display:flex;
      align-items:center;
      justify-content:center;
      height:52px;
    }
    .ring .center .lbl{
      font-size:12px;
      font-weight:950;
      letter-spacing:.18em;
      text-transform:uppercase;
      color: rgba(234,240,255,.70);
      margin-top: 2px;
    }
    .ring .under{
      margin-top: 10px;
      text-align:center;
      color: var(--muted);
      font-weight:700;
      font-size:13px;
    }

    
    
    /* ===== Readiness ring containment (no overflow) ===== */
    #cardReadiness{ padding-bottom: 22px; }
    #cardReadiness .ringWrap{ padding-top: 2px; padding-bottom: 10px; overflow:hidden; }
    #cardReadiness .ring{ transform: none; max-width: 100%; }
    #cardReadiness svg{ width:100%; height:100%; overflow: visible; }
/* Overview spans */
    .span-4{grid-column: span 4;}
    .span-6{grid-column: span 6;}
    .span-12{grid-column: span 12;}
    .span-3{grid-column: span 3;}

    /* Retention list */
    .list{
      margin-top: 10px;
      display:flex; flex-direction:column; gap:10px;
    }
    .row{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.06);
    }
    .row .left{
      display:flex; flex-direction:column; gap:2px;
    }
    .row .left b{font-weight:900;}
    .row .left small{color: var(--muted2); font-weight:650;}
    .row .right{font-weight:950; color: var(--accentBright);}

    /* Recommendation banner */
    .banner{
      border-radius: 22px;
      padding:16px 16px;
      background:
        radial-gradient(800px 280px at 20% 0%, rgba(255,255,255,.10), transparent 60%),
        linear-gradient(135deg, var(--bannerA), var(--bannerB));
      box-shadow: var(--shadow2);
      backdrop-filter: blur(var(--blur));
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
      margin-bottom: 16px;
    }


    .banner.bannerSlim{
      padding:12px 14px;
      border-radius:20px;
      margin-bottom:12px;
    }
    .banner.bannerSlim .recRow{ padding:9px 12px; border-radius:15px; }
    .banner.bannerSlim #recSub, .banner.bannerSlim #recRows{ display:none; }

    /* Retention tier gradient labels (text-only) */
    .riskTier{
      font-weight:950;
      letter-spacing:.02em;
      -webkit-background-clip:text;
      background-clip:text;
      color: transparent;
      text-shadow:none;
    }
    .riskTier--low{  background-image: linear-gradient(90deg, rgba(163,255,47,.92), rgba(34,214,201,.70)); }
    .riskTier--med{  background-image: linear-gradient(90deg, rgba(255,176,32,.95), rgba(255,90,42,.70)); }
    .riskTier--high{ background-image: linear-gradient(90deg, rgba(255,77,109,.95), rgba(181,108,255,.65)); }

    /* PATCH: Overview recommendation rows (match Next session plan popup) */
    .banner .recRows{ display:flex; flex-direction:column; gap:10px; }
    .banner .recRow{
      display:flex; justify-content:space-between; align-items:flex-start; gap:14px;
      padding:10px 12px; border-radius:16px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
    }
    .banner .recRow b{
      font-size:12px;
      letter-spacing:.12em;
      text-transform:uppercase;
      font-weight:900;
      color: rgba(234,240,255,.82);
      display:block;
    }
    .banner .recRow .small{ margin-top:4px; color: rgba(234,240,255,.78); font-weight:750; line-height:1.25; }

    .banner .btitle{
      display:flex; flex-direction:column; gap:6px;
    }
    .banner .btitle .h{
      font-size:14px;
      font-weight:950;
      letter-spacing:.10em;
      text-transform:uppercase;
      color: rgba(234,240,255,.90);
    }
    .banner .btitle .p{
      color: rgba(234,240,255,.86);
      font-weight:750;
    }

    /* Start Session page */
    .two{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: repeat(6, 1fr);}
      .card{grid-column: span 6;}
      .span-3,.span-4,.span-6{grid-column: span 6;}
      .two{grid-template-columns:1fr;}
      .mini{min-width:80px;}
    }

    .form{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:12px;
      margin-top: 8px;
    }
    .field{
      padding:12px;
      border-radius: 18px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.06);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .field label{
      display:block;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color: var(--muted2);
      font-weight:900;
      margin-bottom:8px;
    }
    .field input, .field select{
      width:100%;
      padding:10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      color: rgba(234,240,255,.92);
      font-weight:750;
      outline:none;
    }

    .timerCard{
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      min-height: 340px;
    }
    .timer{
      display:grid; place-items:center;
      position:relative;
      padding: 16px 0 10px;
    }
    .time{
      font-size:84px;
      font-weight:950;
      letter-spacing:-.03em;
      line-height:1;
    }
    .timerBtns{
      display:flex; justify-content:center; gap:10px;
      padding-bottom: 8px;
      flex-wrap: wrap; /* controls moved here */
    }
    .timerBtns .btn{min-width: 140px;}
    .hint{
      color: var(--muted2);
      font-weight:700;
      font-size:12px;
      margin-top: 10px;
      text-align:center;
    }

    .timerViewRow{
      display:flex;
      justify-content:center;
      gap:10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .viewBtn{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: rgba(234,240,255,.88);
      padding:8px 10px;
      border-radius: 999px;
      cursor:pointer;
      font-weight:850;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .viewBtn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.16); }
    .viewBtn.active{
      background: linear-gradient(135deg, rgba(124,92,255,.55), rgba(38,213,198,.18));
      border-color: rgba(124,92,255,.30);
      color: rgba(255,255,255,.95);
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
    }

    .timerVisual--digital #timerRing,
    .timerVisual--digital #timerBar{ display:none; }
    .timerVisual--bar #timerRing{ display:none; }
    .timerVisual--ring #timerBar{ display:none; }

    .timerRing{ display:none; position:absolute; inset:0; place-items:center; pointer-events:none; opacity:.95; }
    .timerVisual--ring .timerRing{ display:grid; }
    .timerVisual--ring .time{ position:relative; z-index:2; }
    .timerVisual--ring .timerRing svg{ transform: rotate(-90deg); filter: drop-shadow(0 18px 40px rgba(0,0,0,.35)); }

    .timerBar{ display:none; width:min(520px, 92%); margin: 0 auto; }
    .timerVisual--bar .timerBar{ display:block; }
    .timerBar .bar{ height:14px; border-radius:999px; background: rgba(255,255,255,.08); overflow:hidden; }
    .timerBar .bar i{ display:block; height:100%; width:0%; border-radius:999px; background: linear-gradient(90deg, var(--accent), var(--accent2)); }
    .timerBarMeta{ display:flex; justify-content:space-between; margin-top:10px; color: rgba(234,240,255,.78); font-weight:850; font-size:12px; letter-spacing:.06em; }

    /* Analytics */
    .chartWrap{
      width:100%;
      height: 280px;
      border-radius: 18px;
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.06);
      overflow:hidden;
      position:relative;
    }
    canvas{display:block; width:100%; height:100%;}

    .legend{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top: 10px;
      color: var(--muted2);
      font-weight:750;
      font-size:12px;
    }

    /* Small sparkline used in Overview cards */
    .sparkWrap{
      height: 46px;
      border-radius: 14px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.06);
      overflow: hidden;
    }
    .sparkWrap canvas{ width:100%; height:100%; display:block; }

    /* Modal */
    .modalBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.60);
      backdrop-filter: blur(12px);
      display:flex;
      opacity:0;
      visibility:hidden;
      pointer-events:none;
      transition: opacity 200ms cubic-bezier(.2,.8,.2,1);

      align-items:center;
      justify-content:center;
      overflow:auto;
      align-items:flex-start;
      padding: 18px;
      z-index: 50;
    }
    .modalBack.show{ opacity:1; visibility:visible; pointer-events:auto; }
    .modalBack.show .modal{ transform: scale(1); opacity:1; }
    .modal{
      width:min(980px, 100%);
      transform: scale(.98);
      opacity:0;
      transition: transform 200ms cubic-bezier(.2,.8,.2,1), opacity 200ms cubic-bezier(.2,.8,.2,1);
      border-radius: 26px;
      background:
        radial-gradient(900px 400px at 30% 0%, rgba(255,255,255,.08), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.08);
      overflow:hidden;
      position:relative;
    }
    .modal .mhead{
      padding: 16px 16px;
      display:flex; align-items:flex-start; justify-content:space-between; gap:14px;
      border-bottom: 1px solid rgba(255,255,255,.06);
    }
    .modal .mhead h3{
      margin:0;
      font-size:14px;
      letter-spacing:.12em;
      text-transform:uppercase;
      font-weight:950;
    }
    .modal .mhead p{
      margin:6px 0 0;
      color: var(--muted2);
      font-weight:700;
      font-size:12px;
    }
    .modal .mbody{padding: 16px; overflow:auto; max-height: calc(100vh - 210px);}
    .modal .mfoot{
      padding: 14px 16px;
      display:flex; justify-content:flex-end; gap:10px;
      border-top: 1px solid rgba(255,255,255,.06);
    }

    .seg{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .seg .box{
      border-radius: 18px;
      padding:12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.06);
    }
    .box h4{
      margin:0 0 8px;
      font-size:12px;
      font-weight:950;
      letter-spacing:.12em;
      text-transform:uppercase;
      color: rgba(234,240,255,.85);
      display:flex; gap:8px; align-items:center;
    }
    .scale{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
    }
    .scale input[type="range"]{width:100%;}
    .pillrow{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top: 10px;
    }

    /* PATCH: Ensure onboarding "pill" options are clickable (avoid overlay capture) */
    #onboardBack .pillrow{ position:relative; z-index:5; pointer-events:auto; }
    #onboardBack .pillOpt{ position:relative; z-index:6; pointer-events:auto; }

    .pillOpt{
      user-select:none;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.06);
      color: rgba(234,240,255,.88);
      font-weight:850;
    }
    .pillOpt.active{
      background: linear-gradient(135deg, rgba(124,92,255,.40), rgba(38,213,198,.12));
      border-color: rgba(124,92,255,.30);
    }

    .txt{
      width:100%;
      padding:10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      color: rgba(234,240,255,.92);
      font-weight:750;
      outline:none;
      margin-top: 10px;
    }

    
    /* Next session plan overlay + quick end reflection popover */
    .overlayBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.58);
      backdrop-filter: blur(14px);
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:0;
      pointer-events:none;
      z-index: 90;
      transition: opacity 160ms ease;
    }
    .overlayBack.show{ opacity:1; pointer-events:auto; }

    .glassBox{
      width: min(560px, 92vw);
      border-radius: 24px;
      padding: 16px;
      background: rgba(13,20,42,.72);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 30px 90px rgba(0,0,0,.55);
      backdrop-filter: blur(18px);
      transform: translateY(10px) scale(.99);
      transition: transform 180ms cubic-bezier(.2,.8,.2,1);
    }
    .overlayBack.show .glassBox{ transform: translateY(0) scale(1); }

    .glassHead{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      margin-bottom: 10px;
    }
    .glassHead .t{ font-weight: 950; font-size: 15px; }
    .glassHead .s{ font-size: 12px; color: var(--muted2); margin-top:4px; }
    .glassBody{ display:flex; flex-direction:column; gap: 10px; }
    .glassRow{
      display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.06);
    }
    .glassRow b{ font-weight: 900; }
    .glassRow .small{ opacity:.88; }
    .glassActions{
      display:flex; gap:10px; justify-content:flex-end; align-items:center;
      margin-top: 12px;
    }
    .glassPills{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-start; }
    .glassPills .pillBig{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      cursor:pointer;
      font-weight: 800;
      transition: transform 140ms cubic-bezier(.2,.8,.2,1), filter 140ms ease, background 140ms ease;
      user-select:none;
    }
    .glassPills .pillBig:hover{ transform: translateY(-1px); filter: brightness(1.06); }
    .glassPills .pillBig.active{ background: var(--pillActiveBg); border-color: var(--pillActiveBorder); }


    /* Tooltip */
    .tip{
      position:fixed;
      z-index: 80;
      pointer-events:none;
      padding:10px 12px;
      max-width: 320px;
      border-radius: 14px;
      background: rgba(10,14,25,.92);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow2);
      color: rgba(234,240,255,.92);
      font-size:12px;
      font-weight:700;
      display:block;
      opacity:0;
      visibility:hidden;
      transform: translate(10px, 10px);
      transition: opacity 160ms ease, transform 160ms ease;

      transform: translate(10px, 10px);
    }
    .tip b{font-weight:950;}
    .tip.show{ opacity:1; visibility:visible; transform: translate(10px, 6px);}
    .muted{color: var(--muted2); font-weight:700;}

    /* Toast notification */
    .toast{
      position: fixed;
      right: 18px;
      top: 18px;
      z-index: 90;
      width: min(420px, calc(100% - 36px));
      border-radius: 18px;
      padding: 12px 14px;
      background:
        radial-gradient(800px 240px at 10% 0%, rgba(255,255,255,.10), transparent 60%),
        linear-gradient(135deg, rgba(124,92,255,.55), rgba(38,213,198,.18));
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(18px);
      display:block;
      opacity:0;
      pointer-events:none;
      transform: translateY(-12px);
      filter: blur(6px);
      transition: opacity 220ms cubic-bezier(.2,.8,.2,1), transform 220ms cubic-bezier(.2,.8,.2,1), filter 220ms cubic-bezier(.2,.8,.2,1);

    }
    .toast.show{ opacity:1; pointer-events:auto; transform: translateY(0); filter: blur(0);} 
    .toast .t{ font-weight:950; letter-spacing:.04em; }
    .toast .m{ margin-top:4px; color: rgba(234,240,255,.86); font-weight:750; }

    /* Fullscreen timer overlay (styled back to “clean screen” look) */
    .full{
      position:fixed;
      top: var(--chromeH, 0px);
      left:0; right:0; bottom:0;
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(124,92,255,.25), transparent 55%),
        radial-gradient(1000px 700px at 80% 10%, rgba(38,213,198,.20), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      background-attachment: fixed;
      display:none;
      z-index: 60;
    }
    .full.show{display:block;}
    .fullInner{
      height:100%;
      width:100%;
      display:block;
      position:relative;
      padding: 18px;
    }
    /* Focus timer: allow split-view on larger screens */
    @media (min-width: 980px){
      .full{background: rgba(0,0,0,.18); backdrop-filter: blur(6px);}
      .fullInner{
        width: min(520px, 44vw);
        margin-left: auto;
        height: calc(100% - 36px);
        margin-top: 18px;
        margin-bottom: 18px;
        border-radius: 24px;
        border: 1px solid rgba(255,255,255,.08);
        background:
          radial-gradient(900px 380px at 15% 0%, rgba(255,255,255,.08), transparent 60%),
          linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
        box-shadow: 0 18px 60px rgba(0,0,0,.55);
      }
    }

    .fullCard{
      width:100%;
      height:100%;
      background: transparent;
      border: 0;
      box-shadow: none;
      backdrop-filter: none;
      padding: 0;
      text-align:center;
      position:relative;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }
    .fullCard .bigTime{
      font-size:120px;
      font-weight:950;
      letter-spacing:-.04em;
      margin: 10px 0 0;
    }
    .fullCard .sub{
      display:none; /* match the clean fullscreen look */
    }
    .fullCard .btnrow{
      position:absolute;
      left:0; right:0;
      bottom: 26px;
      display:flex; justify-content:center; gap:10px; flex-wrap:wrap;
    }
    #fullLabel{
      position:absolute;
      top: 16px;
      left: 16px;
      font-size:12px;
      color: rgba(234,240,255,.82);
      font-weight:800;
      letter-spacing:.06em;
      text-transform:uppercase;
    }
    #btnFullExit{
      position:absolute;
      top: 12px;
      right: 12px;
      padding: 10px 12px;
      border-radius: 14px;
    }

    /* Helpers */
    .right{float:right;}
    .small{font-size:12px; color:var(--muted2); font-weight:700;}
    .hr{height:1px; background: rgba(255,255,255,.06); margin: 14px 0;}

    /* End-session slider styling */
    .scaleRow{
      display:flex; align-items:center; gap:12px;
    }
    .scaleRow input[type="range"]{width:100%;}
    .scaleVal{
      min-width:54px;
      text-align:right;
      font-weight:900;
      color: rgba(234,240,255,.90);
    }

    .endCheck{display:flex; flex-direction:column; gap:14px; margin-top:12px;}
    .endLine{
      padding:12px;
      border-radius:18px;
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.06);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .endLbl{
      font-size:11px; letter-spacing:.14em; text-transform:uppercase;
      color: var(--muted2); font-weight:950; margin-bottom:8px;
    }
    .endRow{display:flex; align-items:center; gap:12px;}
    .endRow input[type="range"]{width:100%;}
    .endNum{
      min-width:44px;
      text-align:right;
      font-weight:950;
      color: rgba(234,240,255,.92);
    }
  
    /* goals mini list */
    .miniList{ display:flex; flex-direction:column; gap:10px; margin-top:8px; }
    .miniRow{ display:flex; justify-content:space-between; align-items:center; padding:10px 12px; border:1px solid var(--line); border-radius:14px; background:rgba(255,255,255,.02); }
    .miniLeft{ color:var(--ink); font-weight:600; }
    .miniRight{ display:flex; align-items:center; gap:8px; }
    .miniInp{ width:140px; }

/* Ensure consistent typography across all UI controls */
body, button, input, select, textarea{ font-family:var(--font); }



/* ===== Explicit Goals ===== */
.goalsGrid{ display:grid; grid-template-columns:1fr; gap:14px; }
@media (max-width: 980px){ .goalsGrid{ grid-template-columns:1fr; } }
.goalCard{ background:var(--card); border:1px solid var(--line); border-radius:var(--r); box-shadow:var(--shadow2); padding:14px; }
.goalHdr{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; margin-bottom:10px; }
.goalHdr .h{ font-weight:950; letter-spacing:.12em; font-size:11px; opacity:.9; }
.goalHdr .status{ font-size:12px; color:var(--muted); display:flex; align-items:center; gap:8px; }
.statusDot{ width:8px; height:8px; border-radius:50%; background:rgba(255,255,255,.20); }
.statusDot.saved{ background:rgba(38,213,198,.75); }
.formGrid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
.formGrid .span2{ grid-column:1 / -1; }
.field{ display:flex; flex-direction:column; gap:6px; }
.field .lbl{ font-size:12px; color:var(--muted); }
.field .help{ font-size:11px; color:var(--muted2); margin-top:-2px; }
.dual{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
.goalActions{ display:flex; gap:10px; justify-content:flex-end; margin-top:12px; align-items:center; }
.linkBtn{ background:transparent; border:1px solid var(--line); color:var(--ink); padding:10px 12px; border-radius:14px; cursor:pointer; }
.prog{ height:10px; background:rgba(255,255,255,.06); border-radius:99px; overflow:hidden; border:1px solid rgba(255,255,255,.06); }
.prog i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--rgA),var(--rgB)); border-radius:99px; }
.adhRow{ display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:10px; }
.adhRow .k{ font-size:12px; color:var(--muted); }
.adhRow .v{ font-size:12px; color:var(--ink); font-weight:800; }
.adhBlock{ margin-top:12px; border-top:1px solid var(--line); padding-top:12px; }
.subList{ display:flex; flex-direction:column; gap:10px; margin-top:10px; }
.subItem{ border:1px solid var(--line); border-radius:14px; padding:10px 12px; background:rgba(255,255,255,.02); }
.subItemTop{ display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px; }
.subItemTop .name{ font-weight:850; }
.subItemTop .meta{ font-size:12px; color:var(--muted); }

/* ===== Fullscreen timer overlay ===== */
.full{ position:fixed; inset:0; display:none; z-index:1000; background:
  radial-gradient(1200px 700px at 50% 20%, rgba(255,255,255,.06), rgba(0,0,0,0) 55%),
  radial-gradient(900px 600px at 70% 80%, rgba(255,255,255,.05), rgba(0,0,0,0) 60%),
  linear-gradient(180deg, rgba(7,10,18,1), rgba(4,6,12,1));
  align-items:center; justify-content:center; padding:18px;
}
.full.show{ display:flex; }
.fullInner{ width:100%; height:100%; display:flex; flex-direction:column; justify-content:space-between; }
.fullTop{ display:flex; justify-content:space-between; align-items:center; }
.fullTop .subj{ font-weight:900; letter-spacing:.08em; font-size:12px; color:rgba(234,240,255,.85); }
.fullExit{ border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); color:var(--ink); padding:8px 10px; border-radius:12px; cursor:pointer; }
.fullCenter{ flex:1; display:flex; align-items:center; justify-content:center; }
.fullTime{ font-weight:950; font-size:76px; letter-spacing:-.02em; }
@media (max-width:520px){ .fullTime{ font-size:56px; } }
.fullBottom{ display:flex; justify-content:center; gap:10px; padding-bottom:12px; }
.fullBottom .btn{ padding:10px 14px; border-radius:999px; }
.fullBottom .btn.primary{ padding:10px 16px; }


    /* ---- Added/Adjusted UI primitives (inputs, toggles, overview card headers) ---- */
    button, input, textarea, select{font-family:var(--font);}

    .inp, .sel, .txt, .ta{
      width:100%;
      box-sizing:border-box;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: rgba(234,240,255,.96);
      padding:10px 12px;
      outline:none;
      transition: border-color .15s ease, background .15s ease, box-shadow .15s ease;
    }
    .inp::placeholder, .txt::placeholder, .ta::placeholder{color: rgba(154,167,199,.60);}
    .inp:focus, .sel:focus, .txt:focus, .ta:focus{
      border-color: rgba(124,92,255,.40);
      box-shadow: 0 0 0 4px rgba(124,92,255,.14);
      background: rgba(255,255,255,.06);
    }
    .unit{
      display:inline-flex;
      align-items:center;
      padding:0 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      font-weight:800;
      font-size:12px;
      height:36px;
      margin-left:10px;
      white-space:nowrap;
    }

    /* Onboarding custom subject row: keep clear but not a white bar */
    #onboardStep1 .row input.inp{
      background: rgba(0,0,0,.14);
      border-color: rgba(255,255,255,.14);
    }

    /* Settings strict mode toggle (switch) */
    .switch{position:relative; display:inline-block; width:56px; height:32px;}
    .switch input{opacity:0; width:0; height:0;}
    .switch .slider{
      position:absolute; inset:0;
      cursor:pointer;
      border-radius:999px;
      background: rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.16);
      transition: .18s ease;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.12);
    }
    .switch .slider:before{
      content:"";
      position:absolute;
      height:24px; width:24px;
      left:3px; top:3px;
      border-radius:999px;
      background: rgba(234,240,255,.92);
      box-shadow: 0 12px 26px rgba(0,0,0,.40);
      transition: .18s ease;
    }
    .switch input:checked + .slider{
      background: linear-gradient(135deg, rgba(124,92,255,.75), rgba(38,213,198,.28));
      border-color: rgba(124,92,255,.34);
    }
    .switch input:checked + .slider:before{ transform: translateX(24px); }

    /* Overview cards that use cardTop/cardTitle/cardSub */
    .cardTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .cardTitle{
      font-weight:950;
      letter-spacing:-.02em;
      font-size:14px;
      color: rgba(234,240,255,.96);
      line-height:1.1;
    }
    .cardSub{
      margin-top:4px;
      font-size:12px;
      color: var(--muted);
      line-height:1.25;
    }
    .metric{display:flex; flex-direction:column; gap:4px; margin-top:6px;}
    .metric .big{
      min-height:unset; /* override earlier layout class */
      font-size:28px;
      font-weight:950;
      letter-spacing:-.02em;
      line-height:1.05;
      color: rgba(234,240,255,.96);
    }
    .metric .small{
      color: var(--muted);
      font-size:12px;
      font-weight:750;
    }
    .bar{height:10px; border-radius:999px; background: rgba(255,255,255,.08); overflow:hidden;}
    .barFill{
      height:100%;
      border-radius:999px;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    /* Readiness ring: ensure number always centered */
    .ring{position:relative;}
    .ring .center{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      pointer-events:none;
    }
    .ring .center .val{
      font-weight:1000;
      line-height:1;
      letter-spacing:-.03em;
      font-variant-numeric: tabular-nums;
    }
    .ring .center .lbl{display:none;}

    /* Additional themes (more contrast) */
    [data-theme="ocean"]{
      --bg0:#03050B; --bg1:#061326; --card:#071B33; --card2:#051225;
      --accent:#3B8CFF; --accent2:#22D6C9;

      --glow1: rgba(59,140,255,.30);
      --glow2: rgba(34,214,201,.22);
      --glow3: rgba(255,255,255,.05);

      --gradA: rgba(59,140,255,.55);
      --gradB: rgba(34,214,201,.28);
      --bannerA: rgba(59,140,255,.62);
      --bannerB: rgba(34,214,201,.22);

      --primaryBtnA: rgba(59,140,255,.82);
      --primaryBtnB: rgba(34,214,201,.30);

      --accentBright: rgba(59,140,255,.98);
      --accentSoft: rgba(59,140,255,.24);
      --accentSoft2: rgba(59,140,255,.34);

      --pillActiveBg: rgba(59,140,255,.20);
      --pillActiveBorder: rgba(59,140,255,.38);
    }
    [data-theme="grape"]{
      --bg0:#06020E; --bg1:#14072A; --card:#190A38; --card2:#100625;
      --accent:#B56CFF; --accent2:#FF49D6;

      --glow1: rgba(181,108,255,.32);
      --glow2: rgba(255,73,214,.20);
      --glow3: rgba(255,176,32,.06);

      --gradA: rgba(181,108,255,.58);
      --gradB: rgba(255,73,214,.26);
      --bannerA: rgba(181,108,255,.66);
      --bannerB: rgba(255,73,214,.20);

      --primaryBtnA: rgba(181,108,255,.86);
      --primaryBtnB: rgba(255,73,214,.30);

      --accentBright: rgba(181,108,255,.98);
      --accentSoft: rgba(181,108,255,.24);
      --accentSoft2: rgba(181,108,255,.34);

      --pillActiveBg: rgba(181,108,255,.20);
      --pillActiveBorder: rgba(181,108,255,.38);
    }
    [data-theme="forest"]{
      --bg0:#030806; --bg1:#06120D; --card:#071A13; --card2:#05110C;
      --accent:#38E07A; --accent2:#A6E34D;

      --glow1: rgba(56,224,122,.24);
      --glow2: rgba(166,227,77,.16);
      --glow3: rgba(0,240,181,.06);

      --gradA: rgba(56,224,122,.36);
      --gradB: rgba(166,227,77,.20);
      --bannerA: rgba(56,224,122,.46);
      --bannerB: rgba(166,227,77,.14);

      --primaryBtnA: rgba(56,224,122,.72);
      --primaryBtnB: rgba(166,227,77,.24);

      --accentBright: rgba(56,224,122,.95);
      --accentSoft: rgba(56,224,122,.20);
      --accentSoft2: rgba(56,224,122,.28);

      --pillActiveBg: rgba(56,224,122,.16);
      --pillActiveBorder: rgba(56,224,122,.32);
    }
    [data-theme="mono"]{
      --bg0:#000000; --bg1:#040407; --card:#07070B; --card2:#030306;
      --accent:#00E5FF; --accent2:#FF3D81;
      --line:rgba(255,255,255,.10);

      --glow1: rgba(0,229,255,.18);
      --glow2: rgba(255,61,129,.12);
      --glow3: rgba(163,255,47,.06);

      --gradA: rgba(0,229,255,.42);
      --gradB: rgba(255,61,129,.22);
      --bannerA: rgba(0,229,255,.48);
      --bannerB: rgba(255,61,129,.14);

      --primaryBtnA: rgba(0,229,255,.76);
      --primaryBtnB: rgba(255,61,129,.28);

      --accentBright: rgba(0,229,255,.96);
      --accentSoft: rgba(0,229,255,.18);
      --accentSoft2: rgba(0,229,255,.26);

      --pillActiveBg: rgba(0,229,255,.14);
      --pillActiveBorder: rgba(0,229,255,.30);
    }


[data-theme="blackout"]{
      --bg0:#000000; --bg1:#000000; --card:#05050A; --card2:#020206;
      --accent:#EAF0FF; --accent2:#00E5FF;
      --line:rgba(255,255,255,.10);

      --glow1: rgba(234,240,255,.10);
      --glow2: rgba(0,229,255,.12);
      --glow3: rgba(255,61,129,.05);

      --gradA: rgba(234,240,255,.20);
      --gradB: rgba(0,229,255,.14);
      --bannerA: rgba(0,229,255,.42);
      --bannerB: rgba(234,240,255,.10);

      --primaryBtnA: rgba(0,229,255,.78);
      --primaryBtnB: rgba(234,240,255,.28);

      --accentBright: rgba(234,240,255,.95);
      --accentSoft: rgba(234,240,255,.12);
      --accentSoft2: rgba(234,240,255,.18);

      --pillActiveBg: rgba(0,229,255,.12);
      --pillActiveBorder: rgba(0,229,255,.28);
    }

    [data-theme="neutral"]{
      --bg0:#06080E; --bg1:#0B111B; --card:#0F1927; --card2:#0B1422;
      --accent:#A3BFFA; --accent2:#38BDF8;

      --glow1: rgba(163,191,250,.16);
      --glow2: rgba(56,189,248,.12);
      --glow3: rgba(255,176,32,.05);

      --gradA: rgba(163,191,250,.34);
      --gradB: rgba(56,189,248,.14);
      --bannerA: rgba(163,191,250,.40);
      --bannerB: rgba(56,189,248,.12);

      --primaryBtnA: rgba(163,191,250,.78);
      --primaryBtnB: rgba(56,189,248,.22);

      --accentBright: rgba(163,191,250,.96);
      --accentSoft: rgba(163,191,250,.12);
      --accentSoft2: rgba(56,189,248,.16);

      --pillActiveBg: rgba(163,191,250,.12);
      --pillActiveBorder: rgba(163,191,250,.26);
    }


    [data-theme="cream"]{
      --bg0:#F7F2E8; --bg1:#F2ECE1; --card:#FFFFFF; --card2:#FBF6EE;
      --ink:#141414; --muted:#4D4D4D; --muted2:#6A6A6A;
      --accent:#C08B4A; --accent2:#2F6F68;
      --line:rgba(0,0,0,.08);
      --shadow: 0 20px 70px rgba(0,0,0,.14);
      --shadow2: 0 10px 40px rgba(0,0,0,.10);

      --glow1: rgba(192,139,74,.12);
      --glow2: rgba(47,111,104,.10);
      --glow3: rgba(0,0,0,.04);

      --gradA: rgba(192,139,74,.22);
      --gradB: rgba(47,111,104,.10);
      --bannerA: rgba(192,139,74,.20);
      --bannerB: rgba(47,111,104,.08);

      --primaryBtnA: rgba(20,20,20,.92);
      --primaryBtnB: rgba(20,20,20,.76);

      --accentBright: rgba(20,20,20,.92);
      --accentSoft: rgba(192,139,74,.12);
      --accentSoft2: rgba(47,111,104,.10);

      --pillActiveBg: rgba(192,139,74,.14);
      --pillActiveBorder: rgba(192,139,74,.24);
    }

    [data-theme="noir"]{
      --bg0:#000000; --bg1:#020203; --card:#07070A; --card2:#030305;
      --accent:#EAF0FF; --accent2:#9AA7C7;
      --line:rgba(255,255,255,.10);

      --glow1: rgba(234,240,255,.10);
      --glow2: rgba(154,167,199,.10);
      --glow3: rgba(255,255,255,.04);

      --gradA: rgba(234,240,255,.18);
      --gradB: rgba(154,167,199,.10);
      --bannerA: rgba(234,240,255,.16);
      --bannerB: rgba(154,167,199,.08);

      --primaryBtnA: rgba(234,240,255,.85);
      --primaryBtnB: rgba(154,167,199,.18);

      --accentBright: rgba(234,240,255,.92);
      --accentSoft: rgba(234,240,255,.10);
      --accentSoft2: rgba(154,167,199,.12);

      --pillActiveBg: rgba(234,240,255,.10);
      --pillActiveBorder: rgba(234,240,255,.18);
    }
    [data-theme="retro"]{
      --bg0:#090513; --bg1:#120A22; --card:#1A1032; --card2:#140A2A;
      --accent:#FF3D81; --accent2:#FFB020;

      --glow1: rgba(255,61,129,.18);
      --glow2: rgba(255,176,32,.12);
      --glow3: rgba(42,207,194,.08);

      --gradA: rgba(255,61,129,.36);
      --gradB: rgba(255,176,32,.16);
      --bannerA: rgba(255,61,129,.44);
      --bannerB: rgba(255,176,32,.14);

      --primaryBtnA: rgba(255,61,129,.78);
      --primaryBtnB: rgba(255,176,32,.26);

      --accentBright: rgba(255,61,129,.96);
      --accentSoft: rgba(255,61,129,.12);
      --accentSoft2: rgba(255,176,32,.14);

      --pillActiveBg: rgba(255,61,129,.12);
      --pillActiveBorder: rgba(255,61,129,.28);
    }


/* ===== Global font enforcement (ensure elegant font everywhere) ===== */
html, body, body * { font-family: var(--font) !important; }

/* ===== Fix readiness number centering (force true center) ===== */
#cardReadiness .ring .center{ position:absolute; inset:0; display:grid; place-items:center; transform:none; }
#cardReadiness .ring .center .val{ display:block; }

/* ===== Explicit Goals spacing improvements ===== */
.goalCard{ padding:18px; }
.adhRow{ margin-top:16px; align-items:flex-end; }
.adhRow .k{ line-height:1.25; }
.adhRow .v{ line-height:1.25; font-weight:800; font-size:12px; }
.prog{ height:12px; margin-top:10px; margin-bottom:14px; }
.formGrid{ gap:14px; }
.subList{ gap:12px; }

/* ===== End-session modal layout + styling fixes ===== */
.grid-2{
  display:grid;
  grid-template-columns: 1.05fr .95fr;
  gap:14px;
  align-items:start;
}
@media (max-width: 980px){
  .grid-2{ grid-template-columns: 1fr; }
}
.boxTitle{
  font-size:12px;
  font-weight:950;
  letter-spacing:.12em;
  text-transform:uppercase;
  color: rgba(234,240,255,.86);
  margin-bottom:10px;
  margin-top:4px;
  padding-top:4px;
}
.endGrid{ display:flex; flex-direction:column; gap:12px; }
.endLine{
  padding:12px 14px;
  border-radius:18px;
  background: rgba(255,255,255,.03);
  border:1px solid rgba(255,255,255,.08);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
}
.endTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin-bottom:10px;
  margin-top:4px;
  padding-top:4px;
}
.endLbl{
  font-size:11px;
  letter-spacing:.14em;
  text-transform:uppercase;
  color: var(--muted2);
  font-weight:950;
  margin:0;
}
.endVal{
  font-weight:950;
  color: rgba(234,240,255,.92);
  font-variant-numeric: tabular-nums;
}
.endLine input[type="range"]{ width:100%; margin-top:2px; }

/* Close (X) button — subtle, no white block */
button.x{
  appearance:none;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: rgba(234,240,255,.88);
  width:38px;
  height:38px;
  border-radius:14px;
  cursor:pointer;
  font-weight:950;
  line-height:1;
  display:grid;
  place-items:center;
  transition: transform .12s ease, background .12s ease, border-color .12s ease;
}
button.x:hover{
  transform: translateY(-1px);
  background: rgba(255,255,255,.06);
  border-color: rgba(255,255,255,.16);
}

/* Distraction pills row spacing */
.chipRow{ display:flex; flex-wrap:wrap; gap:10px; }

    .customDistract{ margin-top:14px; padding:12px; border-radius:14px; background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); }





/* ===== v11 fixes ===== */
#page-overview .title .s{ display:none !important; }

.modal{ display:flex; flex-direction:column; }
.modal .mbody{ flex:1 1 auto; }
.modal .mfoot{
  flex:0 0 auto;
  display:flex;
  justify-content:flex-end;
  gap:10px;
  padding:14px 16px;
  border-top:1px solid rgba(255,255,255,.06);
  background: linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.18));
}

.timerSettingsBtn, .fullSettingsBtn{
  position:absolute;
  left:12px;
  top:12px;
  width:38px; height:38px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.05);
  color: rgba(234,240,255,.92);
  cursor:pointer;
  display:grid;
  place-items:center;
  font-weight:950;
  transition: transform .12s ease, background .12s ease, border-color .12s ease;
  z-index:6;
}
.timerSettingsBtn:hover, .fullSettingsBtn:hover{
  transform: translateY(-1px);
  background: rgba(255,255,255,.07);
  border-color: rgba(255,255,255,.18);
}
.viewMenu{
  position:absolute;
  left:12px;
  top:56px;
  width: 200px;
  border-radius:18px;
  padding:10px;
  background: radial-gradient(700px 240px at 10% 0%, rgba(255,255,255,.10), transparent 60%),
              rgba(10,14,25,.88);
  border:1px solid rgba(255,255,255,.12);
  box-shadow: var(--shadow2);
  backdrop-filter: blur(16px);
  opacity:0;
  visibility:hidden;
  transform: translateY(-6px);
  transition: opacity 160ms cubic-bezier(.2,.8,.2,1), transform 160ms cubic-bezier(.2,.8,.2,1);
  z-index:7;
}
.viewMenu.show{ opacity:1; visibility:visible; transform: translateY(0); }
.viewMenu button{
  width:100%;
  text-align:left;
  border:0;
  cursor:pointer;
  padding:10px 12px;
  border-radius:14px;
  background: rgba(255,255,255,.04);
  color: rgba(234,240,255,.92);
  font-weight:850;
  letter-spacing:.02em;
  display:flex; justify-content:space-between; align-items:center;
  transition: background .12s ease, transform .12s ease;
}
.viewMenu button + button{ margin-top:8px; }
.viewMenu button:hover{ background: rgba(255,255,255,.07); transform: translateY(-1px); }
.viewMenu button.active{
  background: linear-gradient(135deg, rgba(124,92,255,.55), rgba(38,213,198,.18));
  box-shadow: 0 14px 34px rgba(0,0,0,.35);
}

.timerVisual--ring .timerRing svg{ filter: drop-shadow(0 24px 60px rgba(0,0,0,.55)) drop-shadow(0 0 18px rgba(124,92,255,.22)); }
.timerVisual--bar .timerBar .bar i{ box-shadow: 0 18px 50px rgba(0,0,0,.40), 0 0 16px rgba(38,213,198,.18); }

/* bar settle animation removed (replaced by subtle width transitions + overview nudge) */
65%{ width: calc(var(--to, 0%) + 1%); }
      100%{ width: var(--to, 0%); }
    }


    /* PATCH: Analytics range select styling (match aesthetic) */
    .select{
      appearance:none;
      -webkit-appearance:none;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: rgba(234,240,255,.92);
      padding:10px 38px 10px 12px;
      border-radius:14px;
      font-weight:850;
      letter-spacing:.02em;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
      cursor:pointer;
      position:relative;
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(234,240,255,.70) 50%),
        linear-gradient(135deg, rgba(234,240,255,.70) 50%, transparent 50%);
      background-position:
        calc(100% - 18px) 55%,
        calc(100% - 12px) 55%;
      background-size:6px 6px, 6px 6px;
      background-repeat:no-repeat;
    }
    .select:focus{
      outline:none;
      border-color: rgba(124,92,255,.40);
      box-shadow: 0 0 0 4px rgba(124,92,255,.14);
      background-color: rgba(255,255,255,.06);
    }
    .select option{ background: var(--bg1); color: rgba(234,240,255,.92); }


    /* Goals: Auto-goals lock visuals + adherence layout fixes */
    #page-goals .formGrid.goalsLocked .lockable{
      opacity:.58;
      filter:saturate(.85);
      background: rgba(255,255,255,.03);
    }
    #page-goals .formGrid.goalsLocked .lockable .inp{
      background: rgba(0,0,0,.10);
    }
    #page-goals .formGrid.goalsLocked .lockable .lbl,
    #page-goals .formGrid.goalsLocked .lockable .small{
      color: rgba(234,240,255,.78);
    }

    /* Ensure adherence rows stack vertically (avoid flex-row bullets/odd artifacts) */
    #page-goals .adhGrid{ display:flex; flex-direction:column; gap:12px; }
    #page-goals .adhRow{
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:10px;
      padding:12px;
      border-radius:16px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
      margin-top:0;
    }
    #page-goals .adhTop{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    #page-goals .adhLbl{ font-size:12px; color:var(--muted); line-height:1.25; }
    #page-goals .adhVal{ font-size:12px; color:var(--ink); font-weight:800; line-height:1.25; }
    #page-goals .bar{ height:10px; border-radius:999px; background: rgba(255,255,255,.08); overflow:hidden; display:flex; align-items:center; }
    #page-goals .barFill{ height:100%; border-radius:999px; background: linear-gradient(90deg, rgba(124,92,255,.9), rgba(84,217,255,.9)); width:0%; }


    /* ===== End session modal layout improvements (PDF v4) ===== */
    .softWrap{
      background: rgba(255,255,255,.035);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 18px;
      padding: 12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .endNotesFull{
      margin-top: 12px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 18px;
      padding: 12px;
    }
    .customDistract{
      margin-top: 12px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(0,0,0,.16);
      border: 1px solid rgba(255,255,255,.08);
    }

    /* Auto-goals blocked feedback */
    .shake{ animation: st_shake 360ms cubic-bezier(.2,.9,.2,1); }
    @keyframes st_shake{
      0%{ transform: translateX(0); }
      20%{ transform: translateX(-5px); }
      40%{ transform: translateX(5px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
      100%{ transform: translateX(0); }
    }
    .pulse{ animation: st_pulse 420ms cubic-bezier(.2,.9,.2,1); transform-origin: left center; }
    @keyframes st_pulse{
      0%{ transform: scale(1); }
      55%{ transform: scale(1.04); }
      100%{ transform: scale(1); }
    }

    /* ===== Guided tour overlay ===== */
    .tourOverlay{
      position: fixed; inset: 0;
      display: none;
      z-index: 9999;
      pointer-events: none;
    }
    .tourOverlay.show{ display: block; }
    .tourDim{
      position:absolute; inset:0;
      background: transparent;
      backdrop-filter: none;
      display:none;
    }
    .tourHole{
      position:absolute;
      border-radius: 18px;
      box-shadow: 0 0 0 9999px rgba(0,0,0,.62);
      outline: 2px solid rgba(255,255,255,.14);
      pointer-events: none;
    }
    .tourCard{
      position:absolute;
      pointer-events: auto;
      width: min(420px, calc(100vw - 24px));
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 22px;
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .tourTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .tourStep{ color: var(--muted); font-weight: 750; font-size: 12px; letter-spacing: .03em; }
    .tourTitle{ margin-top: 10px; font-weight: 950; font-size: 16px; }
    .tourBody{ margin-top: 8px; color: var(--muted); line-height: 1.4; font-size: 13px; }
    .tourFoot{ margin-top: 12px; display:flex; justify-content:flex-end; }


    /* ===== Settings accordion (rows with expand arrows) ===== */
    .settingsStack{ display:flex; flex-direction:column; gap:12px; }
    
    /* Settings accordion: hide subtitles when collapsed */
    .accCard.collapsed .head .s{ display:none; }
.accCard .head{ cursor:pointer; user-select:none; }
    .accCard .accArrow{
      margin-left:auto;
      width:34px; height:34px;
      display:grid; place-items:center;
      border-radius:12px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.08);
      color: var(--muted);
      transition: transform .18s cubic-bezier(.2,.8,.2,1), background .18s;
    }
    .accCard:not(.collapsed) .accArrow{ transform: rotate(180deg); background: rgba(255,255,255,.07); }
    .accCard.collapsed .accBody{ display:none; }

    /* Slight emphasis when blocked features pulse */
    .pulseBig{ transform: scale(1.06); font-weight: 700; }

    /* Ensure Explicit Goals styles apply inside Settings as well */



/* Moved from accidental trailing text (goals lock visuals) */
#settingsGoals .formGrid.goalsLocked .lockable{
      opacity:.58;
      filter:saturate(.85);
      background: rgba(255,255,255,.03);
    }
    #settingsGoals .formGrid.goalsLocked .lockable .inp{
      background: rgba(0,0,0,.10);
    }
    #settingsGoals .formGrid.goalsLocked .lockable .lbl,
    #settingsGoals .formGrid.goalsLocked .lockable .small{
      color: rgba(234,240,255,.78);
    }
    #settingsGoals .adhGrid{ display:flex; flex-direction:column; gap:12px; }
    #settingsGoals .adhRow{
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:10px;
      padding:12px;
      border-radius:16px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
      margin-top:0;
    }
    #settingsGoals .adhTop{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    #settingsGoals .adhLbl{ font-size:12px; color:var(--muted); line-height:1.25; }
    #settingsGoals .adhVal{ font-size:12px; color:var(--ink); font-weight:800; line-height:1.25; }
    #settingsGoals .bar{ height:10px; border-radius:999px; background: rgba(255,255,255,.08); overflow:hidden; display:flex; align-items:center; }
    #settingsGoals .barFill{ height:100%; border-radius:999px; background: linear-gradient(90deg, rgba(124,92,255,.9), rgba(84,217,255,.9)); width:0%; }

/* ===== Settings compact headers (per PDF feedback) ===== */
#page-settings .settingsStack{ gap:10px; }
#page-settings .card.accCard{ min-height:auto; padding:12px 14px; }
#page-settings .card.accCard .head{ padding:0; align-items:center; }
#page-settings .card.accCard .title{ gap:2px; }
#page-settings .card.accCard .title .s{ margin-top:2px; }
#page-settings .card.accCard .accArrow{ width:32px; height:32px; }
#page-settings .card.accCard .accBody{ margin-top:10px; }



    /* --- Patch: UI refinements --- */
    /* Prevent the "single dot" ring artifact at 0% progress */
    #timerRingArc, #fullTimerRingArc{ opacity:0; transition: opacity .18s ease; }

    /* Readiness: subtle glow that follows the ring color */
    #readinessArc{ filter: drop-shadow(0 0 7px var(--rgGlowA)); }

    /* Retention alerts: use full width and distribute items laterally */
    @media (min-width: 900px){
      #cardRetention .list{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
      #cardRetention .list > *{ margin:0; }
    }

    /* Analytics: improve legibility of the key numbers */
    #page-analytics .minirow{
      border:1px solid rgba(255,255,255,.06);
      border-radius:16px;
      padding:10px 12px;
      background: rgba(255,255,255,.03);
    }
    #page-analytics .minirow > div:first-child{ color: var(--muted2); font-weight: 800; }
    #page-analytics .minirow > div:last-child{ font-size: 16px; font-weight: 950; }

    /* Timer controls: reduce visual "shake" from layout shifts */
    .timerBtns{ min-height: 54px; }
    #timerHint{ min-height: 18px; display:block; }


    /* ===== PDF follow-up improvements ===== */
    /* Onboarding: hide auto weekly target line (kept internally) */
    #baseWeeklyAutoText{ display:none !important; }

    /* Onboarding Baselines: make the 4 boxes align and match proportions */
    #onboardStep2 .form{ align-items:stretch; }
    #onboardStep2 .field{ min-height: 104px; display:flex; flex-direction:column; justify-content:flex-start; }
    #onboardStep2 .field .row{ align-items:center; }
    #onboardStep2 .inp, #onboardStep2 .sel{ height:40px; }

    #tourSkipBtn{ display:none !important; }
    .tourDim{ display:none !important; }
    .tourOverlay{ pointer-events:none; }
    .tourCard{ pointer-events:auto; }
    /* Readiness ring: bigger, thicker, no boxed glow */
    #cardReadiness svg{ overflow: visible; }
    #cardReadiness #readinessArc{ filter: drop-shadow(0 0 8px var(--rgGlowA)) drop-shadow(0 0 3px var(--rgGlowB)); }
    #cardReadiness .ring{ transform: none; max-width: 100%; }
    #cardReadiness .ring .center{ position:absolute; inset:0; display:grid; place-items:center; transform:none; }
    #cardReadiness .ringWrap{ padding-top: 2px; padding-bottom: 10px; overflow:hidden; }
    /* Cognitive strain card: bigger % + target chip lower */
    #cardStrain .num{ font-size: 56px; line-height: 1.0; }
    #cardStrain .chip{ margin-top: 16px; }


    /* Split card stack (strain + consistency) */
    #cardStrain.strainStack{ display:flex; flex-direction:column; gap:12px; padding:12px; }
    #cardStrain.strainStack .subcard{
      flex:1;
      border-radius: calc(var(--r) - 4px);
      padding:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.07);
      box-shadow: 0 10px 34px rgba(0,0,0,.25);
      overflow:hidden;
    }
    #cardStrain.strainStack .subcard .head{ margin-bottom: 10px; }

    /* Split card stack (balance + ended early) */
    #cardBalance.strainStack{ display:flex; flex-direction:column; gap:12px; padding:12px; }
    #cardBalance.strainStack .subcard{
      flex:1;
      border-radius: calc(var(--r) - 4px);
      padding:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.07);
      box-shadow: 0 10px 34px rgba(0,0,0,.25);
      overflow:hidden;
    }
    #cardBalance.strainStack .subcard .head{ margin-bottom: 10px; }


    /* Tour completion toast (visually richer, non-intrusive) */
    .tourDoneToast{ border: 1px solid var(--accentSoft); position:fixed; right:18px; bottom:18px; z-index:70; }
    .tourDoneToast .t{ font-weight: 950; }
    .tourDoneToast::before{
      content:"";
      position:absolute;
      inset:-1px;
      border-radius: 22px;
      background: radial-gradient(120px 80px at 18% 20%, var(--accentSoft2), transparent 70%),
                  radial-gradient(140px 90px at 78% 40%, rgba(52,211,153,.12), transparent 70%);
      pointer-events:none;
      z-index:-1;
    }

    /* ===== PDF (7) patches ===== */
    /* Prevent accidental text selection (allow inputs/textarea) */
    body, .wrap, .page, .tabbar, .card, .btn, .pill, .pillBig, .chip, .mini, h1, h2, h3, h4, p, span, div{
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    input, textarea, select, option{
      -webkit-user-select: text;
      user-select: text;
    }

    /* Cognitive strain target chip: lift slightly (avoid border collision) */
    #subStrain .chip{ margin-top: 10px; }

    /* Setup (Baselines) boxes: consistent sizing/alignment */
    #onboardStep2 .form .field{ min-height: 132px; }
    #onboardStep2 .form .row .sel{ flex:1; }
    #onboardStep2 .form .row .inp{ flex:1; }
    #onboardStep2 .form .unitGhost{ opacity:0; }

    /* Feedback textarea */
    textarea.inp{ resize: vertical; min-height: 120px; line-height: 1.4; }

    /* Responsive tweaks (no user action required) */
    @media (max-width: 980px){
      #onboardStep2 .form{ grid-template-columns: repeat(2, 1fr) !important; }
    }
    @media (max-width: 560px){
      #onboardStep2 .form{ grid-template-columns: 1fr !important; }
      .stats-mini{ display:none; } /* keeps topbar clean on narrow phones */
    }
    @media (max-height: 520px) and (orientation: landscape){
      .topbar{ padding-top: 10px; padding-bottom: 10px; }
      .page{ padding-top: 14px; }
      .modal{ max-height: 92vh; }
    }



/* ===== v10: Start Session hover stability + Strain target spacing + Readiness ring tweaks ===== */
/* Remove hover "lift" movement ONLY within Start Session tab */
#page-start .card:hover,
#page-start .card:focus-within{ transform:none !important; }
#page-start .btn:hover,
#page-start .pill button:hover,
#page-start .viewBtn:hover,
#page-start .glassPills .pillBig:hover{ transform:none !important; }
/* Keep press feedback (active) unchanged */

/* Cognitive strain: ensure target chip never kisses the bottom edge */
#cardStrain #subStrain .metric{ padding-bottom:10px; }

/* Readiness ring: slightly larger + thicker, but contained */
#cardReadiness .ring{ width:min(240px, 100%); height:min(240px, 100%); }
#cardReadiness .ringWrap{ padding-bottom: 12px; }
#readinessInterpret{
  margin-top: 8px;
  text-align: center;
  color: var(--muted);
  font-weight: 750;
  font-size: 12px;
  line-height: 1.35;
  white-space: pre-line;
  padding: 0 6px 2px;
}

    /* Insight banner */
    .insightBanner{
      border-radius: 18px;
      padding: 12px 14px;
      background: radial-gradient(900px 260px at 10% 0%, rgba(255,255,255,.10), transparent 60%),
                  linear-gradient(135deg, rgba(124,92,255,.16), rgba(38,213,198,.10));
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: var(--shadow2);
    }
    .insightTop{
      display:flex; align-items:center; gap:10px;
      margin-bottom: 8px;
    }
    .insightLeft{ display:flex; gap:8px; align-items:center; }
    .insightTitle{ font-weight:900; letter-spacing:.2px; }
    .insightBody{ color: var(--ink); font-weight:700; line-height:1.45; }
    .insightBtn{
      width:28px; height:28px; border-radius:10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: var(--ink);
      display:inline-flex; align-items:center; justify-content:center;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, opacity .12s ease;
      user-select:none;
    }
    .insightBtn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
    .insightBtn:active{ transform: translateY(0px) scale(.98); }
    .insightBtn.ok{ background: rgba(38,213,198,.14); }
    .insightBtn.no{ background: rgba(255,80,80,.10); }
    .insightBanner.fadeOut{ animation: insightFade .18s ease forwards; }
    @keyframes insightFade{ to{ opacity:0; transform: translateY(-4px); } }

  
/* ===== PDF v19 patches (streak + next plan + analytics spacing) ===== */

/* Chart info icon (deep work) */
.chartWrap{ position: relative; }
.chartInfo{
  position:absolute;
  top:10px; right:10px; left:auto;
  width:22px; height:22px;
  border-radius:999px;
  display:grid; place-items:center;
  font-weight:950;
  font-size:12px;
  background: rgba(0,0,0,.35);
  border: 1px solid rgba(255,255,255,.14);
  color: rgba(255,255,255,.88);
  backdrop-filter: blur(10px);
  cursor: help;
}
.chartInfo:hover{ background: rgba(0,0,0,.45); }

/* Sessions ended early: make value feel "inside" the card */
#subEndedEarly .minirow{ align-items:center; }
#endedEarlyWeekVal{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  min-width: 44px;
  padding: 6px 10px;
  border-radius: 999px;
  background: rgba(124,92,255,.14);
  border: 1px solid rgba(124,92,255,.26);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
}


    /* ===== PDF v6: Reward pill + commit bonus + finish coach ===== */
    .rewardPill{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translate(-50%, 12px) scale(.985);
      width: min(560px, calc(100vw - 24px));
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 999px;
      background: rgba(13,20,42,.82);
      backdrop-filter: blur(var(--blur));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 26px 90px rgba(0,0,0,.58);
      opacity: 0;
      pointer-events: none;
      z-index: 9998;
      transition: opacity .22s ease, transform .22s cubic-bezier(.2,.9,.2,1);
    }
    .rewardPill.show{
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, 0) scale(1);
    }
    .rewardIcon{
      width: 38px;
      height: 38px;
      border-radius: 16px;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: rgba(0,0,0,.78);
      box-shadow: 0 14px 44px rgba(0,0,0,.35);
      font-weight: 950;
      letter-spacing: .01em;
      flex: 0 0 auto;
    }
    .rewardLines{ min-width: 0; }
    .rewardLines .l1{ font-weight: 950; font-size: 13px; line-height: 1.15; }
    .rewardLines .l2{ margin-top: 3px; font-size: 12px; color: var(--muted); line-height: 1.2; }

    .commitBonus{
      display: none;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
      font-size: 12px;
      color: var(--ink);
    }

    .commitBonus .cbRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .commitBonus .cbText{ font-weight:750; color: rgba(234,240,255,.92); line-height:1.2; }
    .commitBonus .cbSub{ display:block; margin-top:3px; font-weight:650; color: rgba(234,240,255,.70); }
    .commitBonus .cbBtns{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .commitBonus .cbBtn{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(234,240,255,.92);
      border-radius: 999px;
      padding: 6px 10px;
      font: inherit;
      font-size: 12px;
      font-weight: 800;
      cursor: pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      white-space: nowrap;
    }
    .commitBonus .cbBtn:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.22); background: rgba(255,255,255,.08); }
    .commitBonus .cbBtn.primary{ border-color: rgba(124,92,255,.45); background: rgba(124,92,255,.16); }

    .commitBonus b{ font-weight: 950; }
    .commitBonus .muted{ color: var(--muted); font-weight: 750; }

    .finishCoach{
      display:none;
      margin-top: 10px;
      padding: 12px;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.04));
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .finishCoach .t{ font-weight: 950; font-size: 13px; }
    .finishCoach .s{ margin-top: 6px; color: var(--muted); font-size: 12px; line-height: 1.35; }
    .finishCoach .pillHint{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(124,92,255,.16);
      border: 1px solid rgba(124,92,255,.30);
      font-weight: 900;
      font-size: 12px;
    }


/* ===========================
   Mobile-first polish (v38)
   - Better fit on popular phone viewports
   - Bottom tab bar on mobile
   - Inputs sized to avoid iOS zoom
   =========================== */
@media (max-width: 860px){
  .topbar{flex-wrap:wrap;}
  .stats-mini{width:100%; overflow-x:auto; -webkit-overflow-scrolling:touch; padding-bottom:6px;}
  .mini{min-width:110px;}
}
@media (max-width: 720px){
  .wrap{margin:12px auto; padding:0 10px;}
  .page{padding-bottom: 110px;} /* room for fixed tabbar */
  .tabbar{
    position: fixed;
    left: 10px; right: 10px; bottom: 10px; top: auto;
    z-index: 90;
    border-radius: 18px;
    box-shadow: var(--shadow2);
    background: linear-gradient(180deg, rgba(15,22,42,.92), rgba(9,13,26,.88));
    border: 1px solid rgba(255,255,255,.08);
    backdrop-filter: blur(10px);
  }
  .tabbtn{padding:10px 12px; font-size: 13px;}
  /* Make common two-col layouts collapse cleanly */
  .row{flex-wrap:wrap;}
  .split{grid-template-columns: 1fr !important;}
  .grid{gap:12px;}
  /* Forms and inputs */
  input, select, textarea{font-size:16px;} /* prevent iOS auto-zoom */
  .field{grid-column: span 12 !important;}
  /* Cards spacing */
  .card{border-radius: 20px;}
  /* Charts / tables: allow horizontal scroll instead of squish */
  .chart, .chartbox, .tableWrap, .table, table{max-width:100%;}
  .tableWrap{overflow-x:auto; -webkit-overflow-scrolling:touch;}
}
@media (max-width: 520px){
  .topbar{gap:10px;}
  h1{font-size:18px;}
  .tabbtn{padding:10px 10px;}
  /* Rings & big visuals */
  .ring, .ring svg{width: 140px !important; height: 140px !important;}
  .ringWrap{gap:10px;}
  /* Modals become near full-screen */
  .overlay{padding:10px !important;}
  .modal{width: 100% !important; border-radius: 18px !important;}
  .modal .body{max-height: calc(100vh - 120px); overflow:auto;}
  /* Long button rows wrap */
  .btnrow, .timerBtns, .chiprow{flex-wrap:wrap;}
}

/* ===========================
   Mobile Simulator (desktop dev tool)
   =========================== */
.simShell{position:fixed; right:14px; bottom:14px; z-index: 9999; pointer-events:none;}
.simToggle{
  pointer-events:auto;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(13,20,42,.78);
  backdrop-filter: blur(10px);
  color: var(--ink);
  border-radius: 999px;
  padding: 10px 12px;
  font-weight: 900;
  box-shadow: var(--shadow2);
}
.simPanel{
  pointer-events:auto;
  position: fixed;
  right: 14px;
  bottom: 64px;
  width: min(520px, calc(100vw - 28px));
  height: min(820px, calc(100vh - 90px));
  background: rgba(9,13,26,.94);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 22px;
  box-shadow: var(--shadow);
  backdrop-filter: blur(12px);
  display: none;
  overflow: hidden;
}
.simPanel.open{display:flex; flex-direction:column;}
.simHdr{
  display:flex; align-items:center; justify-content:space-between;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,.08);
}
.simTitle{font-weight: 900; font-size: 13px; letter-spacing:.2px; color: var(--ink);}
.simClose{
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: var(--ink);
  border-radius: 10px;
  padding: 6px 10px;
  font-weight: 900;
}
.simControls{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,.08);
}
.simControls label{display:flex; flex-direction:column; gap:6px; font-size:11px; color: var(--muted); font-weight:800;}
.simControls select, .simControls input[type="range"]{
  width:100%;
  border-radius: 12px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: var(--ink);
  padding: 8px 10px;
}
.simControls .span2{grid-column: span 2;}
.simStage{flex:1; display:flex; align-items:center; justify-content:center; padding: 10px; overflow:auto;}
.simPhone{
  position: relative;
  border-radius: 34px;
  border: 10px solid rgba(0,0,0,.55);
  background: #000;
  box-shadow: 0 30px 90px rgba(0,0,0,.60);
  transform-origin: top center;
}
.simNotch{
  position:absolute; top:0; left:50%; transform:translateX(-50%);
  width: 44%; height: 26px;
  background: rgba(0,0,0,.65);
  border-bottom-left-radius: 18px;
  border-bottom-right-radius: 18px;
  z-index: 2;
  pointer-events:none;
}
#simFrame{
  width:100%;
  height:100%;
  border:0;
  border-radius: 24px;
  background: #070A12;
}

/* Hide simulator inside embedded preview */
body.embed .simShell, body.embed .simPanel{display:none !important;}
@media (max-width: 980px){
  /* Don't clutter small screens with simulator controls */
  .simShell, .simPanel{display:none !important;}
}

</style>
</head>
<body data-theme="midnight">

<!-- Mobile Simulator (desktop dev tool) -->
<div class="simShell" id="simShell">
  <button class="simToggle" id="simToggle" type="button" title="Open mobile simulator">📱 Mobile preview</button>
</div>

<div class="simPanel" id="simPanel" role="dialog" aria-label="Mobile simulator">
  <div class="simHdr">
    <div class="simTitle">Mobile simulator</div>
    <button class="simClose" id="simClose" type="button" aria-label="Close">✕</button>
  </div>

  <div class="simControls">
    <label>
      Device
      <select id="simDevice"></select>
    </label>
    <label>
      Orientation
      <select id="simOrient">
        <option value="portrait">Portrait</option>
        <option value="landscape">Landscape</option>
      </select>
    </label>
    <label class="span2">
      Scale
      <input id="simScale" type="range" min="40" max="120" value="72" />
    </label>
  </div>

  <div class="simStage">
    <div class="simPhone" id="simPhone" aria-label="Device frame">
      <div class="simNotch" aria-hidden="true"></div>
      <iframe id="simFrame" title="Mobile preview"></iframe>
    </div>
  </div>
</div>

<div class="wrap">
<div class="topbar">
<div class="brand">
<div aria-hidden="true" class="logo"></div>
<h1>StudyPulse</h1>
</div>
<div class="stats-mini">
<div class="mini">
<div class="v" id="miniStreak">0</div>
<div class="k">Day streak</div>
</div>
<div class="mini">
<div class="v" id="miniSessions">0</div>
<div class="k">Sessions</div>
</div>
<div class="mini">
<div class="v" id="miniTime">0h</div>
<div class="k">Total time</div>
</div>
</div>
</div>
<div aria-label="Navigation tabs" class="tabbar" role="tablist">
<button aria-selected="true" class="tabbtn active" data-tab="overview" role="tab">Overview</button>
<button aria-selected="false" class="tabbtn" data-tab="start" role="tab">Start Session</button>
<button aria-selected="false" class="tabbtn" data-tab="analytics" role="tab">Analytics</button>
<button aria-selected="false" class="tabbtn" data-tab="settings" role="tab">Settings</button>
<div class="spacer"></div>
</div>
<!-- OVERVIEW -->
<section class="page active" id="page-overview">
<div class="banner bannerSlim" id="recBanner">
<div class="btitle">
<div class="h">Recommended next session</div>
<div class="p" id="recText">Set up subjects or projects in Settings to unlock recommendations.</div>
<div class="small" id="recSub">Recommended based on readiness + your history.</div>
<div class="small" id="recConf" style="margin-top:4px; opacity:.92;"></div>
<div class="recRows" id="recRows" style="margin-top:10px;">
<div class="recRow">
<div>
<b>Duration</b>
<div class="small" id="recDurWhy">—</div>
</div>
<div id="recDuration" style="font-weight:950;">-- min</div>
</div>
<div class="recRow">
<div>
<b>Method</b>
<div class="small" id="recMethWhy">—</div>
</div>
<div id="recMethod" style="font-weight:950;">--</div>
</div>
<div class="recRow">
<div>
<b>Subject</b>
<div class="small" id="recSubjWhy">—</div>
</div>
<div id="recSubject" style="font-weight:950;">--</div>
</div>
</div>
</div>
<div style="display:flex; gap:10px; align-items:center;">
<button class="btn" id="btnGoStart">Start now 🚀</button>
</div>
</div>
<div class="insightBanner" id="insightBanner" style="margin-top:12px; margin-bottom:12px; display:none;">
<div class="insightTop">
<div class="insightLeft">
<button aria-label="Mark insight as read" class="insightBtn ok" id="insightOk" type="button">✓</button>
<button aria-label="Hide insight" class="insightBtn no" id="insightNo" type="button">✕</button>
</div>
<div class="insightTitle">Coach insight</div>
</div>
<div class="insightBody" id="insightText">—</div>
<div class="small" id="insightMeta" style="opacity:.78; margin-top:6px;">Updates more frequently as you build data.</div>
</div>
<div class="grid">
<!-- Row 1 -->
<div class="card big span-4 strainStack" id="cardStrain">
<div class="subcard" id="subStrain">
<div class="head">
<div class="title">
<div class="t">Cognitive strain</div>
<div class="s" id="strainSub">Sessions today: 0</div>
</div>
<div class="info" data-tip="Strain is a daily workload estimate from your sessions (duration × difficulty × distraction penalty). It resets at midnight.">i</div>
</div>
<div class="metric metricCenter">
<div class="num" id="strainVal">0%</div>
<div class="chip" id="strainTargetChip">Target: --%</div>
</div>
</div>
<div class="subcard" id="subConsistency">
<div class="head">
<div class="title">
<div class="t">Consistency index</div>
<div class="s">Steadiness (7D)</div>
</div>
<div class="info" data-tip="Consistency index measures how steady your daily minutes are across the last 7 days. It uses the coefficient of variation (std ÷ mean) and maps it to a 0–100 score. Higher is steadier.">i</div>
</div>
<div class="metric metricCenter">
<div class="num" id="consistencyVal">--</div>
<div class="sub" id="consistencyNote">Log a few days to estimate steadiness</div>
</div>
</div>
</div>
<div class="card big span-4" id="cardReadiness">
<div class="head">
<div class="title">
<div class="t">Cognitive readiness ⚡</div>
<div class="s"></div>
</div>
<div class="info" data-tip="Readiness comes from your daily check-in (sleep quality, stress, motivation, clarity) and decreases with strain across the day. Resets at midnight.">i</div>
</div>
<div class="ringWrap">
<div class="ring">
<svg aria-hidden="true" height="100%" viewbox="0 0 180 180" width="100%">
<defs>
<lineargradient id="readinessGrad" x1="0" x2="1" y1="0" y2="1">
<stop offset="0%" stop-color="var(--rgA)"></stop>
<stop offset="100%" stop-color="var(--rgB)"></stop>
</lineargradient>
</defs>
<defs>
<lineargradient id="rg" x1="0" x2="1" y1="0" y2="1">
<stop offset="0" stop-color="var(--rgA)"></stop>
<stop offset="1" stop-color="var(--rgB)"></stop>
</lineargradient>
</defs>
<circle cx="90" cy="90" fill="none" r="70" stroke="rgba(255,255,255,.08)" stroke-width="24"></circle>
<circle cx="90" cy="90" fill="none" id="readinessArc" r="70" stroke="url(#readinessGrad)" stroke-dasharray="439.823" stroke-dashoffset="439.823" stroke-linecap="round" stroke-width="24"></circle>
</svg>
<div class="center">
<div class="val" id="readinessVal">--</div>
</div>
</div>
<div id="readinessInterpret">Complete a daily check-in to interpret readiness.</div>
</div>
</div>

<div class="card big span-4 strainStack" id="cardBalance">
  <div class="subcard" id="subBalance">
<div class="head">
<div class="title">
<div class="t">Strain / recovery balance</div>
<div class="s">Balance ratio (7D)</div>
</div>
<div class="info" data-tip="Balance compares recent strain vs average readiness. If strain stays high while readiness stays low, burnout risk rises.">i</div>
</div>
<div class="minirow">
<div><b>Balance Ratio (7D)</b></div>
<div id="balanceVal" style="font-weight:950;">--</div>
</div>
<div class="bar" style="margin-top:10px;"><i class="barFill" id="balanceBar"></i></div>
<div class="minirow" style="margin-top:12px;">
<div><b>Pacing indicator</b>: <span class="muted" id="pacingText">--</span></div>
<div class="chip" id="pacingBadge">--</div>
</div>

  
  </div>
  <div class="subcard" id="subEndedEarly">
    <div class="head">
      <div class="title">
        <div class="t">Sessions ended early</div>
        <div class="s"></div>
      </div>
      <div class="info" data-tip="Counts how many sessions you stopped before the planned timer finished (this week). Useful for spotting planning issues or low readiness.">i</div>
    </div>
    <div class="minirow"><div>Total (this week)</div><div id="endedEarlyWeekVal" style="font-weight:950;">--</div></div>
    <div class="small" id="endedEarlyWeekNote" style="margin-top:10px;">--</div>
  </div>
</div>
<!-- Row 2 -->
<div class="card span-4" id="cardFocus">
<div class="head">
<div class="title">
<div class="t">Quality-weighted minutes 🎯</div>
<div class="s">Today</div>
</div>
<div class="info" data-tip="Quality-weighted minutes = Σ minutes × (quality/5) for today. This rewards both duration and session quality.">i</div>
</div>
<div class="metric metricCenter">
<div class="num" id="focusVal">--</div>
<div class="sub" id="focusNote">Log sessions to build the trend</div>
</div>
</div>
<div class="card span-4" id="cardLastQuality">
<div class="head">
<div class="title">
<div class="t">Last session quality index</div>
<div class="s">Quality</div>
</div>
<div class="info" data-tip="Last session quality blends focus, learning value, confidence gain, and distraction penalty.">i</div>
</div>
<div class="metric metricCenter">
<div class="num" id="lastQualityVal">--</div>
<div class="sub" id="lastQualityLabel">--</div>
</div>
</div>
<div class="card span-4" id="cardTodayTarget">
<div class="cardTop">
<div>
<div class="cardTitle">Today vs target</div>
</div>
</div>
<div class="metric metricCenter" id="todayMetric">
<div class="big" id="todayProgressText">0/0 minutes</div>
<div class="small" id="todayStrainText">strain 0.0 / target 10–14</div>
</div>
<div class="bar">
<div class="barFill" id="todayProgressBar" style="width:0%;"></div>
</div>
</div>
<div class="card span-4" id="cardDailyTotal">
<div class="cardTop">
<div>
<div class="cardTitle">Daily total</div>
</div>
</div>
<div class="metric">
<div class="big" id="dailyTotalText">0m</div>
<div class="bar" style="margin-top:10px;">
<div class="barFill" id="dailyTotalBar" style="width:0%;"></div>
</div>
<div class="small" id="dailyTotalNote">0% of today’s goal</div>
</div>
</div>
<div class="card span-4" id="cardWindow">
<div class="head">
<div class="title">
<div class="t">Avg session distractions</div>
<div class="s">Improving vs last week</div>
</div>
<div class="info" data-tip="Compares your average number of distractions per session this week vs last week. Lower is better.">i</div>
</div>
<div class="metric metricCenter">
<div class="num" id="windowVal">--</div>
<div class="sub" id="windowNote">Needs more sessions to learn your patterns</div>
</div>
</div>
<div class="card span-4" id="cardBurnout">
<div class="head">
<div class="title">
<div class="t">Burnout risk</div>
<div class="s">Risk level (7D)</div>
</div>
<div class="info" data-tip="Burnout risk rises when 7-day strain is high and your readiness has been trending low.">i</div>
</div>
<div class="minirow">
<div id="burnoutLabel"><b>Low</b></div>
<div id="burnoutVal" style="font-weight:950;">--/100</div>
</div>
<div class="small" id="burnoutNote" style="margin-top:10px;">--</div>
</div>
<div class="card span-12" id="cardRetention">
<div class="head">
<div class="title">
<div class="t">Retention risk alerts</div>
<div class="s">Review priority</div>
</div>
<div class="info" data-tip="Retention risk increases as time passes since you last studied a subject. It’s a practical spaced-review prompt.">i</div>
</div>
<div class="list" id="retentionList">
<div class="small">Add at least one subject in Settings to see retention alerts (projects are excluded).</div>
</div>
</div>
</div>
</section>
<!-- START SESSION -->
<section class="page" id="page-start">
<div class="two">
<div class="card tall">
<div class="head">
<div class="title">
<div class="t">Session configuration ⚙️</div>
<div class="s"></div>
</div>
</div>
<div class="form">
<div class="field" style="grid-column: span 2;">
<label>Subject / research</label>
<select id="sessSubject"></select>
</div>
<div class="field">
<label>Timer (minutes)</label>
<input id="sessMinutes" max="240" min="5" type="number" value="25"/>
</div>
<div class="field" style="grid-column: span 1;">
<label>Mode</label>
<select id="sessMode">
<option selected="" value="countdown">Countdown</option>
<option value="free">Free mode (stopwatch)</option>
</select>
</div>
<div class="field" style="grid-column: span 4;">
<label>Method</label>
<select id="sessMethod" style="display:none;">
<option selected="" value="Practice">Practice problems</option>
<option value="Recall">Active recall</option>
<option value="Flashcards">Flashcards</option>
<option value="Notes">Notes / summary</option>
<option value="Reading">Reading</option>
<option value="Essay">Writing / essay</option>
</select>
<div class="pillrow" id="sessMethodRow" style="margin-top:0;"></div>
<div class="row" style="gap:10px; align-items:center; margin-top:10px;">
<input class="inp" id="sessMethodCustom" placeholder="Add custom method (press Enter)" style="flex:1"/>
<button class="btn" id="btnAddSessMethod" type="button">Add</button>
</div>
</div>
<div class="field" style="grid-column: span 4;">
<label>Active session</label>
<div class="small" id="activeSessionLabel">Not started</div>
</div>
<div class="card timerCard">
<div class="head">
<div class="title">
<div class="t">Timer</div>
<div class="s"></div>
</div>
</div>
<div class="timer timerVisual--digital" id="timerVisual">
<div class="time" id="timerDisplay">25:00</div>
<div aria-hidden="true" class="timerRing" id="timerRing">
<svg height="210" viewbox="0 0 210 210" width="210">
<defs>
<lineargradient id="timerGrad" x1="0" x2="1" y1="0" y2="1">
<stop offset="0%" stop-color="var(--accent)"></stop>
<stop offset="100%" stop-color="var(--accent2)"></stop>
</lineargradient>
</defs>
<circle cx="105" cy="105" fill="none" id="timerRingArc" r="86" stroke="url(#timerGrad)" stroke-dasharray="540.354" stroke-dashoffset="540.354" stroke-linecap="round" stroke-width="18"></circle>
</svg>
</div>
<div aria-hidden="true" class="timerBar" id="timerBar">
<div class="bar"><i id="timerBarFill"></i></div>
<div class="timerBarMeta">
<span id="timerBarLeft">--</span>
<span id="timerBarRight">--</span>
</div>
</div>
<div class="hint" id="timerHint">Ready when you are.</div>
<div class="commitBonus" id="commitBonusPill" aria-live="polite"></div>

</div>
<!-- Controls moved UNDER the timer (as requested) -->
<div class="timerBtns">
<button class="btn" id="btnResetTimer">Reset</button>
<button class="btn primary" id="btnStartStop">Start session</button>
<button class="btn" id="btnFullscreen">Fullscreen timer</button>
<button class="btn finishTint" id="btnStopAndLog">Finish &amp; log</button>
</div>
</div>
</div>
</div></div></section>
<section class="page" id="page-analytics">
<div class="grid">
<div class="card span-12">
<div class="head">
<div class="title">
<div class="t">Weekly performance summary</div>
</div>
<div class="info" data-tip="Summary cards computed from the last 7 days: time distribution, quality metrics, and your learned peak learning hour.">i</div>
</div>
<div class="grid" style="gap:12px;">
<div class="card span-4" style="min-height:140px;">
<div class="head">
<div class="title">
<div class="t">Time distribution</div>
</div>
</div>
<div class="minirow"><div>Total study time</div><div id="anTotalTime" style="font-weight:950;">--</div></div>
<div class="minirow"><div>Avg session length</div><div id="anAvgLen" style="font-weight:950;">--</div></div>
<div class="minirow"><div>Longest session</div><div id="anLongest" style="font-weight:950;">--</div></div>
</div>
<div class="card span-4" style="min-height:140px;">
<div class="head">
<div class="title">
<div class="t">Quality metrics</div>
</div>
</div>
<div class="minirow"><div>Avg quality</div><div class="valDelta"><div id="anAvgQuality" style="font-weight:950;">--</div><span class="deltaPill neutral" id="anAvgQualityDelta">—</span></div></div>
<div class="minirow"><div>Avg focus</div><div class="valDelta"><div id="anAvgFocus" style="font-weight:950;">--</div><span class="deltaPill neutral" id="anAvgFocusDelta">—</span></div></div>
<div class="minirow"><div>Avg distractions</div><div class="valDelta"><div id="anAvgDistr" style="font-weight:950;">--</div><span class="deltaPill neutral" id="anAvgDistrDelta">—</span></div></div>
</div>
<div class="card span-4" style="min-height:140px;">
<div class="head">
<div class="title">
<div class="t">Peak learning hour</div>
</div>
</div>
<div class="minirow"><div>Best hour</div><div id="anPeakHour" style="font-weight:950;">--</div></div>
<div class="minirow"><div>Avg quality</div><div id="anPeakConf" style="font-weight:950;">--</div></div>
<div class="minirow"><div>Sample size</div><div id="anPeakN" style="font-weight:950;">--</div></div>
</div>
</div>
</div>
<div class="card span-12">
<div class="head">
<div class="title">
<div class="t">Analytics</div>
</div>
</div>
<div class="grid" style="margin-top:12px; gap:12px;">
<div class="card span-6" style="min-height:320px;">
<div class="head">
<div class="title">
<div class="t">Quality vs duration scatter</div>
</div>
</div>
<div class="chartWrap"><canvas id="gScatter"></canvas></div>
</div>
<div class="card span-6" style="min-height:320px;">
<div class="head">
<div class="title">
<div class="t">Quality by method</div>
</div>
</div>
<div class="chartWrap"><canvas id="gMethod"></canvas></div>
</div>
<div class="card span-6" style="min-height:320px;">
<div class="head">
<div class="title">
<div class="t">3) Time-of-day heatmap</div>
</div>
</div>
<div class="chartWrap"><canvas id="gHeat"></canvas></div>
</div>
<div class="card span-6" style="min-height:320px;">
<div class="head">
<div class="title">
<div class="t">Deep work rate over time</div>
</div>
</div>
<div class="chartWrap"><div class="chartInfo info" data-tip="Deep work is inferred from your end-of-session inputs. A session is counted as deep work when: duration ≥ 45 min, distractions ≤ 1, focus ≥ 4, and frustration ≤ 2.">i</div><canvas id="gDeepRate"></canvas></div>
</div>
<div class="card span-12" style="min-height:320px;">
<div class="head">
<div class="title">
<div class="t">Top distractions</div>
</div>
</div>
<div class="chartWrap"><canvas id="gPareto"></canvas></div>
</div>
<div class="card span-12" style="min-height:320px;">
<div class="head">
<div class="title">
<div class="t">Readiness vs session quality</div>
</div>
</div>
<div class="chartWrap"><canvas id="gReadyOutcome"></canvas></div>
</div>
</div>
<!-- Weekly Summary kept exactly, but no longer a separate tab -->
</div>
</div></section>
<!-- SETTINGS -->
<section class="page" id="page-settings"><div class="settingsStack"><div class="card accCard collapsed" id="cardExplicitGoals"><div class="head"><div class="title"><div class="t">Explicit goals</div><div class="s">Targets + adherence</div></div><div class="accArrow">▾</div></div><div class="accBody"><div class="goalsMoved" id="settingsGoals"><div class="goalsGrid">
<!-- Left: explicit goals -->
<div class="goalCard">
<div class="goalHdr">
<div>
<div class="h">EXPLICIT GOALS</div>
</div>
</div>
<div class="formGrid" id="goalsFormGrid">
<div class="field autoField" style="grid-column: span 2;">
<div class="row" style="justify-content:space-between; align-items:center; gap:12px;">
<div>
<div class="lbl" style="margin:0;">Auto-goals</div>
<div class="small" id="autoGoalsHint">Suggestions are based on the last 14 days and gently push you upward.</div>
</div>
<label class="switch" style="margin-left:auto;">
<input id="goalAutoEnabled" type="checkbox"/>
<span class="slider"></span>
</label>
</div>
<div class="small" id="autoGoalsPreview" style="margin-top:10px;"></div>
</div>
<div class="field lockable">
<div class="lbl">Daily study minutes</div>
<input class="inp" id="goalWeeklyMin" max="720" min="0" placeholder="e.g., 120" step="5" type="number"/>
</div>
<div class="field lockable">
<div class="lbl">Average session length target (min)</div>
<input class="inp" id="goalAvgLen" max="600" min="5" placeholder="45" step="5" type="number"/>
<div class="small">Used for adherence as your average minutes per session this week.</div>
</div>
<div class="field lockable">
<div class="lbl">Preferred start window (from)</div>
<input class="inp" id="goalStartFrom" type="time"/>
</div>
<div class="field lockable">
<div class="lbl">Preferred start window (to)</div>
<input class="inp" id="goalStartTo" type="time"/>
</div>
<input id="goalSessionsPerWeek" type="hidden" value="8"/>
<div class="field lockable" style="grid-column: span 2;">
<div class="row" style="justify-content:space-between; align-items:center;">
<div class="lbl" style="margin:0;">Average quality target</div>
<div class="small"><b id="goalQualityVal">4/5</b></div>
</div>
<input class="inp" id="goalQuality" max="5" min="1" step="1" type="range" value="4"/>
<div class="row" style="justify-content:space-between;">
<span class="small">Low</span>
<span class="small">High</span>
</div>
</div>
<div class="row" style="justify-content:flex-end; gap:10px; margin-top:6px; grid-column: span 2;">
<button class="btn" id="resetGoalsBtn" type="button">Reset</button>
</div>
</div>
</div>
</div></div></div></div>
<div class="card accCard collapsed" id="cardOverviewLayout"><div class="head">
<div class="title">
<div class="t">Overview layout</div>
<div class="s"></div>
</div>
<div class="accArrow">▾</div></div><div class="accBody">
<div class="small" style="margin-top:8px;">Toggle what appears in Overview. Tracking continues even when hidden.</div>
<div class="endGrid" id="overviewLayoutList" style="margin-top:12px;"></div>
</div></div>
<div class="card accCard collapsed" id="cardStrict"><div class="head">
<div class="title">
<div class="t">Strict mode</div>
</div>
<div class="accArrow">▾</div></div><div class="accBody">
<div class="small" style="margin-top:6px;">When enabled: (1) you must complete the daily check-in before starting a session, (2) subject + method are required, and (3) you must rate the session before saving.</div>
<div class="row" style="justify-content:space-between; align-items:center; margin-top:8px;">
<div>
<div style="font-weight:850;">Enforce required inputs</div>
<div class="small">Recommended if you want cleaner analytics.</div>
</div>
<label class="switch" style="flex:0 0 auto;">
<input id="strictToggle" type="checkbox"/>
<span class="slider"></span>
</label>
</div>
</div></div>
<div class="card accCard collapsed" id="cardCheckinTime"><div class="head">
<div class="title">
<div class="t">Daily check-in</div>
<div class="s">Schedule</div>
</div>
<div class="accArrow">▾</div></div><div class="accBody">
<div class="small" style="margin-top:6px;">Set when the daily check-in should appear. </div>
<div class="form" style="grid-template-columns: repeat(2, 1fr); margin-top:10px;">
<div class="field" style="grid-column: span 2;">
<div class="lbl">Preferred check-in time</div>
<input class="inp" id="settingCheckinTime" type="time" value="20:00"/>
<div class="small" id="settingCheckinNextHint" style="margin-top:6px;"></div>
</div>
</div>
<div class="row" style="justify-content:flex-end; gap:10px; margin-top:8px;">
<button class="btn" id="btnOpenCheckinNow" type="button">Open check-in now</button>
</div>
</div></div>
<div class="card accCard collapsed" id="cardSubjects"><div class="head">
<div class="title">
<div class="t">Subjects & Projects</div>
<div class="s">Subjects are traditional classes. Projects are non-subject academic work (e.g., TOK, EE, CAS, IA drafts).</div>
</div>
<div class="accArrow">▾</div></div><div class="accBody">
<div class="small" style="margin-bottom:6px;">Subjects</div>
<div class="pillrow" id="subjectChips"></div>
<div class="hr"></div>
<div class="small">Add a subject</div>
<input class="txt" id="newSubject" placeholder="e.g., IB Maths"/>
<div style="display:flex; justify-content:flex-end; gap:10px; margin-top:10px;">
<button class="btn primary" id="btnAddSubject">Add subject</button>
</div>

<div class="hr" style="margin:14px 0;"></div>

<div class="small" style="margin-bottom:6px;">Academic projects</div>
<div class="pillrow" id="projectChips"></div>
<div class="hr"></div>
<div class="small">Add a project</div>
<input class="txt" id="newProject" placeholder="e.g., TOK essay, EE research"/>
<div style="display:flex; justify-content:flex-end; gap:10px; margin-top:10px;">
<button class="btn primary" id="btnAddProject">Add project</button>
</div>
</div></div>
<div class="card accCard collapsed" id="cardTheme"><div class="head">
<div class="title">
<div class="t">Theme</div>
<div class="s">Choose the overall look</div>
</div>
<div class="accArrow">▾</div></div><div class="accBody">
<div style="display:flex; gap:10px; flex-wrap:wrap; margin-top: 8px;">
<button class="btn" data-theme-btn="midnight">Midnight</button>
<button class="btn" data-theme-btn="aurora">Aurora</button>
<button class="btn" data-theme-btn="ember">Ember</button>
<button class="btn" data-theme-btn="ocean">Ocean</button>
<button class="btn" data-theme-btn="grape">Grape</button>
<button class="btn" data-theme-btn="forest">Forest</button>
<button class="btn" data-theme-btn="mono">Mono</button>
<button class="btn" data-theme-btn="blackout">Blackout</button>
<button class="btn" data-theme-btn="neutral">Neutral</button>
<button class="btn" data-theme-btn="cream">Cream</button>
<button class="btn" data-theme-btn="noir">Noir</button>
<button class="btn" data-theme-btn="retro">Retro</button>
</div>
</div></div>
<div class="card accCard collapsed" id="cardPopups"><div class="head">
<div class="title">
<div class="t">Pop-ups</div>
<div class="s">Control automatic overlays</div>
</div>
<div class="accArrow">▾</div></div><div class="accBody">
<div class="formGrid">
<div class="field autoField" style="grid-column: span 2;">
<div class="row" style="justify-content:space-between; align-items:center; gap:12px;">
<div>
<div class="lbl" style="margin:0;">Next session plan</div>
<div class="small">Shows when you open Start Session.</div>
</div>
<label class="switch" style="margin-left:auto;">
<input id="popupNextPlan" type="checkbox"/>
<span class="slider"></span>
</label>
</div>
</div>
<div class="field autoField" style="grid-column: span 2;">
<div class="row" style="justify-content:space-between; align-items:center; gap:12px;">
<div>
<div class="lbl" style="margin:0;">Coach</div>
<div class="small">Shows recommendations after your daily check-in.</div>
</div>
<label class="switch" style="margin-left:auto;">
<input id="popupCoach" type="checkbox"/>
<span class="slider"></span>
</label>
</div>
</div>
<div class="field autoField" style="grid-column: span 2;">
<div class="row" style="justify-content:space-between; align-items:center; gap:12px;">
<div>
<div class="lbl" style="margin:0;">Daily check-in</div>
<div class="small">Shows the daily check-in prompt automatically.</div>
</div>
<label class="switch" style="margin-left:auto;">
<input id="popupCheckin" type="checkbox"/>
<span class="slider"></span>
</label>
</div>
</div>
<div class="field autoField" style="grid-column: span 2;">
<div class="row" style="justify-content:space-between; align-items:center; gap:12px;">
<div>
<div class="lbl" style="margin:0;">Overview recommendation banner</div>
<div class="small">Shows the “Recommended next session” banner at the top of Overview.</div>
</div>
<label class="switch" style="margin-left:auto;">
<input id="popupRecBanner" type="checkbox"/>
<span class="slider"></span>
</label>
</div>
</div>
</div>
<div class="small" style="margin-top:10px;">
  Even with pop-ups off, you can still use the manual buttons (e.g., open check-in).
</div>
</div></div>
<div class="card accCard collapsed" id="cardFeedback">
<div class="head">
<div class="title">
<div class="t">Feedback</div>
<div class="s">Feature requests + bugs (saved locally)</div>
</div>
<div class="accArrow">▾</div>
</div>
<div class="accBody">
<div class="small" style="margin-bottom:10px;">
      Use this to jot bugs, UX friction, or feature requests. Until a backend exists, submissions are stored locally in your browser.
    </div>
<div class="formGrid">
<div class="field">
<label>Your email (optional)</label>
<input class="inp" id="fbEmail" placeholder="name@example.com" type="email"/>
</div>
<div class="field" style="grid-column: 1 / -1;">
<label>Feedback</label>
<textarea class="inp" id="fbText" placeholder="What’s working? What’s missing? What should be changed?" rows="5"></textarea>
</div>
</div>
<div style="display:flex; gap:10px; justify-content:flex-end; margin-top:10px;">
<button class="btn" id="fbClear" type="button">Clear</button>
<button class="btn primary" id="fbSave" type="button">Save feedback</button>
</div>
<div class="small" id="fbSavedNote" style="margin-top:10px;"></div>
</div>
</div>
<div class="card accCard collapsed" id="cardResetAll">
<div class="head">
<div class="title">
<div class="t">Reset all data</div>
<div class="s"></div>
</div>
<div class="accArrow">▾</div>
</div>
<div class="accBody">
<div class="small" style="margin-top:6px;">This will permanently remove all saved sessions, check-ins, goals, and settings on this device.</div>
<div style="display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px;">
<button class="btn danger" id="btnWipe" type="button">Reset all data</button>
</div>
</div>
</div></div></section>
</div>
<!-- Daily check-in modal -->
<div aria-hidden="true" class="modalBack" id="modalCheckinBack">
<div aria-label="Daily check-in" aria-modal="true" class="modal" role="dialog">
<div class="mhead">
<div>
<h3>Daily check-in ✨</h3>
<p>Quick inputs that set your readiness baseline for today.</p>
</div>
<button class="btn" id="btnCloseCheckin">Close</button>
</div>
<div class="mbody">
<div class="seg">
<div class="box">
<h4>Rested</h4>
<div class="scale">
<span class="small">Low</span>
<input id="ciSleepQ" max="5" min="1" type="range" value="3"/>
<span class="small">High</span>
</div>
<div class="small" id="ciSleepQVal">3/5</div>
</div>
<div class="box">
<h4>Stress</h4>
<div class="scale">
<span class="small">Low</span>
<input id="ciStress" max="5" min="1" type="range" value="3"/>
<span class="small">High</span>
</div>
<div class="small" id="ciStressVal">3/5</div>
</div>
<div class="box">
<h4>Motivation</h4>
<div class="scale">
<span class="small">Low</span>
<input id="ciMotivation" max="5" min="1" type="range" value="3"/>
<span class="small">High</span>
</div>
<div class="small" id="ciMotivationVal">3/5</div>
</div>
<div class="box">
<h4>Mental clarity</h4>
<div class="scale">
<span class="small">Low</span>
<input id="ciClarity" max="5" min="1" type="range" value="3"/>
<span class="small">High</span>
</div>
<div class="small" id="ciClarityVal">3/5</div>
</div>
</div>
<div class="hr"></div>
</div>
<div class="mfoot">
<button class="btn primary" id="btnSaveCheckin">Save check-in</button>
</div>
</div>
</div>
<div aria-hidden="true" class="modalBack" id="modalCoachBack">
<div aria-label="Coach recommendations" aria-modal="true" class="modal" role="dialog">
<div class="mhead">
<div>
<h3 id="coachTitle">Coach</h3>
<p id="coachSubtitle">Personalized recommendations</p>
</div>
<button class="btn" id="btnCloseCoach">Close</button>
</div>
<div class="mbody">
<div id="coachContent"></div>
</div>
<div class="mfoot">
<button class="btn primary" id="btnCoachDone">Done</button>
</div>
</div>
</div>
<div aria-hidden="true" class="modalBack" id="modalOnboardBack">
<div aria-label="First-time setup" aria-modal="true" class="modal" role="dialog">
<div class="mhead">
<div>
<h3 id="onboardTitle">Setup</h3>
<p id="onboardSubtitle">Step 1 of 3</p>
</div>
<button class="btn" id="btnCloseOnboard">Close</button>
</div>
<div class="mbody">
<div id="onboardStep1">
<div class="box" style="margin-bottom:12px;">
<h4>Subjects</h4>
<div class="small">Select the subjects you currently study. You can change these later in Settings.</div>
</div>
<div class="pillrow" id="onboardOptions"></div>
<div class="hr" style="margin:14px 0;"></div>
<div class="row" style="gap:10px; align-items:center;">
<input class="inp" id="onboardCustom" placeholder="Add custom subject (press Enter)" style="flex:1"/>
<button class="btn" id="btnAddOnboardCustom">Add</button>
</div>
<div class="hr" style="margin:14px 0;"></div>
<div class="box" style="margin-bottom:12px;">
  <h4>Academic projects</h4>
  <div class="small">Add non-subject academic work you still need to do (e.g., TOK, CAS, EE, IA drafts). You can change these later in Settings.</div>
</div>
<div class="pillrow" id="onboardProjects"></div>
<div class="hr" style="margin:14px 0;"></div>
<div class="row" style="gap:10px; align-items:center;">
  <input class="inp" id="onboardProjectCustom" placeholder="Add custom project (press Enter)" style="flex:1"/>
  <button class="btn" id="btnAddOnboardProjectCustom">Add</button>
</div>
<div class="hr" style="margin:14px 0;"></div>

<div style="display:flex; justify-content:flex-end; gap:10px; margin-top:10px;">
<button class="btn primary" id="btnOnboardNext" type="button">Next</button>
</div>
</div>
<div id="onboardStep2" style="display:none;">
<div class="box" style="margin-bottom:12px;">
<h4>Baselines</h4>
<div class="small">These calibrate your metrics to you (not to a generic default). Baselines automatically shift over time as you log sessions and daily check-ins.</div>
</div>
<div class="form" style="grid-template-columns: repeat(2, 1fr);">
<div class="field">
<label>Current study per day</label>
<div class="row">
<input class="inp" id="baseDailyMin" min="0" placeholder="e.g., 120" step="5" type="number"/>
<span class="unit">min</span>
</div>
</div>
<div class="field" style="grid-column: span 2;">
<label>Where you usually study</label>
<div class="pillrow" id="onboardPlaceRow" style="margin-top:0;"></div>
<div class="row" style="gap:10px; align-items:center; margin-top:10px;">
<input class="inp" id="onboardPlaceCustom" placeholder="Add custom place (press Enter)" style="flex:1"/>
<button class="btn" id="btnAddOnboardPlace" type="button">Add</button>
</div>
<input id="baseStudyPlace" type="hidden" value="desk"/>
</div>
<div class="field" style="grid-column: span 2;">
<label>Daily target study time</label>
<div class="row">
<input class="inp" id="baseTargetDailyMin" max="600" min="0" placeholder="e.g., 120" step="5" type="number"/>
<span class="unit">min</span>
</div>
<div class="small" id="baseWeeklyAutoText">Weekly target (auto): -- min</div>
<input id="baseWeeklyMin" type="hidden" value="0"/>
</div>
</div>
<div class="hr" style="margin:14px 0;"></div>
<div style="display:flex; justify-content:space-between; gap:10px; margin-top:10px;">
<button class="btn" id="btnOnboardBack" type="button">Back</button>
<button class="btn primary" id="btnOnboardNext2" type="button">Next</button>
</div>
<div class="small" id="onboardSaveNote" style="margin-top:10px;"></div>
</div>
<div id="onboardStep3" style="display:none;">
<div class="box" style="margin-bottom:12px;">
<h4>Daily check-in times</h4>
<div class="small">Choose when you want the morning and evening check-ins to appear. You can change this later in Settings.</div>
</div>
<div class="form" style="grid-template-columns: repeat(2, 1fr);">
<div class="field">
<label class="lbl">Morning check-in</label>
<input class="inp" id="onboardCheckinTimeAM" type="time" value="08:00"/>
</div>
<div class="field">
<label class="lbl">Evening check-in</label>
<input class="inp" id="onboardCheckinTimePM" type="time" value="18:00"/>
</div>
</div>
<div class="hr" style="margin:14px 0;"></div>
<div style="display:flex; justify-content:space-between; gap:10px; margin-top:10px;">
<button class="btn" id="btnOnboardBack2" type="button">Back</button>
<button class="btn primary" id="btnFinishOnboard" type="button">Finish setup</button>
</div>
<div class="small" id="onboardSaveNote3" style="margin-top:10px;"></div>
</div>
</div>
</div>
</div>
<!-- End session modal -->
<!-- Fullscreen timer overlay -->
<div aria-hidden="true" class="full timerVisual--digital" id="fullOverlay">
<div class="fullInner">
<div class="fullTop">
<div class="subj" id="fullSubject">--</div>
<button class="fullExit" id="fullExitBtn" type="button">Exit</button>
</div>
<div class="fullCenter">
<div class="timer" id="fullTimer" style="width:100%; max-width:720px; display:grid; place-items:center; position:relative;">
<div class="time fullTime" id="fullTime" style="font-size: clamp(84px, 10vw, 140px);">00:00</div>
<div aria-hidden="true" class="timerRing" id="fullTimerRing">
<svg height="320" viewbox="0 0 210 210" width="320">
<defs>
<lineargradient id="fullTimerGrad" x1="0" x2="1" y1="0" y2="1">
<stop offset="0%" stop-color="var(--accent)"></stop>
<stop offset="100%" stop-color="var(--accent2)"></stop>
</lineargradient>
</defs>
<circle cx="105" cy="105" fill="none" r="86" stroke="rgba(255,255,255,.08)" stroke-width="18"></circle>
<circle cx="105" cy="105" fill="none" id="fullTimerRingArc" r="86" stroke="url(#fullTimerGrad)" stroke-dasharray="540.354" stroke-dashoffset="540.354" stroke-linecap="round" stroke-width="18"></circle>
</svg>
</div>
<div aria-hidden="true" class="timerBar" id="fullTimerBar" style="position:relative; margin-top:18px; width:min(760px, 92%);">
<div class="bar"><i id="fullTimerBarFill"></i></div>
<div class="timerBarMeta">
<span id="fullTimerBarLeft">--</span>
<span id="fullTimerBarRight">--</span>
</div>
</div>
</div>
</div>
<div class="fullBottom">
<button class="btn" id="fullStartStop" type="button">Start</button>
<button class="btn" id="fullReset" type="button">Reset</button>
<button class="btn primary" id="fullFinish" type="button">Finish</button>
</div>
</div>
</div>
<!-- Tooltip + toast -->
<div aria-hidden="true" class="tip" id="tip"></div>
<div aria-hidden="true" class="toast" id="toast">
<div class="t" id="toastTitle">Saved</div>
<div class="m" id="toastMsg">Session logged.</div>
</div>

<div aria-hidden="true" class="rewardPill" id="rewardPill">
  <div class="rewardIcon">★</div>
  <div class="rewardLines">
    <div class="l1" id="rewardLine1">You gained +0 minutes toward today’s goal</div>
    <div class="l2" id="rewardLine2">Streak preserved ✅</div>
  </div>
</div>

<div aria-hidden="true" class="coachToast" id="coachToast">
<div class="coachTop">
<div class="coachHdr">
<div class="t coachTitle" id="coachToastTitle">Break recommendation</div>
<div class="small coachHint">Coach</div>
</div>
<div class="actions">
<button aria-label="Dismiss" id="coachDismissBtn" type="button">Dismiss</button>
</div>
</div>
<div class="m coachBody" id="coachMsg">Take a short break.</div>
<div class="meta" id="coachMeta"></div>
</div>
<div aria-hidden="true" class="coachToast tourDoneToast" id="tourDoneToast">
<div class="t" id="tourDoneTitle">Tour complete</div>
<div class="m" id="tourDoneMsg">You’re set. Explore the tabs and start logging sessions.</div>
<div class="meta" id="tourDoneMeta">Tip: Do a quick daily check-in to calibrate readiness.</div>
<div class="actions">
<button class="btn" id="tourDoneDismissBtn" type="button">Dismiss</button>
<button class="btn primary" id="tourDoneStartBtn" type="button">Start a session</button>
</div>
</div>
<!-- Next session plan overlay -->
<div aria-hidden="true" class="overlayBack" id="nextPlanBack">
<div aria-label="Next session plan" aria-modal="true" class="glassBox" role="dialog">
<div class="glassHead">
<div>
<div class="t">Next session plan</div>
<div class="s" id="nextPlanSubtitle">Recommended based on readiness + your history</div>
<div class="s" id="nextPlanConfidence" style="opacity:.92; margin-top:4px;"></div>
</div>
</div>
<div class="glassBody">
<div class="glassRow">
<div>
<b>Duration</b>
<div class="small" id="nextPlanDurWhy">—</div>
</div>
<div id="nextPlanDuration" style="font-weight:950;">-- min</div>
</div>
<div class="glassRow">
<div>
<b>Method</b>
<div class="small" id="nextPlanMethWhy">—</div>
</div>
<div id="nextPlanMethod" style="font-weight:950;">--</div>
</div>
<div class="glassRow">
<div>
<b>Subject</b>
<div class="small" id="nextPlanSubjWhy">—</div>
</div>
<div id="nextPlanSubject" style="font-weight:950;">--</div>
</div>
<div class="glassActions">
<button class="btn" id="nextPlanReject" type="button">Reject</button>
<button class="btn primary" id="nextPlanAccept" type="button">Accept &amp; apply</button>
</div>
</div>
</div>
</div>
<!-- Quick end reflection popover -->
<div aria-hidden="true" class="overlayBack" id="quickEndBack">
<div aria-label="Quick reflection" aria-modal="true" class="glassBox" role="dialog">
<div class="glassHead">
<div>
<div class="t">How did the session go?</div>
<div class="s">One click, then finish. You can add details if needed.</div>
</div>
<button aria-label="Close" class="x" id="quickEndClose">✕</button>
</div>
<div class="glassBody">
<div class="glassPills" id="quickEndChoices">
<div class="pillBig" data-preset="great">Great</div>
<div class="pillBig" data-preset="okay">Okay</div>
<div class="pillBig" data-preset="rough">Rough</div>
</div>
<div class="glassRow" style="justify-content:space-between; align-items:center;">
<div>
<b>Selected</b>
<div class="small" id="quickEndNote">Pick one option to enable Finish.</div>
</div>
<div id="quickEndSelected" style="font-weight:950;">—</div>
</div>
<div class="glassActions">
<button class="btn" id="quickEndDetails" type="button">Details</button>
<button class="btn primary finishTint" disabled="" id="quickEndFinish" type="button">Finish &amp; log</button>
</div>
</div>
</div>
</div>
<!-- End session modal -->
<div aria-hidden="true" class="modalBack" id="endModalBack">
<div aria-label="End session" aria-modal="true" class="modal" role="dialog">
<div class="mhead">
<div>
<div style="font-weight:950; font-size:16px;">Session ended</div>
<div class="small">Log outcomes only after a session ends.</div>
</div>
<button aria-label="Close" class="x" id="endModalClose">✕</button>
</div>
<div class="mbody">
<div class="grid-2">
<div class="box">
<div class="boxTitle">Ratings</div>
<div class="endGrid">
<div class="endLine">
<div class="endTop">
<div class="endLbl">Focus</div>
<div class="endVal"><span id="endFocusVal">3</span>/5</div>
</div>
<input id="endFocus" max="5" min="1" step="1" type="range" value="3"/>
</div>
<div class="endLine">
<div class="endTop">
<div class="endLbl">Retrieval success</div>
<div class="endVal"><span id="endRetrievalVal">3</span>/5</div>
</div>
<input id="endRetrieval" max="5" min="1" step="1" type="range" value="3"/>
</div>
<div class="endLine">
<div class="endTop">
<div class="endLbl">Perceived performance</div>
<div class="endVal"><span id="endPerfVal">3</span>/5</div>
</div>
<input id="endPerf" max="5" min="1" step="1" type="range" value="3"/>
</div>
<div class="endLine">
<div class="endTop">
<div class="endLbl">Effort</div>
<div class="endVal"><span id="endEffortVal">3</span>/5</div>
</div>
<input id="endEffort" max="5" min="1" step="1" type="range" value="3"/>
</div>
<div class="endLine">
<div class="endTop">
<div class="endLbl">Frustration</div>
<div class="endVal"><span id="endFrustrationVal">2</span>/5</div>
</div>
<input id="endFrustration" max="5" min="1" step="1" type="range" value="2"/>
</div>
</div>
</div>
<div>
<!-- Distractions wrap -->
<div class="softWrap" id="endDistractWrap">
<div class="boxTitle">Distractions</div>
<div class="chipRow" id="endDistractRow">
<span class="pillOpt" data-distr="Phone">Phone</span>
<span class="pillOpt" data-distr="Social">Social</span>
<span class="pillOpt" data-distr="Noise">Noise</span>
<span class="pillOpt" data-distr="People">People</span>
<span class="pillOpt" data-distr="Thoughts">Thoughts</span>
<span class="pillOpt" data-distr="Hunger">Hunger</span>
<span class="pillOpt" data-distr="Notifications">Notifications</span>
</div>
<div class="customDistract">
<div class="small" style="margin-bottom:10px;">Custom distraction</div>
<div class="row" style="gap:10px; align-items:center; width:100%;">
<input class="inp" id="endDistractCustom" placeholder="Type and add…" style="flex:1; min-width: 0;"/>
<button class="btn" id="endDistractAdd" style="flex:0 0 auto;" type="button">Add</button>
</div>
</div>
<div class="hint">Select the main sources. This will reduce session quality and help identify patterns.</div>
</div>
<!-- Environment wrap -->
<div class="softWrap" id="endEnvWrap" style="margin-top:12px;">
<div class="boxTitle">Environment / context</div>
<div class="pillrow" id="endEnvPresets" style="margin-top:10px;">
<div class="pillOpt" data-env="home">Home</div>
<div class="pillOpt" data-env="school">School</div>
<div class="pillOpt" data-env="library">Library</div>
<div class="pillOpt" data-env="cafe">Cafe</div>
<div class="pillOpt" data-env="classroom">Classroom</div>
<div class="pillOpt" data-env="quiet">Quiet</div>
<div class="pillOpt" data-env="noisy">Noisy</div>
<div class="pillOpt" data-env="music">Music</div>
<div class="pillOpt" data-env="phone-away">Phone away</div>
</div>
<div class="customDistract" style="margin-top:12px;">
<div class="small" style="margin-bottom:10px;">Custom environment / context</div>
<div class="row" style="gap:10px; align-items:center; width:100%;">
<input class="inp" id="endEnv" list="endEnvList" placeholder="Type and add…" style="flex:1; min-width:0;"/>
<button class="btn" id="endEnvAdd" style="flex:0 0 auto;" type="button">Add</button>
</div>
</div>
<datalist id="endEnvList">
<option value="home"></option>
<option value="school"></option>
<option value="library"></option>
<option value="cafe"></option>
<option value="classroom"></option>
<option value="study hall"></option>
</datalist>
<div class="hint" style="margin-top:10px;">Optional: helps you spot which environments correlate with better or worse sessions.</div>
</div>
</div>
</div>
<!-- Notes full width -->
<div class="endNotesFull">
<div class="boxTitle" style="margin-bottom:8px;">Optional notes</div>
<textarea class="ta" id="endNotes" placeholder="What worked / what didn’t (optional)" rows="5"></textarea>
<div id="endActions" style="display:flex; justify-content:flex-end; gap:10px; margin-top:12px;">
<button class="btn" id="discardEndBtn" type="button">Discard</button>
<button class="btn primary" id="saveEndBtn" type="button">Save session</button>
</div>
</div>
</div>
</div>
</div>
<!-- Guided tour overlay (new users, one-time) -->
<div aria-hidden="true" class="tourOverlay" id="tourOverlay">
<div class="tourDim"></div>
<div aria-hidden="true" class="tourHole" id="tourHole"></div>
<div aria-label="Tour" aria-modal="true" class="tourCard" id="tourCard" role="dialog">
<div class="tourTop">
<div class="tourStep" id="tourStepText">Step</div>
<button class="btn" id="tourSkipBtn" type="button">Skip</button>
</div>
<div class="tourTitle" id="tourTitle">Welcome</div>
<div class="tourBody" id="tourBody">Tour text</div>
<div class="tourFoot">
<button class="btn primary" id="tourNextBtn" type="button">Next</button>
</div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>


/**********************
 * StudyPulse (Merged build)
 * Front-end only — LocalStorage
 **********************/
const LS_KEY = "studytrack_v5";
const $ = (id)=>document.getElementById(id);
// ===== Supabase (browser-safe) =====
// Use ONLY the Publishable key (sb_publishable_...), never the secret key.
const SUPABASE_URL = https://dlrsyefsjlhokbtlupwz.supabase.co;
const SUPABASE_ANON_KEY = sb_publishable_v74m_5bLelbAVpbbiV7rvQ_ylzkquLz;

const supa = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const clamp = (v,min,max)=>{ v = Number(v); if(!Number.isFinite(v)) return min; return Math.max(min, Math.min(max, v)); };
const todayKey = ()=> new Date().toISOString().slice(0,10);
const now = ()=> Date.now();

const DEFAULT_SUBJECTS = ["Maths", "English", "Biology", "Chemistry", "Physics", "History", "Geography", "Computer Science", "Economics", "Business", "French", "Spanish", "German", "Literature", "Art", "Design & Technology"];
const DEFAULT_PROJECTS = ["TOK", "Extended Essay", "CAS", "IA Drafting", "University Applications", "Personal Statement", "Research", "Portfolio / PP", "Revision Plan", "Past Papers"];
const DEFAULT_PLACES = [
  {v:"desk",   label:"Desk / home"},
  {v:"library",label:"Library"},
  {v:"shared", label:"Shared space"},
  {v:"cafe",   label:"Café"},
  {v:"school", label:"School"},
  {v:"other",  label:"Other"},
];

const DEFAULT_AREAS = [
  {v:"bedroom",  label:"Bedroom"},
  {v:"living",   label:"Living room"},
  {v:"studyroom",label:"Study room"},
  {v:"kitchen",  label:"Kitchen / table"},
  {v:"outdoors", label:"Outdoors"},
  {v:"other",    label:"Other"},
];


// Overview cards (user can hide/show in Settings)
const OVERVIEW_CARDS = [
  { id:"cardStrain",      label:"Cognitive strain" },
  { id:"cardReadiness",   label:"Cognitive readiness" },
  { id:"cardBalance",     label:"Strain / recovery balance" },
  { id:"cardFocus",       label:"Focus score" },
  { id:"cardLastQuality", label:"Last session quality index" },
  { id:"cardTodayTarget", label:"Today vs target" },
  { id:"cardDailyTotal",  label:"Daily total" },
  { id:"cardWindow",      label:"Week performance" },
  { id:"cardBurnout",     label:"Burnout risk" },
  { id:"cardRetention",   label:"Retention risk alerts" },
];

function defaultOverviewVisibility(){
  const o = {};
  OVERVIEW_CARDS.forEach(c=>o[c.id]=true);
  return o;
}


const defaultState = ()=>({
  version: 5,
  settings: { theme: document.body.getAttribute("data-theme") || "midnight", strict:false, checkinTime:"20:00", overview: defaultOverviewVisibility(), prefWindow:"evening", prefPlace:"desk", prefPlaces:["desk"], prefArea:"", prefAreas:[], methods:["Practice","Recall","Flashcards","Notes","Reading","Essay"], popups:{nextPlan:true, coach:true, checkin:true} },
  subjects: [],
  projects: [],
  baselines: { dailyMin: 120, energy: 3, focus: 3, adapt: 0.18 },
  goals: { weeklyMin: 600, sessionsPerWeek: 8, strainMin: 200, strainMax: 420, perSubject: {} },
  dailyCheckins: {}, // date -> {sleepQ, stress, motivation, clarity, savedAt}
  sessions: [],       // session objects  schedule: { enabled:false, items:[] }, // scheduled activities
  ui: { lastOpenDate: todayKey(), lastCheckinPromptDate:"", onboarded:false, lastCheckinAt:0, lastCheckinPromptAt:0, tourDone:false, pendingTour:false },
  active: null        // {startTs, subject, method, mode, topic, plannedMin}
});

function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return defaultState();
    const s = JSON.parse(raw);
    // minimal migration guards
    if(!s.version) s.version = 5;
    if(!s.settings) s.settings = {theme:"midnight", strict:false, overview:null};
    if(!("overview" in s.settings) || !s.settings.overview) s.settings.overview = defaultOverviewVisibility();
    // fill any missing keys
    Object.keys(defaultOverviewVisibility()).forEach(k=>{ if(!(k in s.settings.overview)) s.settings.overview[k]=true; });

    // settings migrations
    if(!("checkinTime" in s.settings) || !s.settings.checkinTime) s.settings.checkinTime = "20:00";
    if(!("prefWindow" in s.settings) || !s.settings.prefWindow) s.settings.prefWindow = "evening";
    if(!("prefPlace" in s.settings) || !s.settings.prefPlace) s.settings.prefPlace = "desk";
    if(!Array.isArray(s.settings.prefPlaces) || !s.settings.prefPlaces.length){
      const pp = String(s.settings.prefPlace||"desk").trim() || "desk";
      s.settings.prefPlaces = [pp];
      s.settings.prefPlace = pp;
    }else{
      s.settings.prefPlace = String(s.settings.prefPlaces[0]||s.settings.prefPlace||"desk");
    }
    if(!Array.isArray(s.settings.prefAreas)) s.settings.prefAreas = (s.settings.prefArea ? [s.settings.prefArea] : []);
    if(!("prefArea" in s.settings)) s.settings.prefArea = s.settings.prefAreas[0] || "";
    if(!Array.isArray(s.settings.methods) || !s.settings.methods.length){
      s.settings.methods = ["Practice","Recall","Flashcards","Notes","Reading","Essay"];
    }

    

    // pop-up preferences (default on)
    if(!s.settings.popups) s.settings.popups = {nextPlan:true, coach:true, checkin:true};
    if(!("nextPlan" in s.settings.popups)) s.settings.popups.nextPlan = true;
    if(!("coach" in s.settings.popups)) s.settings.popups.coach = true;
    if(!("checkin" in s.settings.popups)) s.settings.popups.checkin = true;
if(!s.baselines) s.baselines = {dailyMin:120, energy:3, focus:3, adapt:0.18};
    if(!s.goals) s.goals = defaultState().goals;
    if(!Array.isArray(s.subjects)) s.subjects = [];
    if(!Array.isArray(s.projects)) s.projects = [];
    if(!Array.isArray(s.sessions)) s.sessions = [];
if(!s.dailyCheckins) s.dailyCheckins = {};
    if(!s.ui) s.ui = { lastOpenDate: todayKey(), lastCheckinPromptDate: "", onboarded: false, lastCheckinAt: 0, lastCheckinPromptAt: 0 };
    if(!("tourDone" in s.ui)) s.ui.tourDone = false;
    if(!("pendingTour" in s.ui)) s.ui.pendingTour = false;

    if(!("lastCheckinPromptDate" in s.ui)) s.ui.lastCheckinPromptDate = "";
    if(!("lastCheckinAt" in s.ui)) s.ui.lastCheckinAt = 0;
    if(!("lastCheckinPromptAt" in s.ui)) s.ui.lastCheckinPromptAt = 0;
    if(!("tourDone" in s.ui)) s.ui.tourDone = false;
    if(!("pendingTour" in s.ui)) s.ui.pendingTour = false;
    if(!("onboarded" in s.ui)) s.ui.onboarded = ((Array.isArray(s.subjects)&&s.subjects.length>0) || (Array.isArray(s.projects)&&s.projects.length>0));
    if(!("active" in s)) s.active = null;
    // ensure adapt is always present
// sanitize numeric fields (protect overview metrics from NaN/strings)
s.baselines.dailyMin = Number(s.baselines.dailyMin);
if(!Number.isFinite(s.baselines.dailyMin) || s.baselines.dailyMin<0) s.baselines.dailyMin = 120;
s.baselines.energy = clamp(Number(s.baselines.energy), 1, 5) || 3;
s.baselines.focus  = clamp(Number(s.baselines.focus),  1, 5) || 3;

s.goals.weeklyMin = Number(s.goals.weeklyMin);
if(!Number.isFinite(s.goals.weeklyMin) || s.goals.weeklyMin<0) s.goals.weeklyMin = 600;
s.goals.sessionsPerWeek = Number(s.goals.sessionsPerWeek);
if(!Number.isFinite(s.goals.sessionsPerWeek) || s.goals.sessionsPerWeek<0) s.goals.sessionsPerWeek = 8;

s.goals.strainMin = Number(s.goals.strainMin);
if(!Number.isFinite(s.goals.strainMin) || s.goals.strainMin<0) s.goals.strainMin = 200;
s.goals.strainMax = Number(s.goals.strainMax);
if(!Number.isFinite(s.goals.strainMax) || s.goals.strainMax<0) s.goals.strainMax = 420;

// coerce daily check-in entries to numbers when present
if(s.dailyCheckins && typeof s.dailyCheckins === "object"){
  Object.keys(s.dailyCheckins).forEach(k=>{
    const ci = s.dailyCheckins[k];
    if(!ci || typeof ci !== "object") return;
    ci.sleepQ = clamp(Number(ci.sleepQ), 1, 5) || 3;
    ci.stress = clamp(Number(ci.stress), 1, 5) || 3;
    ci.motivation = clamp(Number(ci.motivation), 1, 5) || 3;
    ci.clarity = clamp(Number(ci.clarity), 1, 5) || 3;
    if(ci.savedAt!==undefined) ci.savedAt = Number(ci.savedAt)||0;
  });
}
    s.baselines.adapt = computeAdaptRate(s.baselines);
    return s;
  }catch(e){
    console.warn("Failed to load state, resetting.", e);
    return defaultState();
  }
}

function saveState(){
  try{
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }catch(e){
    console.warn("Failed to save state.", e);
  }
}

let state = loadState();

/**********************
 * Theme
 **********************/
function syncThemeButtons(){
  const cur = document.body.getAttribute("data-theme") || "midnight";
  document.querySelectorAll("[data-theme-btn]").forEach(b=>{
    const t = b.getAttribute("data-theme-btn");
    if(t === cur) b.classList.add("primary");
    else b.classList.remove("primary");
  });
}

function applyTheme(theme){
  document.body.setAttribute("data-theme", theme);
  state.settings = state.settings || {};
  state.settings.theme = theme;
  saveState();
  syncThemeButtons();
}

/**********************
 * Onboarding
 **********************/
const onboard = {
  back: ()=>$("modalOnboardBack"),
  open(){
    if(!this.back()) return;
    this.back().classList.add("show");
    this.back().setAttribute("aria-hidden","false");
    showOnboardStep(1);
  },
  close(){
    if(!this.back()) return;
    this.back().classList.remove("show");
    this.back().setAttribute("aria-hidden","true");
  }
};

function ensureSubjectsSeeded(){
  if(state.subjects.length===0){
    // seed defaults but keep them unselected until onboarding
    state.subjects = [];
  }
}


function ensureProjectsSeeded(){
  state.projects = Array.isArray(state.projects) ? state.projects : [];
  if(state.projects.length===0){
    state.projects = [];
  }
}



function renderOnboardSubjects(){
  const wrap = $("onboardOptions");
  if(!wrap) return;
  wrap.innerHTML = "";
  const pool = Array.from(new Set([...DEFAULT_SUBJECTS, ...state.subjects]));
  const selected = new Set(state.subjects);
  pool.forEach(sub=>{
    const b = document.createElement("div");
    b.className = "pillOpt";
    b.textContent = sub;
    b.setAttribute("role","button");
    b.setAttribute("tabindex","0");
    if(selected.has(sub)) b.classList.add("active");
    b.addEventListener("click", ()=>{
      if(selected.has(sub)) selected.delete(sub);
      else selected.add(sub);
      state.subjects = Array.from(selected);
      renderOnboardSubjects();
  try{ wireOnboardStudyCustom(); }catch(e){}
  try{ renderOnboardStudyPills(); }catch(e){}

      renderSubjectChips();
      fillSessionSubjectSelect();
      saveState();
      updateAll();
      });
    wrap.appendChild(b);
  });

}

function renderOnboardProjects(){
  const wrap = $("onboardProjects");
  if(!wrap) return;
  wrap.innerHTML = "";
  state.projects = Array.isArray(state.projects) ? state.projects : [];
  const pool = Array.from(new Set([...DEFAULT_PROJECTS, ...state.projects]));
  const selected = new Set(state.projects);

  pool.forEach(name=>{
    const b = document.createElement("div");
    b.className = "pillOpt";
    b.textContent = name;
    b.setAttribute("role","button");
    b.setAttribute("tabindex","0");
    if(selected.has(name)) b.classList.add("active");
    b.addEventListener("click", ()=>{
      if(selected.has(name)) selected.delete(name);
      else selected.add(name);
      state.projects = Array.from(selected);
      renderOnboardProjects();
      renderProjectChips();
      fillSessionSubjectSelect();
      saveState();
      updateAll();
    });
    wrap.appendChild(b);
  });
}

function wireOnboardProjectCustom(){
  const addBtn = $("btnAddOnboardProjectCustom");
  const addInp = $("onboardProjectCustom");
  if(addBtn && addInp){
    const doAdd = ()=>{
      const v = (addInp.value||"").trim();
      if(!v) return;
      state.projects = Array.isArray(state.projects) ? state.projects : [];
      if(!state.projects.includes(v)) state.projects.push(v);
      addInp.value="";
      renderOnboardProjects();
      renderProjectChips();
      fillSessionSubjectSelect();
      saveState();
      updateAll();
    };
    addBtn.addEventListener("click", doAdd);
    addInp.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); doAdd(); } });
  }
}



function renderOnboardStudyPills(){
  // Places
  const placeWrap = $("onboardPlaceRow");
  const areaWrap = $("onboardAreaRow");
  const placeHidden = $("baseStudyPlace");
  const areaHidden = $("baseStudyArea");

  // Ensure arrays exist
  if(!Array.isArray(state.settings.prefPlaces) || !state.settings.prefPlaces.length){
    state.settings.prefPlaces = [state.settings.prefPlace || "desk"];
  }
  if(!Array.isArray(state.settings.prefAreas)) state.settings.prefAreas = (state.settings.prefArea ? [state.settings.prefArea] : []);

  const prefPlaces = new Set(state.settings.prefPlaces);
  const prefAreas = new Set(state.settings.prefAreas);

  const defaultPlaceVals = new Set(DEFAULT_PLACES.map(o=>o.v));
  const defaultAreaVals = new Set(DEFAULT_AREAS.map(o=>o.v));

  const poolPlaces = [
    ...DEFAULT_PLACES,
    ...Array.from(prefPlaces).filter(v=>v && !defaultPlaceVals.has(v)).map(v=>({v, label:v}))
  ];
  const poolAreas = [
    ...DEFAULT_AREAS,
    ...Array.from(prefAreas).filter(v=>v && !defaultAreaVals.has(v)).map(v=>({v, label:v}))
  ];

  const render = (wrap, pool, selected, onChange)=>{
    if(!wrap) return;
    wrap.innerHTML = "";
    pool.forEach(opt=>{
      const b = document.createElement("div");
      b.className = "pillOpt";
      b.textContent = opt.label;
      b.setAttribute("role","button");
      b.setAttribute("tabindex","0");
      if(selected.has(opt.v)) b.classList.add("active");
      b.addEventListener("click", ()=>{
        if(selected.has(opt.v)) selected.delete(opt.v);
        else selected.add(opt.v);
        onChange(Array.from(selected));
        // Re-render so selection colors update immediately (fix: pills looked unresponsive until a later render)
        try{ renderOnboardStudyPills(); }catch(e){}
      });
      wrap.appendChild(b);
    });
  };

  render(placeWrap, poolPlaces, prefPlaces, (vals)=>{
    // Require at least one place
    const cleaned = vals.filter(x=>String(x||"").trim());
    state.settings.prefPlaces = cleaned.length ? cleaned : ["desk"];
    state.settings.prefPlace = String(state.settings.prefPlaces[0]||"desk");
    if(placeHidden) placeHidden.value = state.settings.prefPlace;
    saveState();
  });

  render(areaWrap, poolAreas, prefAreas, (vals)=>{
    const cleaned = vals.filter(x=>String(x||"").trim());
    state.settings.prefAreas = cleaned;
    state.settings.prefArea = String(state.settings.prefAreas[0]||"");
    if(areaHidden) areaHidden.value = state.settings.prefArea;
    saveState();
  });
}

function wireOnboardStudyCustom(){
  const addPlace = ()=>{
    const inp = $("onboardPlaceCustom");
    const v = String(inp?.value||"").trim();
    if(!v) return;
    if(!Array.isArray(state.settings.prefPlaces)) state.settings.prefPlaces = [];
    const exists = state.settings.prefPlaces.some(x=>String(x).toLowerCase()===v.toLowerCase());
    if(!exists) state.settings.prefPlaces.push(v);
    state.settings.prefPlace = state.settings.prefPlaces[0] || v;
    if(inp) inp.value = "";
    renderOnboardStudyPills();
    saveState();
  };

  const addArea = ()=>{
    const inp = $("onboardAreaCustom");
    const v = String(inp?.value||"").trim();
    if(!v) return;
    if(!Array.isArray(state.settings.prefAreas)) state.settings.prefAreas = [];
    const exists = state.settings.prefAreas.some(x=>String(x).toLowerCase()===v.toLowerCase());
    if(!exists) state.settings.prefAreas.push(v);
    state.settings.prefArea = state.settings.prefAreas[0] || v;
    if(inp) inp.value = "";
    renderOnboardStudyPills();
    saveState();
  };

  $("btnAddOnboardPlace")?.addEventListener("click", addPlace);
  $("btnAddOnboardArea")?.addEventListener("click", addArea);

  $("onboardPlaceCustom")?.addEventListener("keydown", (e)=>{
    if(e.key==="Enter"){ e.preventDefault(); addPlace(); }
  });
  $("onboardAreaCustom")?.addEventListener("keydown", (e)=>{
    if(e.key==="Enter"){ e.preventDefault(); addArea(); }
  });
}

function showOnboardStep(n){
  const s1 = $("onboardStep1");
  const s2 = $("onboardStep2");
  const s3 = $("onboardStep3");
  if(!s1 || !s2) return;

  const total = s3 ? 3 : 2;
  const stepNum = clamp(n, 1, total);

  $("onboardSubtitle").textContent = `Step ${stepNum} of ${total}`;

  s1.style.display = (stepNum===1) ? "" : "none";
  s2.style.display = (stepNum===2) ? "" : "none";
  if(s3) s3.style.display = (stepNum===3) ? "" : "none";

  // update adapt display on baseline step
  if(stepNum===2){
    state.baselines.adapt = computeAdaptRate(state.baselines);
    if($("baseAdaptDisplay")) $("baseAdaptDisplay").textContent = state.baselines.adapt.toFixed(2);
  }

  // Pre-fill check-in times on the new step
  if(stepNum===3){
    const am = (state.settings && state.settings.checkinTimeAM) ? state.settings.checkinTimeAM : "08:00";
    const pm = (state.settings && state.settings.checkinTimePM) ? state.settings.checkinTimePM : "18:00";
    if($("onboardCheckinTimeAM")) $("onboardCheckinTimeAM").value = am;
    if($("onboardCheckinTimePM")) $("onboardCheckinTimePM").value = pm;
  }
}

function computeAdaptRate(b){
  // Replace “baseline adapt rate” input with an auto-calculated value.
  // Intuition: heavier daily load -> baselines update slightly faster.
  const dm = clamp(Number(b.dailyMin||120), 0, 600);
  const base = 0.12 + (dm/600)*0.10; // 0.12–0.22
  return clamp(base, 0.08, 0.26);
}

function initOnboarding(){
  ensureSubjectsSeeded();
  ensureProjectsSeeded();
  const needsSetup = !(state.ui && state.ui.onboarded) || (((state.subjects||[]).length + (state.projects||[]).length)===0);
  // Wire buttons
  const closeBtn = $("btnCloseOnboard");
  if(closeBtn) closeBtn.addEventListener("click", ()=>onboard.close());
  const addBtn = $("btnAddOnboardCustom");
  const addInp = $("onboardCustom");
  if(addBtn && addInp){
    const doAdd = ()=>{
      const v = (addInp.value||"").trim();
      if(!v) return;
      if(!state.subjects.includes(v)) state.subjects.push(v);
      addInp.value="";
      renderOnboardSubjects();
  renderOnboardProjects();
      renderSubjectChips();
      fillSessionSubjectSelect();
      saveState();
      updateAll();
      };
    addBtn.addEventListener("click", doAdd);
    addInp.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); doAdd(); } });
  }
  const nextBtn = $("btnOnboardNext");
  if(nextBtn) nextBtn.addEventListener("click", ()=>showOnboardStep(2));
  const backBtn = $("btnOnboardBack");
  if(backBtn) backBtn.addEventListener("click", ()=>showOnboardStep(1));

  const next2Btn = $("btnOnboardNext2");
  if(next2Btn) next2Btn.addEventListener("click", ()=>showOnboardStep(3));
  const back2Btn = $("btnOnboardBack2");
  if(back2Btn) back2Btn.addEventListener("click", ()=>showOnboardStep(2));

  const finishBtn = $("btnFinishOnboard");
  if(finishBtn) finishBtn.addEventListener("click", ()=>{
    const dailyMin = Number(($("baseDailyMin")?.value||"").trim());
    state.baselines.dailyMin = Number.isFinite(dailyMin) ? clamp(dailyMin,0,600) : 120;

    // New clearer setup
    state.settings.prefWindow = ($("baseStudyWindow")?.value||"evening").trim();

    // Where/area you usually study (multi-select saved during onboarding UI)
    const placeFallback = ($("baseStudyPlace")?.value||"desk").trim() || "desk";
    if(!Array.isArray(state.settings.prefPlaces) || !state.settings.prefPlaces.length){
      state.settings.prefPlaces = [placeFallback];
    }
    state.settings.prefPlace = String(state.settings.prefPlaces[0]||placeFallback);

    const areaFallback = ($("baseStudyArea")?.value||"").trim();
    if(!Array.isArray(state.settings.prefAreas)) state.settings.prefAreas = (areaFallback ? [areaFallback] : []);
    if(!state.settings.prefAreas.length && areaFallback) state.settings.prefAreas = [areaFallback];
    state.settings.prefArea = String(state.settings.prefAreas[0]||areaFallback||"");

    // Daily check-in schedule
    const ciAM = ($("onboardCheckinTimeAM")?.value || (state.settings && state.settings.checkinTimeAM) || "08:00").trim();
    const ciPM = ($("onboardCheckinTimePM")?.value || (state.settings && state.settings.checkinTimePM) || "18:00").trim();

    state.settings.checkinTimeAM = (ciAM && ciAM.length>=4) ? ciAM : "08:00";
    state.settings.checkinTimePM = (ciPM && ciPM.length>=4) ? ciPM : "18:00";

    // Backward-compat single time (used by older code paths)
    state.settings.checkinTime = state.settings.checkinTimePM;

    if($("settingCheckinTimeAM")) $("settingCheckinTimeAM").value = state.settings.checkinTimeAM;
    if($("settingCheckinTimePM")) $("settingCheckinTimePM").value = state.settings.checkinTimePM;
    if($("settingCheckinTime")) $("settingCheckinTime").value = state.settings.checkinTimePM;

    try{ updateSettingCheckinHint_2x(); }catch(e){ try{ updateSettingCheckinHint(); }catch(e2){} }


const dailyTarget = Number(($("baseTargetDailyMin")?.value||"").trim());
    const dailySafe = Number.isFinite(dailyTarget) ? clamp(dailyTarget,0,600) : (state.baselines.dailyMin||120);
    const weeklyMin = clamp(dailySafe*7, 0, 5000);
    if($("baseWeeklyMin")) $("baseWeeklyMin").value = String(weeklyMin);
    if($("baseWeeklyAutoText")) $("baseWeeklyAutoText").textContent = `Weekly target (auto): ${weeklyMin} min`;
    ensureGoalsShape(); state.goals.manual.weeklyMin = weeklyMin; state.goals.weeklyMin = weeklyMin;

    $("onboardSaveNote").textContent = "";
    if(!state.ui) state.ui = { lastOpenDate: todayKey(), lastCheckinPromptDate: "", onboarded: false };
    state.ui.onboarded = true;
    if(!("tourDone" in state.ui)) state.ui.tourDone = false;
    state.ui.pendingTour = !state.ui.tourDone;
    saveState();
    fillSessionSubjectSelect();
    renderSubjectChips();
    renderProjectChips();
    updateAll();
    try{ onboard.close(); }catch(e){ try{ document.getElementById("onboardBack")?.classList.remove("show"); }catch(_){} }
    setTimeout(()=>{ maybePromptCheckin(true); }, 220);
    setTimeout(()=>{ try{ maybeStartTourAfterOnboarding(); }catch(e){} }, 420);
  });

  renderOnboardSubjects();
  renderOnboardProjects();

  // Pre-fill baseline inputs
  if($("baseDailyMin")) $("baseDailyMin").value = state.baselines.dailyMin ?? 120;

  if($("baseStudyWindow")) $("baseStudyWindow").value = state.settings.prefWindow || "evening";
  if($("baseStudyPlace")) $("baseStudyPlace").value = state.settings.prefPlace || "desk";
  if($("baseStudyArea")) $("baseStudyArea").value = state.settings.prefArea || "";
  try{ renderOnboardStudyPills(); }catch(e){}

  const curWeekly = Number(state.goals?.weeklyMin ?? 0);
  const curDailyTarget = Math.round((Number.isFinite(curWeekly)?curWeekly:0)/7);
  if($("baseTargetDailyMin")) $("baseTargetDailyMin").value = (curDailyTarget>0 ? String(curDailyTarget) : String(state.baselines.dailyMin ?? 120));

  const wk = clamp(Number(($("baseTargetDailyMin")?.value||"").trim())*7, 0, 5000);
  if($("baseWeeklyMin")) $("baseWeeklyMin").value = String(wk);
  if($("baseWeeklyAutoText")) $("baseWeeklyAutoText").textContent = `Weekly target (auto): ${wk} min`;

  if($("baseTargetDailyMin")) $("baseTargetDailyMin").addEventListener("input", ()=>{
    const d = Number(($("baseTargetDailyMin")?.value||"").trim());
    const wk2 = clamp((Number.isFinite(d)?d:0)*7, 0, 5000);
    if($("baseWeeklyMin")) $("baseWeeklyMin").value = String(wk2);
    if($("baseWeeklyAutoText")) $("baseWeeklyAutoText").textContent = `Weekly target (auto): ${wk2} min`;
  });

      if($("baseAdaptDisplay")) $("baseAdaptDisplay").textContent = computeAdaptRate(state.baselines).toFixed(2);
  if($("baseWeeklyMin")) $("baseWeeklyMin").value = getEffectiveGoals().weeklyMin ?? 600;

  // Open automatically on first run
  if(needsSetup){
    onboard.open();
  }
}

/**********************
 * Tabs
 **********************/
function initTabs(){
  const btns = Array.from(document.querySelectorAll(".tabbtn"));
  const pages = Array.from(document.querySelectorAll(".page"));
  const wrap = document.querySelector(".wrap");

  let switching = false;

  btns.forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const tab = btn.getAttribute("data-tab");
      if(!tab || switching) return;

      const prevBtn = document.querySelector(".tabbtn.active");
      const prevTab = prevBtn ? prevBtn.getAttribute("data-tab") : null;
      if(prevTab === tab) return;

      const nextPage = document.getElementById("page-"+tab);
      const prevPage = prevTab ? document.getElementById("page-"+prevTab) : null;
      if(!nextPage) return;

      switching = true;

      // Ghost the previous page so we can animate it out without keeping it in layout
      let ghost = null;
      if(prevPage){
        ghost = prevPage.cloneNode(true);
        ghost.classList.remove("active");
        ghost.style.position = "absolute";
        ghost.style.pointerEvents = "none";
        ghost.style.zIndex = "5";
        const r = prevPage.getBoundingClientRect();
        const wr = wrap?.getBoundingClientRect();
        const top = (wr ? (r.top - wr.top) : prevPage.offsetTop);
        ghost.style.left = "0";
        ghost.style.right = "0";
        ghost.style.top = top + "px";
        if(wrap) wrap.appendChild(ghost);
      }

      // Swap real pages immediately (prevents content flashing at the bottom)
      pages.forEach(p=>p.classList.remove("active"));
      nextPage.classList.add("active");

      // Animate in the next page
      nextPage.animate(
        [{opacity:0, transform:"translateY(10px)"},{opacity:1, transform:"translateY(0)"}],
        {duration:220, easing:"cubic-bezier(.2,.8,.2,1)"}
      );

      // Animate out the ghost
      if(ghost){
        const a = ghost.animate(
          [{opacity:1, transform:"translateY(0)"},{opacity:0, transform:"translateY(-6px)"}],
          {duration:200, easing:"cubic-bezier(.2,.8,.2,1)"}
        );
        a.onfinish = ()=>{ try{ ghost.remove(); }catch(e){} };
      }

      // Update tab states
      btns.forEach(b=>{
        const active = (b === btn);
        b.classList.toggle("active", active);
        b.setAttribute("aria-selected", active ? "true" : "false");
      });

      window.setTimeout(()=>{
        switching = false;
        // Keep cards/metrics in sync when navigating between tabs
        updateAll();
        if(tab === "overview"){
          try{ nudgeOverviewBars(); }catch(e){}
        }
        if(tab === "analytics") drawAnalytics();
        if(tab === "start"){
          try{ maybeShowNextPlanOverlay(); }catch(e){}
        }
      }, 240);
});
  });
}


/**********************
 * Subjects
 **********************/

function getStudyItems(){
  const subs = Array.isArray(state.subjects) ? state.subjects : [];
  const projs = Array.isArray(state.projects) ? state.projects : [];
  const all = [...subs, ...projs].map(x=>String(x||"").trim()).filter(Boolean);
  return Array.from(new Set(all));
}

function getSubjectsOnly(){
  const subs = Array.isArray(state.subjects) ? state.subjects : [];
  const cleaned = subs.map(x=>String(x||"").trim()).filter(Boolean);
  return Array.from(new Set(cleaned));
}


function renderSubjectChips(){
  const wrap = $("subjectChips");
  if(!wrap) return;
  wrap.innerHTML = "";
  getStudyItems().forEach(sub=>{
    const chip = document.createElement("div");
    chip.className = "pillOpt active";
    chip.textContent = sub;
    chip.title = "Click to remove";
    chip.addEventListener("click", ()=>{
      state.subjects = state.subjects.filter(s=>s!==sub);
      // remove per-subject goals too
      if(state.goals?.perSubject) delete state.goals.perSubject[sub];
      saveState();
      renderSubjectChips();
      fillSessionSubjectSelect();
      renderGoalsPerSubject();
      updateAll();
    });
    wrap.appendChild(chip);
  });
}

function initSubjectsSettings(){
  const addBtn = $("btnAddSubject");
  const inp = $("newSubject");
  if(addBtn && inp){
    const doAdd = ()=>{
      const v = (inp.value||"").trim();
      if(!v) return;
      if(!state.subjects.includes(v)) state.subjects.push(v);
      inp.value="";
      saveState();
      renderSubjectChips();
      fillSessionSubjectSelect();
      renderGoalsPerSubject();
      updateAll();
    };
    addBtn.addEventListener("click", doAdd);
    inp.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); doAdd(); } });
  }
  renderSubjectChips();
}

function renderProjectChips(){
  const wrap = $("projectChips");
  if(!wrap) return;
  wrap.innerHTML = "";
  (Array.isArray(state.projects) ? state.projects : []).forEach(p=>{
    const chip = document.createElement("div");
    chip.className = "pillOpt active";
    chip.textContent = p;
    chip.title = "Click to remove";
    chip.addEventListener("click", ()=>{
      state.projects = (Array.isArray(state.projects)? state.projects: []).filter(x=>x!==p);
      if(state.goals?.perSubject) delete state.goals.perSubject[p];
      saveState();
      renderProjectChips();
      fillSessionSubjectSelect();
      renderGoalsPerSubject();
      updateAll();
    });
    wrap.appendChild(chip);
  });
}

function initProjectsSettings(){
  const addBtn = $("btnAddProject");
  const inp = $("newProject");
  if(addBtn && inp){
    const doAdd = ()=>{
      const v = (inp.value||"").trim();
      if(!v) return;
      state.projects = Array.isArray(state.projects) ? state.projects : [];
      if(!state.projects.includes(v)) state.projects.push(v);
      inp.value="";
      saveState();
      renderProjectChips();
      fillSessionSubjectSelect();
      renderGoalsPerSubject();
      updateAll();
    };
    addBtn.addEventListener("click", doAdd);
    inp.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); doAdd(); } });
  }
  renderProjectChips();
}



function fillSessionSubjectSelect(){
  const sel = $("sessSubject");
  if(!sel) return;
  sel.innerHTML = "";
  const opt0 = document.createElement("option");
  opt0.value = "";
  opt0.textContent = "Select subject / project";
  sel.appendChild(opt0);
  getStudyItems().forEach(s=>{
    const o = document.createElement("option");
    o.value = s;
    o.textContent = s;
    sel.appendChild(o);
  });

  // preserve current selection if exists
  if(state.active?.subject) sel.value = state.active.subject;

}

function initSessionMethodPicker(){
  const sel = $("sessMethod");            // hidden <select> used as a canonical "primary method"
  const row = $("sessMethodRow");         // pill UI
  const inp = $("sessMethodCustom");
  const btn = $("btnAddSessMethod");
  if(!sel || !row) return;

  const uniq = (arr)=> Array.from(new Set(arr.filter(x=>String(x||"").trim())));

  const getPool = ()=>{
    const fromState = Array.isArray(state.settings.methods) ? state.settings.methods : [];
    const fromDom = Array.from(sel.querySelectorAll("option")).map(o=>String(o.value||"").trim());
    return uniq([...fromState, ...fromDom]);
  };

  const setSelected = (arr)=>{
    const cleaned = uniq((arr||[]).map(x=>String(x||"").trim()).filter(Boolean));
    if(!state.ui) state.ui = {};
    state.ui.sessMethods = cleaned;
    // Keep select in sync (primary method = first selected)
    if(cleaned.length){
      sel.value = cleaned[0];
    }
  };

  const getSelected = ()=>{
    const fromUI = (state.ui && Array.isArray(state.ui.sessMethods)) ? state.ui.sessMethods : [];
    if(fromUI.length) return uniq(fromUI);
    // fallback: whatever is in the select
    const v = String(sel.value||"").trim();
    return v ? [v] : [];
  };

  const rebuildSelectOptions = (methods)=>{
    const cur = String(sel.value||"");
    sel.innerHTML = "";
    methods.forEach((m,i)=>{
      const o = document.createElement("option");
      o.value = m;
      o.textContent = m;
      if(i===0 && !cur) o.selected = true;
      sel.appendChild(o);
    });
    if(cur && methods.includes(cur)) sel.value = cur;
  };

  const render = ()=>{
    const pool = getPool();
    if(!pool.length) pool.push("Practice");
    state.settings.methods = uniq(pool);
    rebuildSelectOptions(state.settings.methods);

    // Ensure at least one selected
    const selected = getSelected();
    if(!selected.length){
      const first = String(sel.value||state.settings.methods[0]||"Practice");
      setSelected([first]);
    }else{
      // Keep select aligned to first selected if present in pool
      setSelected(selected.filter(m=>state.settings.methods.includes(m)));
      if(!getSelected().length){
        const first = String(sel.value||state.settings.methods[0]||"Practice");
        setSelected([first]);
      }
    }

    row.innerHTML = "";
    const selectedNow = getSelected();

    state.settings.methods.forEach(m=>{
      const b = document.createElement("div");
      b.className = "pillOpt";
      b.textContent = m;
      b.setAttribute("role","button");
      b.setAttribute("tabindex","0");
      b.classList.toggle("active", selectedNow.includes(m));

      const toggle = ()=>{
        const cur = getSelected();
        const on = cur.includes(m);
        if(on && cur.length===1){
          // keep at least one selected
          b.classList.add("shake");
          setTimeout(()=>b.classList.remove("shake"), 180);
          return;
        }
        const next = on ? cur.filter(x=>x!==m) : [...cur, m];
        setSelected(next);
        syncSessionMethodPicker();
        try{ markCommitTouched(); }catch(e){}
        try{ updateCommitBonus(); }catch(e){}
        saveState();
      };

      b.addEventListener("click", toggle);
      b.addEventListener("keydown", (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); toggle(); } });
      row.appendChild(b);
    });
  };

  window.getSelectedSessionMethods = ()=> getSelected();

  window.syncSessionMethodPicker = ()=>{
    const cur = getSelected();
    Array.from(row.children).forEach(el=>{
      el.classList.toggle("active", cur.includes(el.textContent));
    });
  };

  const addCustom = ()=>{
    const v = String(inp?.value||"").trim();
    if(!v) return;
    if(!Array.isArray(state.settings.methods)) state.settings.methods = [];
    const exists = state.settings.methods.some(x=>String(x).toLowerCase()===v.toLowerCase());
    if(!exists) state.settings.methods.push(v);
    if(inp) inp.value = "";
    // auto-select the new method (additive)
    const cur = getSelected();
    setSelected([...cur, v]);
    render();
    syncSessionMethodPicker();
    try{ markCommitTouched(); }catch(e){}
    try{ updateCommitBonus(); }catch(e){}
    saveState();
  };

  btn?.addEventListener("click", addCustom);
  inp?.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); addCustom(); } });

  // If something sets the select programmatically, keep UI in sync.
  sel.addEventListener("change", ()=>{
    const v = String(sel.value||"").trim();
    if(!v) return;
    // If selected list is empty, set it; else replace primary (first) with the select value (do not erase other selections)
    const cur = getSelected();
    if(!cur.length) setSelected([v]);
    else setSelected([v, ...cur.filter(x=>x!==v)]);
    try{ syncSessionMethodPicker(); }catch(e){}
  });

  render();
  syncSessionMethodPicker();
}

/**********************
 * Daily Check-in
 **********************/
const checkinModal = {
  back: ()=>$("modalCheckinBack"),
  open(opts){
    opts = opts || {};
    // Track where the check-in was opened from (e.g., Settings preview) to avoid triggering coach unexpectedly.
    if(!state.ui) state.ui = {};
    state.ui.checkinOpenSource = opts.source || "unknown";

    const b=this.back();
    if(!b) return;
    b.classList.add("show");
    b.setAttribute("aria-hidden","false");
  },
  close(){
    const b=this.back();
    if(!b) return;
    b.classList.remove("show");
    b.setAttribute("aria-hidden","true");
    try{ if(state && state.ui) state.ui.checkinOpenSource = ""; }catch(e){}
  }


};

const coachModal = {
  back: ()=>$("modalCoachBack"),
  open(){
    const b=this.back();
    if(!b) return;
    b.classList.add("show");
    b.setAttribute("aria-hidden","false");
  },
  close(){
    const b=this.back();
    if(!b) return;
    b.classList.remove("show");
    b.setAttribute("aria-hidden","true");
  }
};

// Coach modal wiring
(function initCoachModal(){
  const cClose = $("btnCloseCoach");
  const cDone = $("btnCoachDone");
  const close = ()=>{ coachModal.close(); setTimeout(()=>{ try{ maybeStartTourAfterOnboarding(); }catch(e){} }, 120); };
  if(cClose) cClose.addEventListener("click", close);
  if(cDone) cDone.addEventListener("click", close);
})();

/**********************
 * End session modal (fix: ensure buttons only appear inside the modal)
 **********************/
const endModal = {
  back: ()=>$("endModalBack"),
  open(opts){
    const b=this.back();
    if(!b) return;
    opts = opts || {};

    // When opening from the Quick preset overlay, preserve the preset values already applied.
    const preserve = !!opts.preservePreset;

    if(!preserve){
      // reset any previous inputs
      if($("endNotes")) $("endNotes").value = "";
      if($("endEnv")) $("endEnv").value = "";
      // clear distraction selections
      $("endDistractRow")?.querySelectorAll(".pillOpt.active").forEach(p=>p.classList.remove("active"));
      // clear environment/context selections
      $("endEnvPresets")?.querySelectorAll(".pillOpt.active").forEach(p=>p.classList.remove("active"));
      $("endEnvPresets")?.querySelectorAll('.pillOpt[data-env-custom="1"]').forEach(p=>p.remove());
      // default slider values
      if($("endFocus")) $("endFocus").value = 3;
      if($("endRetrieval")) $("endRetrieval").value = 3;
      if($("endPerf")) $("endPerf").value = 3;
      if($("endEffort")) $("endEffort").value = 3;
      if($("endFrustration")) $("endFrustration").value = 2;
    }

    // sync text displays (always)
    if($("endFocusVal") && $("endFocus")) $("endFocusVal").textContent = $("endFocus").value;
    if($("endRetrievalVal") && $("endRetrieval")) $("endRetrievalVal").textContent = $("endRetrieval").value;
    if($("endPerfVal") && $("endPerf")) $("endPerfVal").textContent = $("endPerf").value;
    if($("endEffortVal") && $("endEffort")) $("endEffortVal").textContent = $("endEffort").value;
    if($("endFrustrationVal") && $("endFrustration")) $("endFrustrationVal").textContent = $("endFrustration").value;

    b.classList.add("show");
    b.setAttribute("aria-hidden","false");
  },
  close(){
    const b=this.back();
    if(!b) return;
    b.classList.remove("show");
    b.setAttribute("aria-hidden","true");
  }
};

function initEndModal(){
  const b = endModal.back();
  if(b){
    // hard reset to hidden on load
    b.classList.remove("show");
    b.setAttribute("aria-hidden","true");

    // click outside to close
    b.addEventListener("click", (e)=>{ if(e.target===b) endModal.close(); });
  }

  // wire close icon
  $("endModalClose")?.addEventListener("click", ()=>endModal.close());

  // keep value labels in sync

  setRangePair("endFocus","endFocusVal","span");
  setRangePair("endRetrieval","endRetrievalVal","span");
  setRangePair("endPerf","endPerfVal","span");
  setRangePair("endEffort","endEffortVal","span");
  setRangePair("endFrustration","endFrustrationVal","span");

  // footer actions
  $("discardEndBtn")?.addEventListener("click", discardActiveSession);
  $("saveEndBtn")?.addEventListener("click", saveSessionFromModal);
}

function discardActiveSession(){
  // discard active timer/session without logging
  state.active = null;
  saveState();

  endModal.close();
  setTimerDisplay(getIdleSeconds());
  const hintEl = $("timerHint");
  if(hintEl) hintEl.textContent = "Discarded. Ready when you are.";
  updateStartPage();
  updateAll();
  drawAnalytics();

  // Prompt daily check-in on load (unless onboarding will handle it)
  if(state?.ui?.onboarded) maybePromptCheckin(false);
  showToast("Discarded", "Session not saved.");
}

function setRangePair(id, valId, mode="slash"){
  const r = $(id), v=$(valId);
  if(!r || !v) return;
  const sync = ()=>{
    if(mode==="span") v.textContent = String(r.value);
    else v.textContent = `${r.value}/5`;
  };
  r.addEventListener("input", sync);
  sync();
}

function initDailyCheckin(){
  setRangePair("ciSleepQ","ciSleepQVal");
  setRangePair("ciStress","ciStressVal");
  setRangePair("ciMotivation","ciMotivationVal");
  setRangePair("ciClarity","ciClarityVal");

  const close = $("btnCloseCheckin");
  if(close) close.addEventListener("click", ()=>{ checkinModal.close(); setTimeout(()=>{ try{ maybeStartTourAfterOnboarding(); }catch(e){} }, 120); });

  const saveBtn = $("btnSaveCheckin");
  if(saveBtn) saveBtn.addEventListener("click", ()=>{
    const date = todayKey();
    state.dailyCheckins[date] = {
      sleepQ: Number($("ciSleepQ")?.value||3),
      stress: Number($("ciStress")?.value||3),
      motivation: Number($("ciMotivation")?.value||3),
      clarity: Number($("ciClarity")?.value||3),
      savedAt: now()
    };
    // Track last completed check-in time (24h cadence)
    if(!state.ui) state.ui = { lastOpenDate: todayKey(), lastCheckinPromptDate: "", onboarded: (Array.isArray(state.subjects) && state.subjects.length>0), lastCheckinAt: 0, lastCheckinPromptAt: 0 };
    if(!("lastCheckinAt" in state.ui)) state.ui.lastCheckinAt = 0;
    if(!("lastCheckinPromptAt" in state.ui)) state.ui.lastCheckinPromptAt = 0;
    const _ciNow = now();
    state.ui.lastCheckinAt = _ciNow;
    state.ui.lastCheckinPromptAt = _ciNow;
    state.ui.lastCheckinPromptDate = date;

    // baseline nudges
    updateBaselinesFromCheckin(date);
    saveState();
        try{ if(typeof updateAfterLoadChange==="function") updateAfterLoadChange(); else if(typeof updateAll==="function") updateAll(); }catch(e){}
checkinModal.close();
    updateAll();
    setTimeout(()=>{
      try{
        const src = (state.ui && state.ui.checkinOpenSource) ? state.ui.checkinOpenSource : "";
        if(src !== "settings") maybeShowCoachAfterCheckin();
      }catch(e){}
    }, 80);
  });

  // show when missing (every 24h) after onboarding
  maybePromptCheckin(false);
}

function updateBaselinesFromCheckin(date){
  const ci = state.dailyCheckins[date];
  if(!ci) return;
  const a = state.baselines.adapt;
  // Map check-in to baseline energy/focus slowly
  const energyProxy = clamp(Math.round((ci.sleepQ*0.40 + (6-ci.stress)*0.30 + ci.motivation*0.30)), 1, 5);
  const focusProxy = clamp(Math.round((ci.clarity*0.40 + ci.motivation*0.30 + (6-ci.stress)*0.30)), 1, 5);
  state.baselines.energy = (1-a)*state.baselines.energy + a*energyProxy;
  state.baselines.focus  = (1-a)*state.baselines.focus  + a*focusProxy;
}


function parseHHMM(t){
  const s = String(t||"").trim();
  const m = s.match(/^(\d{1,2}):(\d{2})$/);
  if(!m) return {h:20, mi:0};
  const h = clamp(Number(m[1]), 0, 23);
  const mi = clamp(Number(m[2]), 0, 59);
  return {h, mi};
}

function checkinTargetMsForDate(dateStr){
  // dateStr is YYYY-MM-DD in local time
  const base = new Date(dateStr + "T00:00:00");
  const {h, mi} = parseHHMM(state.settings?.checkinTime || "20:00");
  base.setHours(h, mi, 0, 0);
  return base.getTime();
}

function updateSettingCheckinHint(){
  const el = $("settingCheckinNextHint");
  if(!el) return;
  const pref = (state.settings?.checkinTime || "20:00");
  const tNow = now();
  const today = todayKey();
  const targetToday = checkinTargetMsForDate(today);
  const nextTxt = (tNow < targetToday) ? `Next prompt: today at ${pref}` : `Next prompt: tomorrow at ${pref}`;
  el.textContent = nextTxt;
}

function maybePromptCheckin(forceOpen=false){
  const date = todayKey();
  const tNow = now();

  // Ensure ui shape (backwards compatible)
  if(!state.ui) state.ui = { lastOpenDate: date, lastCheckinPromptDate: "", onboarded: false, lastCheckinAt: 0, lastCheckinPromptAt: 0 };
  if(!("lastCheckinPromptDate" in state.ui)) state.ui.lastCheckinPromptDate = "";
  if(!("onboarded" in state.ui)) state.ui.onboarded = ((Array.isArray(state.subjects)&&state.subjects.length>0) || (Array.isArray(state.projects)&&state.projects.length>0));
  if(!("lastCheckinAt" in state.ui)) state.ui.lastCheckinAt = 0;
  if(!("lastCheckinPromptAt" in state.ui)) state.ui.lastCheckinPromptAt = 0;

  // Do not prompt daily check-in before onboarding is completed
  const onboardBack = $("modalOnboardBack");
  if(!state.ui.onboarded || onboardBack?.classList.contains("show")){
    saveState();
    return;
  }

  // Already completed today
  const hasToday = !!(state.dailyCheckins && state.dailyCheckins[date]);
  if(hasToday && !forceOpen){
    updateSettingCheckinHint();
    return;
  }

  const targetMs = checkinTargetMsForDate(date);
  const eligible = forceOpen || (tNow >= targetMs);
  if(!eligible){
    updateSettingCheckinHint();
    return;
  }

  // Only prompt once per day unless forced
  if(!forceOpen && state.ui.lastCheckinPromptDate === date){
    updateSettingCheckinHint();
    return;
  }

  const allowCheckinPopup = !(state.settings && state.settings.popups && state.settings.popups.checkin === false);
  if(!allowCheckinPopup){
    updateSettingCheckinHint();
    return;
  }

  checkinModal.open({ source:"prompt" });
  state.ui.lastCheckinPromptDate = date;
  state.ui.lastCheckinPromptAt = tNow;
  saveState();
  updateSettingCheckinHint();
}


/**********************
 * Readiness + strain computations
 **********************/
function readinessBaseFor(date){
  const ci = state.dailyCheckins[date];
  if(!ci) return null;
  const sleep = clamp(ci.sleepQ,1,5);
  const stress = clamp(ci.stress,1,5);
  const mot = clamp(ci.motivation,1,5);
  const clar = clamp(ci.clarity,1,5);

  // stress is inverted: higher stress reduces readiness
  const stressInv = 6 - stress;
  const weighted = (sleep*0.30 + stressInv*0.25 + mot*0.22 + clar*0.23); // 1–5 (subtle weighting)
  return clamp(Math.round(weighted*20), 0, 100);
}

function sessionsInRange(startMs, endMs){
  const arr = Array.isArray(state.sessions) ? state.sessions : [];
  return arr.filter(s=>{
    if(!s) return false;
    const t = Number((s.startTs ?? s.ts ?? s.endTs) ?? 0);
    if(!Number.isFinite(t)) return false;
    return t>=startMs && t<endMs;
  });
}
function strainForSession(s){
  const minutes = Number(s.minutes||0);
  const effort = Number(s.effort||3); // 1–5
  const frustration = Number(s.frustration||3); // 1–5
  const intensity = (effort*0.65 + frustration*0.35)/5; // 0.2–1

  // Distraction penalty: strict mode makes sessions more sensitive to interruptions.
  const dCount = (s.distractions||[]).length;
  const strict = !!state.settings.strict;
  const dMult = 1 + dCount * (strict ? 0.12 : 0.06);

  return minutes * intensity * dMult; // strain-minutes
}

function strainToday(){
  const d = new Date();
  const start = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
  const end = start + 24*3600*1000;
  return sessionsInRange(start,end).reduce((a,s)=>a+strainForSession(s), 0);
}

function strainPointsFromStrainMin(strainMin){
  const sm = Math.max(0, Number(strainMin||0));
  // saturating curve: maps minutes*intensity to a 0–21 score
  const points = 21 * (1 - Math.exp(-sm / 350));
  return clamp(points, 0, 21);
}

function updateOverviewPrimaryMetrics(){
  // Today window
  const d = new Date();
  const start = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
  const end = start + 24*3600*1000;

  const todaySessions = sessionsInRange(start, end);
  const strainMin = todaySessions.reduce((a,s)=>a+strainForSession(s), 0);
  const strainPts = strainPointsFromStrainMin(strainMin);

  const strainValEl = $("strainVal");
  const strainSubEl = $("strainSub");
  const strainNoteEl = $("strainNote"); // (kept for backwards compatibility)
  const strainTargetEl = $("strainTargetChip") || $("strainTarget");

  if(strainSubEl) strainSubEl.textContent = `Sessions today: ${todaySessions.length}`;

  // Display strain as a personalized percentage (0–100% against your target range)
  const gMin = (state.goals?.strainMin ?? 200);
  const gMax = (state.goals?.strainMax ?? 420);
  const tMin = strainPointsFromStrainMin(gMin);
  const tMax = Math.max(0.0001, strainPointsFromStrainMin(gMax));
  const curPct = clamp((strainPts / tMax) * 100, 0, 999);

  if(strainValEl) strainValEl.textContent = `${Math.round(todaySessions.length ? curPct : 0)}%`;
  try{ applyMetricHue(strainValEl, clamp(100 - Math.min(curPct,100), 0, 100)); }catch(e){}

  if(strainTargetEl){
    const lowPct = clamp((tMin / tMax) * 100, 0, 100);
    const lowTxt = Math.round(lowPct);
    strainTargetEl.textContent = (lowTxt >= 100) ? "Target: 100%" : `Target: ${lowTxt}–100%`;
  }


  // Celebrate when you hit the upper end of the strain target range (once per day)
  const strainCard = document.querySelector("#cardStrain");
  if(todaySessions.length && curPct>=100 && strainCard){
    if(celebrateOnce("strain")){
      celebrateGoal(strainCard, "You hit your strain target for today.");
    }
  }

  // Hide legacy note text if present in older versions
  if(strainNoteEl) strainNoteEl.textContent = "";
// 7-day window (including today)
  const dayMs = 24*3600*1000;
  const start7 = start - 6*dayMs;
  const days = [];
  for(let k=0;k<7;k++){
    const dt = new Date(start7 + k*dayMs);
    const key = dt.toISOString().slice(0,10);
    days.push({ key, start: start7 + k*dayMs, end: start7 + (k+1)*dayMs });
  }

  const strainPtsByDay = days.map(x=>{
    const s = sessionsInRange(x.start, x.end).reduce((a,ss)=>a+strainForSession(ss), 0);
    return strainPointsFromStrainMin(s);
  });

  const readinessByDay = days.map(x=>{
    const base = readinessBaseFor(x.key);
    if(base !== null && base !== undefined) return Number(base);
    // fallback: baselines -> 0–100
    return clamp(Math.round(((state.baselines.energy + state.baselines.focus)/2) * 20), 0, 100);
  });

  const avgStrainPts = strainPtsByDay.reduce((a,n)=>a+n,0) / Math.max(1, strainPtsByDay.length);
  const avgReadiness = readinessByDay.reduce((a,n)=>a+n,0) / Math.max(1, readinessByDay.length);

  // Balance ratio: (avg daily strain points) vs (readiness scaled to 0–10)
  const denom = Math.max(1, avgReadiness/10);
  const ratio = avgStrainPts / denom;

  const balanceVal = $("balanceVal");
  const balanceBar = $("balanceBar");
  const pacingText = $("pacingText");
  const pacingBadge = $("pacingBadge");

  let balanceScore = null;
if(balanceVal) balanceVal.textContent = isFinite(ratio) ? ratio.toFixed(2) : "--";
  try{
    if(isFinite(ratio)){
      const dev = Math.min(1.5, Math.abs(ratio - 1)); // 0 best
      const score = clamp(Math.round(100 - (dev/1.5)*100), 0, 100);
      balanceScore = score;
      applyMetricHue(balanceVal, score);
    }else{
      clearMetricHue(balanceVal);
    }
  }catch(e){}
  if(balanceBar){
    const pct = clamp((ratio/2.2), 0, 1);
    animateBar(balanceBar, pct);
    // Match the balance value tint (subtle, non-gradient)
    const score = (balanceScore===null || balanceScore===undefined) ? 50 : balanceScore;
    applyBarHue(balanceBar, score, .38);
  }
  const pacing =
    ratio < 0.80 ? {t:"Underreaching", d:"You can likely add volume."} :
    ratio < 1.20 ? {t:"Balanced", d:"Good pacing vs recovery."} :
    ratio < 1.60 ? {t:"Pushing", d:"Be intentional with breaks."} :
                   {t:"Overreaching", d:"Risk of fatigue is rising."};

  if(pacingText) pacingText.textContent = pacing.d;
  if(pacingBadge) pacingBadge.textContent = pacing.t;


  // Quality-weighted minutes (Today)
  const focusVal = $("focusVal");
  const focusNote = $("focusNote");

  const totalMinToday = todaySessions.reduce((a,s)=>a + Number(s.minutes||0), 0);
  const qwMin = todaySessions.reduce((a,s)=>{
    const mins = Number(s.minutes||0);
    const q = clamp(Number(s.quality || s.baseQuality || 0), 1, 5);
    return a + mins * (q/5);
  }, 0);

  if(focusVal) focusVal.textContent = `${Math.round(totalMinToday ? qwMin : 0)} / ${Math.round(totalMinToday)}m`;
  try{ applyMetricHue(focusVal, totalMinToday ? clamp((qwMin/Math.max(1,totalMinToday))*100,0,100) : 0); }catch(e){}
  if(focusNote) focusNote.textContent = totalMinToday ? "Quality-weighted / total minutes today" : "Log a session to start tracking";

  // Consistency index (7D) — steadiness of daily minutes
  const consVal = $("consistencyVal");
  const consNote = $("consistencyNote");

  const minsByDay = days.map(x=>{
    const mins = sessionsInRange(x.start, x.end).reduce((a,s)=>a + Number(s.minutes||0), 0);
    return clamp(mins, 0, 1440);
  });

  const mean = minsByDay.reduce((a,n)=>a+n,0) / Math.max(1, minsByDay.length);
  const hasData = minsByDay.some(n=>n>0);

  if(!consVal || !consNote){
    // nothing
  }else if(!hasData || mean <= 0){
    consVal.textContent = "--";
    consNote.textContent = "Log a few days to estimate steadiness";
  }else{
    const variance = minsByDay.reduce((a,n)=>a + Math.pow(n-mean,2), 0) / Math.max(1, minsByDay.length);
    const std = Math.sqrt(variance);
    const cv = std / Math.max(1e-6, mean);

    const score = clamp(Math.round((1 - cv) * 100), 0, 100);

    let band = "Highly variable";
    if(score >= 80) band = "Very steady";
    else if(score >= 60) band = "Steady";
    else if(score >= 40) band = "Variable";

    consVal.textContent = `${score}/100`;
    try{ applyMetricHue(consVal, score); }catch(e){}
    consNote.textContent = `${band} (7D)`;
  }

  // Last session quality
  const last = (state.sessions||[]).slice().sort((a,b)=>Number(b.endTs||0)-Number(a.endTs||0))[0];
  const lastLabel = $("lastQualityLabel");
  const lastVal = $("lastQualityVal");
  if(last){
    if(lastLabel){
      const sub = (last.subject||"").trim();
      const mins = Number(last.minutes||0);
      lastLabel.textContent = `${sub || "Session"} · ${mins} min`;
    }
    if(lastVal){
      const q = Number(last.quality||0);
      lastVal.textContent = q ? `${q}/5` : "--";
      try{ applyMetricHue(lastVal, clamp((q/5)*100, 0, 100)); }catch(e){}
    }
  }else{
    if(lastLabel) lastLabel.textContent = "--";
    if(lastVal) lastVal.textContent = "--";
  }

  // Burnout risk (7D)
  const rFirst3 = readinessByDay.slice(0,3).reduce((a,n)=>a+n,0)/3;
  const rLast3 = readinessByDay.slice(-3).reduce((a,n)=>a+n,0)/3;
  const drop = rFirst3 - rLast3;

  const ratioRisk = clamp((ratio - 1.0)/0.8, 0, 1) * 60;
  const readinessRisk = clamp((65 - avgReadiness)/25, 0, 1) * 30;
  const trendBonus = drop > 15 ? 15 : (drop > 8 ? 10 : 0);

  const risk = clamp(Math.round(ratioRisk + readinessRisk + trendBonus), 0, 100);

  const burnoutLabel = $("burnoutLabel");
  const burnoutVal = $("burnoutVal");
  const burnoutNote = $("burnoutNote");

  const band =
    risk < 33 ? {t:"Low", d:"Your pacing looks sustainable."} :
    risk < 66 ? {t:"Moderate", d:"Consider shorter sessions and more frequent breaks."} :
                {t:"High", d:"Back off volume and prioritize recovery for a few days."};

  if(burnoutLabel) burnoutLabel.innerHTML = `<b>${band.t}</b>`;
  if(burnoutVal) burnoutVal.textContent = `${risk}/100`;
  try{ applyMetricHue(burnoutVal, clamp(100 - risk, 0, 100)); }catch(e){}
  if(burnoutNote) burnoutNote.textContent = band.d;
}



function readinessToday(){
  const date = todayKey();
  const base = readinessBaseFor(date);

  // Base is primarily check-in driven (dominant signal)
  let baseScore = null;
  let source = "checkin";

  if(base === null){
    // If no check-in, estimate from baselines
    let est = clamp(Math.round(((state.baselines.energy + state.baselines.focus)/2) * 20), 0, 100);
    if(!Number.isFinite(est)) est = 50;
    baseScore = est;
    source = "baseline";
  }else{
    baseScore = Number(base);
  }

  // Multi-day recovery model:
  // Today's strain has the most impact, yesterday has moderate impact, and the last 3-day avg has a smaller smoothing effect.
  const nowD = new Date();
  const start = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate()).getTime();
  const dayMs = 24*3600*1000;

  const strainMinToday = sessionsInRange(start, start+dayMs).reduce((a,s)=>a+strainForSession(s), 0);
  const strainMinYesterday = sessionsInRange(start-dayMs, start).reduce((a,s)=>a+strainForSession(s), 0);
  const strainMinLast3Avg = sessionsInRange(start-3*dayMs, start).reduce((a,s)=>a+strainForSession(s), 0) / 3;

  const p0 = clamp(Math.round(strainMinToday / 18), 0, 35);
  const p1 = clamp(Math.round(strainMinYesterday / 24), 0, 28);
  const p3 = clamp(Math.round(strainMinLast3Avg / 30), 0, 22);

  const penalty = Math.round(p0*0.65 + p1*0.25 + p3*0.10);

  return {score: clamp(baseScore - penalty, 0, 100), source};
}

function readinessBand(score){
  if(score>=75) return {title:"High readiness", desc:"You’re likely to learn efficiently today. Consider deeper work or harder topics."};
  if(score>=55) return {title:"Medium readiness", desc:"Solid capacity. Prefer structured sessions and moderate difficulty."};
  if(score>=35) return {title:"Low readiness", desc:"Keep sessions shorter and focus on easier wins (review, practice, retrieval)."};
  return {title:"Very low readiness", desc:"Prioritize recovery. If you study, keep it light and highly structured."};
}

function readinessHue(score){
  // 0 (red) -> 120 (green)
  return clamp((score/100)*120, 0, 120);
}


/**********************
 * Subtle metric hue (overview numbers)
 * 0 => red, 50 => yellow, 100 => green
 **********************/
function metricHue(score01){
  const s = clamp(Number(score01||0), 0, 100);
  return clamp((s/100)*120, 0, 120);
}
function applyMetricHue(elOrId, score01){
  const el = (typeof elOrId === "string") ? $(elOrId) : elOrId;
  if(!el) return;
  const h = metricHue(score01);
  // Subtle: slightly tinted text + faint glow
  el.style.color = `hsla(${h}, 80%, 72%, .95)`;
  el.style.textShadow = `0 0 18px hsla(${h}, 90%, 60%, .12)`;
}

function applyBarHue(elOrId, score01, alpha=.42){
  const el = (typeof elOrId === "string") ? $(elOrId) : elOrId;
  if(!el) return;
  const h = metricHue(score01);
  el.style.background = `hsla(${h}, 85%, 58%, ${alpha})`;
  el.style.boxShadow = `0 14px 34px hsla(${h}, 90%, 55%, .10)`;
}

function clearMetricHue(elOrId){
  const el = (typeof elOrId === "string") ? $(elOrId) : elOrId;
  if(!el) return;
  el.style.color = "";
  el.style.textShadow = "";
}

/**********************
 * Timer + session logging
 **********************/

/**********************
 * Timer + session logging
 **********************/
let timerInt = null;

function formatTime(sec){
  sec = Math.max(0, Math.floor(sec||0));
  const m = Math.floor(sec/60);
  const s = Math.floor(sec%60);
  return String(m).padStart(2,"0")+":"+String(s).padStart(2,"0");
}

function getIdleSeconds(){
  const mode = $("sessMode")?.value || "countdown";
  const plannedMin = clamp(Number($("sessMinutes")?.value || 25), 1, 600);
  return (mode==="countdown") ? plannedMin*60 : 0;
}

function getActiveRemainingSeconds(ts=now()){
  const a = state.active;
  if(!a) return 0;
  const total = clamp(Number(a.plannedMin || 25), 1, 600) * 60;
  const baseRem = (typeof a.remainingSec === "number") ? a.remainingSec : total;
  if(a.running && a.startTs){
    const d = Math.floor((ts - a.startTs)/1000);
    return clamp(baseRem - d, 0, total);
  }
  return clamp(baseRem, 0, total);
}

function getActiveElapsedSeconds(ts=now()){
  const a = state.active;
  if(!a) return 0;
  if((a.mode||"countdown")==="countdown"){
    const total = clamp(Number(a.plannedMin || 25), 1, 600) * 60;
    return clamp(total - getActiveRemainingSeconds(ts), 0, total);
  }
  const base = Number(a.elapsedSec || 0);
  if(a.running && a.startTs){
    const d = Math.floor((ts - a.startTs)/1000);
    return Math.max(0, base + d);
  }
  return Math.max(0, base);
}

function getDisplaySeconds(){
  if(!state.active) return getIdleSeconds();
  const mode = state.active.mode || "countdown";
  return (mode==="countdown") ? getActiveRemainingSeconds() : getActiveElapsedSeconds();
}

function setTimerDisplay(sec){
  const disp = $("timerDisplay");
  const t = formatTime(sec);
  if(disp) disp.textContent = t;
  if($("fullTime")) $("fullTime").textContent = t;
}


function updateTimerViewVisuals(sec){
  const mode = state.active?.mode || ($("sessMode")?.value || "countdown");
  const plannedMin = clamp(Number($("sessMinutes")?.value || 25), 1, 600);
  const totalSec = plannedMin * 60;

  let progress = 0;
  if(mode === "countdown"){
    progress = totalSec>0 ? clamp((totalSec - sec)/totalSec, 0, 1) : 0;
    if($("timerBarLeft")) $("timerBarLeft").textContent = `Remaining: ${formatTime(sec)}`;
    if($("timerBarRight")) $("timerBarRight").textContent = `Total: ${formatTime(totalSec)}`;
    if($("fullTimerBarLeft")) $("fullTimerBarLeft").textContent = `Remaining: ${formatTime(sec)}`;
    if($("fullTimerBarRight")) $("fullTimerBarRight").textContent = `Total: ${formatTime(totalSec)}`;
  }else{
    progress = totalSec>0 ? clamp(sec/totalSec, 0, 1) : 0;
    if($("timerBarLeft")) $("timerBarLeft").textContent = `Elapsed: ${formatTime(sec)}`;
    if($("timerBarRight")) $("timerBarRight").textContent = `Goal: ${formatTime(totalSec)}`;
    if($("fullTimerBarLeft")) $("fullTimerBarLeft").textContent = `Elapsed: ${formatTime(sec)}`;
    if($("fullTimerBarRight")) $("fullTimerBarRight").textContent = `Goal: ${formatTime(totalSec)}`;
  }

  const barFill = $("timerBarFill");
  if(barFill) barFill.style.width = `${Math.round(progress*100)}%`;
  const fullBarFill = $("fullTimerBarFill");
  if(fullBarFill) fullBarFill.style.width = `${Math.round(progress*100)}%`;

  const arc = $("timerRingArc");
  const fullArc = $("fullTimerRingArc");
  const C = 540.354; // 2*pi*r, r=86
  if(arc){
    arc.style.strokeDasharray = String(C);
    arc.style.strokeDashoffset = String(C*(1-progress));
    // Hide the "single dot" that appears at 0% when stroke-linecap is round
    arc.style.opacity = (progress > 0.001) ? "1" : "0";
  }
  if(fullArc){
    fullArc.style.strokeDasharray = String(C);
    fullArc.style.strokeDashoffset = String(C*(1-progress));
    fullArc.style.opacity = (progress > 0.001) ? "1" : "0";
  }
}


function startInterval(){
  if(timerInt) clearInterval(timerInt);
  timerInt = setInterval(()=>{
    const sec = getDisplaySeconds();
    setTimerDisplay(sec);
    updateTimerViewVisuals(sec);

    if(state.active){
      $("timerHint").textContent = state.active.running ? "In session…" : "Session paused. Log it to save.";
      // Auto-stop countdown at 0 (do not auto-log)
      if((state.active.mode||"countdown")==="countdown" && state.active.running && sec<=0){
        // Auto-stop at 0 (do not auto-log). Open the same end-flow as "Finish & log".
        pauseTimer(true);
        try{ if($("timerHint")) $("timerHint").textContent = "Time's up."; }catch(e){}
        // Exit in-app fullscreen + browser fullscreen so the end flow is visible.
        try{ if($("fullOverlay")?.classList.contains("show")) fullTimer.close(); }catch(e){}
        try{ if(document.fullscreenElement && document.exitFullscreen) document.exitFullscreen(); }catch(e){}
        // Open the same overlay users get when pressing "Finish & log".
        try{ openEndModal(); }catch(e){}
      }
    }else{
      $("timerHint").textContent = "Ready when you are.";
    }

    if($("fullOverlay")?.classList.contains("show")) syncFullTimerUI();
  }, 250);

  updateStartPage();
  syncFullTimerUI();
}

function pauseTimer(isAuto=false){
  if(!state.active) return;
  const a = state.active;
  if((a.mode||"countdown")==="countdown"){
    a.remainingSec = getActiveRemainingSeconds();
  }else{
    a.elapsedSec = getActiveElapsedSeconds();
  }
  a.running = false;
  a.startTs = null;
  saveState();

  if(timerInt) clearInterval(timerInt);
  timerInt = null;

  if(!isAuto){
    $("timerHint").textContent = "Session paused. Log it to save.";
  }
  updateStartPage();
  syncFullTimerUI();
}

function resumeTimer(){
  if(!state.active) return;
  const a = state.active;
  a.running = true;
  a.startTs = now();
  saveState();
  startInterval();
}

function resetTimer(){
  // Reset to the currently selected configuration and ensure the primary CTA returns to “Start session”
  try{ if(timerInt) clearInterval(timerInt); }catch(e){}
  timerInt = null;

  if(state.active){
    // Stop/clear any in-progress or paused session state
    pauseTimer(true);
    state.active = null;
    saveState();
  }

  const idle = getIdleSeconds();
  setTimerDisplay(idle);
  updateTimerViewVisuals(idle);

  $("timerHint").textContent = "Ready when you are.";
  updateStartPage();
  syncFullTimerUI();
}

function initTimer(){
  fillSessionSubjectSelect();

  const startStopBtn = $("btnStartStop");
  const resetBtn = $("btnResetTimer");
  const stopAndLogBtn = $("btnStopAndLog");
  const fullscreenBtn = $("btnFullscreen");  // Timer view: keep main + fullscreen visuals in sync
  try{
    const timerVisual = $("timerVisual");
    const full = $("fullOverlay");

    // Prefer an explicit setting if present; otherwise infer from existing classes.
    let v = (state.settings && state.settings.timerVisual) ? String(state.settings.timerVisual) : "";
    if(!v){
      if(timerVisual?.classList.contains("timerVisual--digital")) v = "digital";
      else if(timerVisual?.classList.contains("timerVisual--bar")) v = "bar";
      else v = "ring";
    }
    if(!["digital","bar","ring"].includes(v)) v = "ring";

    if(timerVisual){
      timerVisual.classList.remove("timerVisual--digital","timerVisual--bar","timerVisual--ring");
      timerVisual.classList.add("timerVisual--"+v);
    }
    if(full){
      full.classList.remove("timerVisual--digital","timerVisual--bar","timerVisual--ring");
      full.classList.add("timerVisual--"+v);
    }
    // keep visuals in sync
    updateTimerViewVisuals(getDisplaySeconds());
  }catch(e){}


  // Keep idle display aligned to config inputs
  const modeSel = $("sessMode");
  const minInp = $("sessMinutes");
  const syncIdle = ()=>{
    if(!state.active){
      setTimerDisplay(getIdleSeconds());
      $("timerHint").textContent = "Ready when you are.";
    }
  };
  if(modeSel) modeSel.addEventListener("change", syncIdle);
  if(minInp)  minInp.addEventListener("input",  syncIdle);

  // PDF v6: commit bonus appears after user adjusts duration/method
  const touchCommit = ()=>{ try{ markCommitTouched(); }catch(e){}; try{ updateCommitBonus(); }catch(e){}; };
  if(minInp)  minInp.addEventListener("input",  touchCommit);
  if(modeSel) modeSel.addEventListener("change", touchCommit);

  if(startStopBtn) startStopBtn.addEventListener("click", ()=>{
    if(state.active){
      if(state.active.running) pauseTimer();
      else resumeTimer();
      return;
    }

    // start new session
    const strict = !!state.settings.strict;
    if(strict && !state.dailyCheckins[todayKey()]){
      const allowCheckinPopup = !(state.settings && state.settings.popups && state.settings.popups.checkin === false);
      if(allowCheckinPopup){
        checkinModal.open({ source:"prompt" });
      }else{
        hint("Strict mode requires today’s check-in. Enable Daily check-in pop-ups in Settings or open the check-in manually from Overview/Settings.");
      }
      return;
    }
    const subject = $("sessSubject")?.value || "";
    const method = $("sessMethod")?.value || "";
    if(strict && (!subject || !method)){
      hint("Strict mode: choose a subject and method before starting.");
      return;
    }
    const plannedMin = clamp(Number($("sessMinutes")?.value || 25), 1, 600);
    const mode = $("sessMode")?.value || "countdown";
    const topic = ($("sessTopic")?.value||"").trim();

    // New session started: allow next-plan recommendations to refresh next time
    if(!state.ui) state.ui = {};
    state.ui.nextPlan = null;

    state.active = {
      startTs: now(),
      subject, method, methods: (window.getSelectedSessionMethods ? window.getSelectedSessionMethods() : [method]).filter(Boolean), mode, topic,
      plannedMin,
      running: true,
      elapsedSec: 0,
      remainingSec: (mode==="countdown") ? plannedMin*60 : undefined
    };
    saveState();
    startInterval();
    updateStartPage();
  });

  if(resetBtn) resetBtn.addEventListener("click", ()=>{
  const tcard = document.querySelector(".timerCard");
  if(state.active && state.active.running && tcard){ tcard.classList.remove("shake"); void tcard.offsetWidth; tcard.classList.add("shake"); }
  resetTimer();
});

  if(stopAndLogBtn) stopAndLogBtn.addEventListener("click", ()=>{
    if(!state.active){
      hint("No active session to log.");
      return;
    }
    // Freeze timer at the moment you hit “Finish & log”
    if(state.active.running) pauseTimer();
    openEndModal();
  });

  const updateFocusChrome = ()=>{
    const tab = document.querySelector(".tabbar");
    const r = tab ? tab.getBoundingClientRect() : null;
    const topPx = r ? Math.max(0, Math.round(r.bottom + 12)) : 0;
    document.documentElement.style.setProperty("--chromeH", topPx + "px");
  };

  if(fullscreenBtn) fullscreenBtn.addEventListener("click", ()=>{
    // In-app focus timer (does not use browser fullscreen so tabs remain accessible)
    updateFocusChrome();
    const isOpen = document.getElementById("fullOverlay")?.classList.contains("show");
    if(isOpen) fullTimer.close();
    else fullTimer.open();
  });

  // Focus overlay buttons mirror the main controls
  const fExit = $("fullExitBtn");
  if(fExit) fExit.addEventListener("click", ()=>{
    fullTimer.close();
  });

  window.addEventListener("resize", ()=>{
    try{
      if(document.getElementById("fullOverlay")?.classList.contains("show")) updateFocusChrome();
    }catch(e){}
  });

  const fSS = $("fullStartStop");
  if(fSS) fSS.addEventListener("click", ()=> $("btnStartStop")?.click());

  const fReset = $("fullReset");
  if(fReset) fReset.addEventListener("click", ()=> $("btnResetTimer")?.click());

  const fFinish = $("fullFinish");
  if(fFinish) fFinish.addEventListener("click", ()=> $("btnStopAndLog")?.click());

  document.addEventListener("fullscreenchange", ()=>{
    if(document.fullscreenElement) fullTimer.open();
    else fullTimer.close();
    syncFullTimerUI();
  });

  document.addEventListener("keydown", async (e)=>{
    if(e.key==="Escape" && (document.fullscreenElement || $("fullOverlay")?.classList.contains("show"))){
      try{ await document.exitFullscreen?.(); }catch(err){}
      fullTimer.close();
    }
  });

  // Sanity: drop impossible/old active sessions (prevents “random start” on open)
  if(state.active){
    const a = state.active;
    const st = (a.startTs && Number.isFinite(a.startTs)) ? a.startTs : null;
    const sameDay = st ? (new Date(st).toISOString().slice(0,10) === todayKey()) : true;
    if(!sameDay){
      state.active = null;
      saveState();
    }
  }

  // restore timer view after refresh
  if(state.active){
    setTimerDisplay(getDisplaySeconds());
    if(state.active.running) startInterval();
    else updateStartPage();
  }else{
    setTimerDisplay(getIdleSeconds());
    updateStartPage();
  }
}

function updateStartPage(){
  const a = state.active;
  const label = $("activeSessionLabel");
  const btn = $("btnStartStop");
  const stopAndLog = $("btnStopAndLog");

  if(!a){
    if(label) label.textContent = "No active session";
    if(btn) btn.textContent = "Start session";
    if(stopAndLog) stopAndLog.disabled = true;
    try{ updateFinishCoach(); }catch(e){}
    try{ updateCommitBonus(); }catch(e){}
    return;
  }

  const subj = a.subject || "Unselected";
  const meth = a.method || "—";
  if(label) label.textContent = `${subj} • ${meth}`;
  if(btn) btn.textContent = a.running ? "Pause" : "Resume";
  if(stopAndLog) stopAndLog.disabled = false;
  try{ updateFinishCoach(); }catch(e){}
  try{ updateCommitBonus(); }catch(e){}
}


function openEndModal(){
  // Quick one-click reflection popover (Great / Okay / Rough).
  // "Details" opens the full end-session modal for edits.
  if(!state.active) return;

  // Default to a neutral preset so Details is meaningful even if user doesn't choose
  try{ applyQuickPreset("okay"); }catch(e){}
  try{ if(!state.ui) state.ui = {}; state.ui.lastQuickPreset = "okay"; }catch(e){}

  quickEndOverlay.open();
}

function selectedDistractions(){
  const row = $("endDistractRow");
  if(!row) return [];
  const active = [];
  row.querySelectorAll(".pillOpt").forEach(p=>{
    if(p.classList.contains("active")) active.push(p.textContent.trim());
  });
  return active;
}

function initDistractionPills(){
  const row = $("endDistractRow");
  if(!row) return;

  const bind = (pill)=>{
    pill.addEventListener("click", ()=>pill.classList.toggle("active"));
  };

  row.querySelectorAll(".pillOpt").forEach(bind);

  // Custom distraction add
  const addBtn = $("endDistractAdd");
  const inp = $("endDistractCustom");
  const addCustom = ()=>{
    const v = (inp?.value||"").trim();
    if(!v) return;
    // Prevent duplicates (case-insensitive)
    const exists = Array.from(row.querySelectorAll(".pillOpt"))
      .some(p => p.textContent.trim().toLowerCase() === v.toLowerCase());
    if(exists){
      inp.value = "";
      return;
    }
    const p = document.createElement("div");
    p.className = "pillOpt active";
    p.textContent = v;
    row.appendChild(p);
    bind(p);
    inp.value = "";
  };

  if(addBtn && inp){
    addBtn.addEventListener("click", addCustom);
    inp.addEventListener("keydown", (e)=>{
      if(e.key === "Enter"){
        e.preventDefault();
        addCustom();
      }
    });
  }
}


function initEnvPills(){
  const wrap = $("endEnvPresets");
  if(!wrap) return;

  // Toggle preset pills (multi-select, like distractions)
  wrap.addEventListener("click", (e)=>{
    const pill = e.target.closest('.pillOpt[data-env]');
    if(!pill) return;
    pill.classList.toggle("active");
  });

  const inp = $("endEnv");
  const addBtn = $("endEnvAdd");

  const addCustom = ()=>{
    const raw = String(inp?.value || "").trim();
    if(!raw) return;

    const items = raw.split(",").map(s=>s.trim()).filter(Boolean);
    items.forEach(txt=>{
      const key = txt.toLowerCase();
      const all = Array.from(wrap.querySelectorAll(".pillOpt"));
      const match = all.find(p=>String(p.textContent||"").trim().toLowerCase()===key);

      if(match){
        match.classList.add("active");
      }else{
        const p = document.createElement("span");
        p.className = "pillOpt active";
        p.setAttribute("data-env", "custom");
        p.setAttribute("data-env-custom", "1");
        p.textContent = txt;
        wrap.appendChild(p);
      }
    });

    if(inp) inp.value = "";
  };

  addBtn?.addEventListener("click", addCustom);
  inp?.addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){
      e.preventDefault();
      addCustom();
    }
  });
}

function selectedEnvironments(){
  const wrap = $("endEnvPresets");
  const out = [];
  const seen = new Set();

  if(wrap){
    wrap.querySelectorAll(".pillOpt.active").forEach(p=>{
      const t = String(p.textContent||"").trim();
      const k = t.toLowerCase();
      if(!t || seen.has(k)) return;
      seen.add(k);
      out.push(t);
    });
  }

  // Safety: include any un-added free text (comma-separated)
  const raw = String($("endEnv")?.value || "").trim();
  if(raw){
    raw.split(",").map(s=>s.trim()).filter(Boolean).forEach(t=>{
      const k = t.toLowerCase();
      if(seen.has(k)) return;
      seen.add(k);
      out.push(t);
    });
  }

  // 8) Consistency: best day-of-week for quality (n≥5)
  try{
    const byD = Array.from({length:7}, ()=>({sum:0,n:0}));
    all.forEach(s=>{
      const d = new Date(Number(s.startTs||0)).getDay();
      byD[d].sum += Number(s.quality||3);
      byD[d].n += 1;
    });
    const dow = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    const bestD = byD.map((b,i)=>({i, q:b.n?b.sum/b.n:0, n:b.n}))
      .filter(x=>x.n>=5)
      .sort((a,b)=>b.q-a.q)[0];
    if(bestD){
      out.push({
        html: `Best day for quality: <b>${dow[bestD.i]}</b> (${bestD.q.toFixed(1)}/5, n=${bestD.n}).`,
        meta: "Day-of-week average quality (n≥5)."
      });
    }
  }catch(e){}

  // 9) Session length sweet spot (median minutes of your top-quality sessions)
  try{
    const top = all.filter(s=>Number(s.quality||0)>=4).map(s=>Number(s.minutes||0)).filter(n=>n>0);
    if(top.length>=6){
      top.sort((a,b)=>a-b);
      const mid = top[Math.floor(top.length/2)];
      out.push({
        html: `Your high-quality sessions cluster around <b>${Math.round(mid)} min</b>. Try planning the next one near that length.`,
        meta: "Computed from sessions rated 4–5 (n≥6)."
      });
    }
  }catch(e){}

  // 10) Deep work ratio (if deep minutes exist)
  try{
    const deepMin = all.reduce((a,s)=>a + (Number(s.deepMin||0)||0), 0);
    if(deepMin>0 && totalMin>0){
      const pct = Math.round((deepMin/totalMin)*100);
      out.push({
        html: `Deep work share: <b>${pct}%</b> of logged minutes. Aim to raise this by protecting your best hour.`,
        meta: "Based on deep minutes you logged."
      });
    }
  }catch(e){}

  // 11) Distractions impact (avg quality when distractions present vs none)
  try{
    const hasD = all.filter(s=>(s.distractions||[]).length>0);
    const noD  = all.filter(s=>(s.distractions||[]).length===0);
    if(hasD.length>=5 && noD.length>=5){
      const qHas = avgQ(hasD);
      const qNo  = avgQ(noD);
      const diff = (qNo - qHas);
      out.push({
        html: `Distractions cost ~<b>${diff.toFixed(1)}</b> quality points on average (none: ${qNo.toFixed(1)}/5 vs distracted: ${qHas.toFixed(1)}/5).`,
        meta: "Average quality split by distraction presence (n≥5 each)."
      });
    }
  }catch(e){}

  // 12) Environment leverage (top env vs worst env, n≥5)
  try{
    const byE2 = {};
    all.forEach(s=>{
      const envs = Array.isArray(s.envs) && s.envs.length ? s.envs : (s.env ? [s.env] : []);
      (envs.length?envs:["Unspecified"]).forEach(e=>{
        if(!byE2[e]) byE2[e]={sum:0,n:0};
        byE2[e].sum += Number(s.quality||3);
        byE2[e].n += 1;
      });
    });
    const envList = Object.entries(byE2).filter(([e,v])=>v.n>=5).map(([e,v])=>({e, q:v.sum/v.n, n:v.n})).sort((a,b)=>b.q-a.q);
    if(envList.length>=2){
      const best = envList[0], worst = envList[envList.length-1];
      out.push({
        html: `Environment swing: <b>${escapeHtml(best.e)}</b> (${best.q.toFixed(1)}/5) beats <b>${escapeHtml(worst.e)}</b> (${worst.q.toFixed(1)}/5).`,
        meta: "Environment averages (n≥5)."
      });
    }
  }catch(e){}

  // 13) Weekly volume milestone
  try{
    const weekMin = computeWeeklyMinutes(todayKey());
    if(Number.isFinite(weekMin) && weekMin>0){
      out.push({
        html: `This week: <b>${Math.round(weekMin)} min</b> logged. If you repeat today’s pattern, you’ll finish strong.`,
        meta: "From your current week total."
      });
    }
  }catch(e){}

  return out;
}

function saveSessionFromModal(){
  if(!state.active) return;

  const strict = !!state.settings.strict;
  const focus = Number($("endFocus")?.value||3);
  const retrieval = Number($("endRetrieval")?.value||3);
  const perf = Number($("endPerf")?.value||3);
  const effort = Number($("endEffort")?.value||3);
  const frustration = Number($("endFrustration")?.value||3);

  if(strict){
    // minimal validation
    const subject = state.active.subject || $("sessSubject")?.value || "";
    const method = state.active.method || $("sessMethod")?.value || "";
    if(!subject || !method){
      hint("Strict mode: subject + method required.");
      return;
    }
  }

  const endTs = now();

  // Use timer state (supports free + countdown, and excludes time spent paused on the end modal)
  const mode = state.active.mode || $("sessMode")?.value || "countdown";
  const plannedMin = clamp(Number(state.active.plannedMin || $("sessMinutes")?.value || 25), 1, 600);

  let elapsedSec = 0;
  let timerCompleted = false;
  let usedStopClock = false;
  let completionPct = 0;
  let endEarlyMin = 0;
  let endedEarly = false;

  if(mode==="countdown"){
    const total = plannedMin * 60;
    let rem = (typeof state.active.remainingSec === "number") ? state.active.remainingSec : total;
    // If the user was still running, account for the last running segment
    if(state.active.running && state.active.startTs){
      rem = clamp(rem - Math.floor((endTs - state.active.startTs)/1000), 0, total);
    }
    elapsedSec = clamp(total - rem, 0, total);
    completionPct = total>0 ? (elapsedSec/total) : 0;

    // Treat "nearly finished" as completed so metrics/adherence are not skewed by a few seconds/minutes.
    timerCompleted = (rem === 0) || (rem <= 60) || (completionPct >= 0.95);
    endedEarly = !timerCompleted && rem > 60;
    endEarlyMin = Math.max(0, Math.round(rem/60));
    usedStopClock = false;
  }else{
    const base = Number(state.active.elapsedSec || 0);
    const add = (state.active.running && state.active.startTs) ? Math.floor((endTs - state.active.startTs)/1000) : 0;
    elapsedSec = Math.max(0, base + add);
    completionPct = 1;
    timerCompleted = false;
    endedEarly = false;
    endEarlyMin = 0;
    usedStopClock = true;
  }

  let minutes = clamp(Math.max(1, Math.round(elapsedSec/60)), 1, 600);
  // If countdown and essentially finished, count the planned minutes.
  if(mode==="countdown" && (completionPct >= 0.95)) minutes = plannedMin;

  const startTs = endTs - elapsedSec*1000;

  const session = {
    id: "s_"+endTs,
    startTs,
    endTs,
    minutes,
    plannedMin,
    elapsedSec,
    completionPct,
    endedEarly,
    endEarlyMin,
    subject: state.active.subject || $("sessSubject")?.value || "",
    method: state.active.method || $("sessMethod")?.value || "",
    methods: (state.active.methods || (state.active.method ? [state.active.method] : [])).filter(Boolean),
    mode: state.active.mode || $("sessMode")?.value || "",
    topic: state.active.topic || ($("sessTopic")?.value||"").trim(),
    env: (selectedEnvironments().join(", ") || ""),
      envs: selectedEnvironments(),
    distractions: selectedDistractions(),
    notes: ($("endNotes")?.value||"").trim(),
    focus, retrieval, perf, effort, frustration,
    // Base quality from ratings
    baseQuality: clamp(Math.round((focus*0.45 + retrieval*0.20 + perf*0.35)), 1, 5),
    // Apply distraction penalty (strict mode increases the penalty)
    quality: (()=>{
      const dq = (selectedDistractions().length) * ((state.settings.strict)?0.60:0.30);
      const baseQ = clamp(Math.round((focus*0.45 + retrieval*0.20 + perf*0.35)), 1, 5);
      return clamp(Math.round(baseQ - dq), 1, 5);
    })()
  };

  // Deep work classification (automatic)
  session.deep = (session.minutes >= 45) && ((session.distractions||[]).length <= 1) && (Number(session.focus||0) >= 4) && (Number(session.frustration||0) <= 2);

  // Stop watch (free mode) sessions are never treated as “ended early”.
  if(session.usedStopClock || session.mode === "free"){
    session.endedEarly = false;
    session.endEarlyMin = 0;
  }

  state.sessions.push(session);

  // baseline updates from sessions (EMA)
  updateBaselinesFromSession(session);

  // Reset “Next session” suggestion cycle after logging any session
  if(state.ui && state.ui.nextPlan) state.ui.nextPlan = null;

  state.active = null;
  saveState();

  endModal.close();
  // Post-save UX: show the break recommendation first, then (after a small gap) the reward pill.
  const pillMs = 3400; // toast duration (readable)
  const gapMs = 250;   // small pause between toast and pill
  const r = nextRewardPillCopy(session);
  try{ showCoachBreak(session, { force:true, durationMs: pillMs, title: "Break" }); }catch(e){}
  setTimeout(()=>{ try{ showRewardPill(r.l1, r.l2, pillMs); }catch(e){} }, pillMs + gapMs);

  setTimerDisplay(getIdleSeconds());
  $("timerHint").textContent = "Saved. Ready when you are.";
  updateStartPage();
  updateAll();
  drawAnalytics();

  // (Toast removed to keep post-save UX clean)
  // Button “Saved” tick
  try{
    const sb = $("saveEndBtn");
    if(sb){
      const prev = sb.textContent;
      sb.textContent = "✓ Saved";
      sb.style.transform = "scale(1.02)";
      setTimeout(()=>{ sb.style.transform = "scale(1)"; }, 140);
      setTimeout(()=>{ sb.textContent = prev; }, 520);
    }
  }catch(e){}
}

function updateBaselinesFromSession(s){
  const a = state.baselines.adapt;
  const dailyMinObs = clamp(Number(s.minutes||0), 0, 600); // per-session proxy; weekly goal handles larger scales
  // shift dailyMin slightly based on typical session length (gentle)
  state.baselines.dailyMin = (1-a)*state.baselines.dailyMin + a*clamp(dailyMinObs*2, 0, 600);
  // focus proxy
  state.baselines.focus = (1-a)*state.baselines.focus + a*clamp(Number(s.focus||3), 1, 5);
  // keep adapt updated
  state.baselines.adapt = computeAdaptRate(state.baselines);
}

/**********************
 * Active (effective) goals — Manual or Auto (Option 2)
 **********************/
function ensureGoalsShape(){
  if(!state.goals) state.goals = {};
  if(!state.goals.manual){
    state.goals.manual = {
      weeklyMin: Number(state.goals.weeklyMin ?? 600),
      avgLenTarget: Number(state.goals.avgLenTarget ?? 45),
      startFrom: state.goals.startFrom || "17:00",
      startTo: state.goals.startTo || "21:00",
      sessionsPerWeekTarget: Number(state.goals.sessionsPerWeek ?? 8),
      qualityTarget: Number(state.goals.qualityTarget ?? 4)
    };
  }else{
    // Backfill new keys for older saves
    if(state.goals.manual.avgLenTarget == null) state.goals.manual.avgLenTarget = 45;
    if(state.goals.manual.sessionsPerWeekTarget == null) state.goals.manual.sessionsPerWeekTarget = Number(state.goals.sessionsPerWeek ?? 8);
  }
  if(typeof state.goals.autoEnabled !== "boolean") state.goals.autoEnabled = false;

  // Keep legacy keys for compatibility (hidden in UI)
  if(state.goals.sessionsPerWeek == null) state.goals.sessionsPerWeek = 8;
  if(state.goals.strainMin == null) state.goals.strainMin = 200;
  if(state.goals.strainMax == null) state.goals.strainMax = 420;
  if(!state.goals.perSubject) state.goals.perSubject = {};
}

function parsePlaces(text){
  return String(text||"")
    .split(",")
    .map(s=>s.trim().toLowerCase())
    .filter(Boolean);
}

function timeToMinutes(t){
  const s = String(t||"").trim();
  const m = /^(\d{1,2}):(\d{2})$/.exec(s);
  if(!m) return null;
  const hh = clamp(Number(m[1]),0,23);
  const mm = clamp(Number(m[2]),0,59);
  return hh*60+mm;
}

function inWindow(startTs, fromStr, toStr){
  const from = timeToMinutes(fromStr);
  const to = timeToMinutes(toStr);
  if(from==null || to==null) return false;
  const d = new Date(startTs);
  const mins = d.getHours()*60 + d.getMinutes();
  if(from===to) return true;
  if(from < to) return (mins>=from && mins<=to);
  // window wraps midnight
  return (mins>=from || mins<=to);
}

function computeSuggestedGoals14d(){
  const end = now();
  const start = end - 14*24*3600*1000;
  const sess = sessionsInRange(start, end);

  const totalMin = sess.reduce((a,s)=>a+Number(s.minutes||0),0);
  const avgPerDay = totalMin / 14;

  // Weekly minutes: base on recent average, then gently push upward (6–10%)
  const push = avgPerDay>=90 ? 1.06 : 1.10;
  let weeklyMin = Math.round(avgPerDay * 7 * push);
  weeklyMin = clamp(weeklyMin, 120, 5000);

  // Average session length (minutes): average + gentle push
  const avgLenObs = sess.length ? (totalMin / sess.length) : 35;
  const avgLenTarget = clamp(Math.round(avgLenObs + 6), 15, 240);

  // Start window suggestion: median start hour +- a buffer
  let startFrom="17:00", startTo="21:00";
  const starts = sess.map(s=>Number(s.startTs||0)).filter(Boolean).sort((a,b)=>a-b);
  if(starts.length){
    const mid = starts[Math.floor(starts.length/2)];
    const d = new Date(mid);
    const h = d.getHours();
    const fromH = clamp(h-1,0,23);
    const toH = clamp(h+2,0,23);
    const pad = (n)=>String(n).padStart(2,"0");
    startFrom = `${pad(fromH)}:00`;
    startTo = `${pad(toH)}:00`;
  }

  // Sessions per week target: based on last 14 days (2 weeks), gently pushed upward
  const sessPerWeekObs = sess.length/2;
  const sessionsPerWeekTarget = clamp(Math.round(sessPerWeekObs + 1), 2, 20);

  // Quality target: average + small push
  const qvals = sess.map(s=>Number(s.quality||s.baseQuality||0)).filter(v=>v>0);
  const avgQ = qvals.length ? (qvals.reduce((a,v)=>a+v,0)/qvals.length) : 3.5;
  const qualityTarget = clamp(Math.round(avgQ + 0.4), 3, 5);

  return { weeklyMin, avgLenTarget, startFrom, startTo, sessionsPerWeekTarget, qualityTarget };
}

function getEffectiveGoals(){
  ensureGoalsShape();
  if(state.goals.autoEnabled){
    return computeSuggestedGoals14d();
  }
  return {
    weeklyMin: Number(state.goals.manual.weeklyMin||0),
    avgLenTarget: Number(state.goals.manual.avgLenTarget||45),
    startFrom: state.goals.manual.startFrom||"17:00",
    startTo: state.goals.manual.startTo||"21:00",
    sessionsPerWeekTarget: Number(state.goals.manual.sessionsPerWeekTarget ?? (state.goals.sessionsPerWeek ?? 8)),
    qualityTarget: Number(state.goals.manual.qualityTarget||4)
  };
}

/**********************
 * Goals
 **********************/

function initSettingsAccordion(){
  const cards = document.querySelectorAll("#page-settings .accCard");
  cards.forEach(card=>{
    const head = card.querySelector(".head");
    if(!head) return;
    // prevent duplicate binding
    if(head.dataset.bound==="1") return;
    head.dataset.bound="1";
    head.addEventListener("click", ()=>{
      card.classList.toggle("collapsed");
    });
    // start collapsed by default
    card.classList.add("collapsed");
  });
}


function initFeedbackForm(){
  const saveBtn = $("fbSave");
  const clearBtn = $("fbClear");
  const emailEl = $("fbEmail");
  const textEl = $("fbText");
  const noteEl = $("fbSavedNote");
  if(!saveBtn || !textEl) return;

  // Load draft (if any)
  try{
    if(!state.ui) state.ui = {};
    if(state.ui.feedbackDraft){
      textEl.value = String(state.ui.feedbackDraft.text || "");
      if(emailEl) emailEl.value = String(state.ui.feedbackDraft.email || "");
    }
    if(noteEl && Array.isArray(state.feedback) && state.feedback.length){
      const last = state.feedback[state.feedback.length-1];
      const when = new Date(Number(last.ts||0) || Date.now()).toLocaleString();
      noteEl.textContent = `Last saved: ${when}`;
    }
  }catch(e){}

  // Persist draft as you type (local only)
  const saveDraft = ()=>{
    try{
      if(!state.ui) state.ui = {};
      state.ui.feedbackDraft = { email: (emailEl?.value||"").trim(), text: (textEl?.value||"").trim() };
      saveState();
    }catch(e){}
  };
  ["input","change"].forEach(ev=>{
    textEl.addEventListener(ev, saveDraft);
    emailEl && emailEl.addEventListener(ev, saveDraft);
  });

  clearBtn && clearBtn.addEventListener("click", ()=>{
    if(emailEl) emailEl.value = "";
    textEl.value = "";
    try{
      if(!state.ui) state.ui = {};
      state.ui.feedbackDraft = { email:"", text:"" };
      saveState();
    }catch(e){}
    if(noteEl) noteEl.textContent = "Cleared.";
  });

  saveBtn.addEventListener("click", ()=>{
    const payload = {
      ts: now(),
      email: (emailEl?.value||"").trim(),
      text: (textEl?.value||"").trim()
    };
    if(!payload.text){
      hint("Write some feedback first.");
      return;
    }
    if(!Array.isArray(state.feedback)) state.feedback = [];
    state.feedback.push(payload);
    // keep the last 50 notes to avoid unbounded growth
    if(state.feedback.length>50) state.feedback = state.feedback.slice(-50);

    // clear draft but keep input visible
    try{
      if(!state.ui) state.ui = {};
      state.ui.feedbackDraft = { email: payload.email, text: payload.text };
    }catch(e){}
    saveState();

    if(noteEl){
      const when = new Date(payload.ts).toLocaleString();
      noteEl.textContent = `Saved locally: ${when}`;
    }
    hint("Feedback saved locally.");
  });
}

function initGoals(){
  ensureGoalsShape();

  const qRange = $("goalQuality");
  const qVal = $("goalQualityVal");
  if(qRange && qVal){
    qVal.textContent = `${qRange.value}/5`;
  }

  const autoToggle = $("goalAutoEnabled");
  const preview = $("autoGoalsPreview");
  const hint = $("autoGoalsHint");
  const formGrid = $("goalsFormGrid");
  const resetBtn = $("resetGoalsBtn");

  const countDataDays = ()=>{
    const days = new Set();
    (state.sessions||[]).forEach(s=>{
      const d = s?.date || (s?.startTs ? (new Date(Number(s.startTs))).toISOString().slice(0,10) : null);
      if(d) days.add(d);
    });
    if(state.dailyCheckins){
      Object.keys(state.dailyCheckins).forEach(k=> days.add(k));
    }
    return days.size;
  };

  const applyFormFrom = (g, disable)=>{
    if($("goalWeeklyMin")) $("goalWeeklyMin").value = Math.round((g.weeklyMin ?? 0)/7);
    if($("goalAvgLen")) $("goalAvgLen").value = g.avgLenTarget ?? 45;
    if($("goalStartFrom")) $("goalStartFrom").value = g.startFrom || "17:00";
    if($("goalStartTo")) $("goalStartTo").value = g.startTo || "21:00";
    if($("goalSessionsPerWeek")) $("goalSessionsPerWeek").value = g.sessionsPerWeekTarget ?? (state.goals.sessionsPerWeek ?? 8);
    if($("goalQuality")) $("goalQuality").value = g.qualityTarget ?? 4;
    if($("goalQualityVal")) $("goalQualityVal").textContent = `${(($("goalQuality")?.value)||4)}/5`;

    ["goalWeeklyMin","goalAvgLen","goalStartFrom","goalStartTo","goalSessionsPerWeek","goalQuality"].forEach(id=>{
      const el=$(id); if(el){ el.disabled = !!disable; }
    });

    if(formGrid){
      formGrid.classList.toggle("goalsLocked", !!disable);
    }
  };

  const refreshAutoPreview = ()=>{
    if(!preview) return;
    if(!state.goals.autoEnabled){
      preview.textContent = "";
      return;
    }
    const s = computeSuggestedGoals14d();
    const daily = Math.round((s.weeklyMin||0)/7);
    preview.innerHTML =
      `<span class="small">Suggested:</span> `+
      `<b>${daily} min/day</b>, `+
      `<b>${s.avgLenTarget} min/session</b>, `+
      `<b>${s.startFrom}–${s.startTo}</b>, `+
      `<b>quality ${s.qualityTarget}/5</b>`;
  };

  const refreshAutoEligibility = ()=>{
    const days = countDataDays();
    const ok = days >= 7;
    if(hint){
      hint.textContent = ok
        ? "Suggestions are based on the last 14 days and gently push you upward."
        : `Auto-goals unlock after 7 days of data (currently ${days}/7).`;
    }
    return ok;
  };

  const animateAutoBlocked = ()=>{
    try{
      const wrap = autoToggle?.closest(".row") || autoToggle?.parentElement;
      const sw = autoToggle?.closest("label.switch") || autoToggle?.parentElement;
      if(wrap){
        wrap.classList.remove("shake");
        void wrap.offsetWidth;
        wrap.classList.add("shake");
        setTimeout(()=>wrap.classList.remove("shake"), 420);
      }
      if(sw){
        sw.classList.remove("shake");
        void sw.offsetWidth;
        sw.classList.add("shake");
        setTimeout(()=>sw.classList.remove("shake"), 420);
      }
      if(hint){
        hint.classList.remove("pulse","pulseBig");
        void hint.offsetWidth;
        hint.classList.add("pulse","pulseBig");
        setTimeout(()=>hint.classList.remove("pulse","pulseBig"), 620);
      }
    }catch(e){}
  };

  const saveManualFromForm = ()=>{
    if(state.goals.autoEnabled) return; // locked
    ensureGoalsShape();

    const dailyMin = clamp(Number($("goalWeeklyMin")?.value||120), 0, 720);
    state.goals.manual.dailyMin = dailyMin;
    state.goals.manual.weeklyMin = dailyMin * 7;
    state.goals.manual.avgLenTarget = clamp(Number($("goalAvgLen")?.value||45), 5, 600);
    state.goals.manual.startFrom = $("goalStartFrom")?.value || "17:00";
    state.goals.manual.startTo = $("goalStartTo")?.value || "21:00";
    state.goals.manual.sessionsPerWeekTarget = clamp(Math.round(Number($("goalSessionsPerWeek")?.value||8)), 0, 50);
    state.goals.sessionsPerWeek = state.goals.manual.sessionsPerWeekTarget;
    state.goals.manual.qualityTarget = clamp(Number($("goalQuality")?.value||4), 1, 5);

    // Keep compatibility key aligned to active weekly target
    state.goals.weeklyMin = state.goals.manual.weeklyMin;

    saveState();
    updateAll();
  };

  const setMode = (enabled)=>{
    const eligible = refreshAutoEligibility();
    if(enabled && !eligible){
      if(autoToggle) autoToggle.checked = false;
      state.goals.autoEnabled = false;
      applyFormFrom(state.goals.manual, false);
      refreshAutoPreview();
      saveState();
      updateAll();
      animateAutoBlocked();
      return;
    }

    state.goals.autoEnabled = !!enabled;
    if(autoToggle) autoToggle.checked = !!enabled;

    if(enabled){
      const s = computeSuggestedGoals14d();
      applyFormFrom(s, true);
      // weeklyMin compatibility key aligned to effective value
      state.goals.weeklyMin = s.weeklyMin;
    }else{
      applyFormFrom(state.goals.manual, false);
      state.goals.weeklyMin = state.goals.manual.weeklyMin;
    }

    refreshAutoPreview();
    saveState();
    updateAll();
  };

  // Attach autosave listeners (manual mode only)
  ["goalWeeklyMin","goalAvgLen","goalSessionsPerWeek"].forEach(id=>{
    const el=$(id); if(el) el.addEventListener("input", saveManualFromForm);
  });
  ["goalStartFrom","goalStartTo"].forEach(id=>{
    const el=$(id); if(el) el.addEventListener("change", saveManualFromForm);
  });
  if(qRange){
    qRange.addEventListener("input", ()=>{
      if(qVal) qVal.textContent = `${qRange.value}/5`;
      saveManualFromForm();
    });
  }

  // Toggle behavior with "blocked" animation
  if(autoToggle){
    autoToggle.addEventListener("click", (e)=>{
      const wantsOn = !autoToggle.checked; // click toggles after, so this is prior state
      if(wantsOn){
        const ok = refreshAutoEligibility();
        if(!ok){
          // keep it off and animate
          e.preventDefault();
          autoToggle.checked = false;
          animateAutoBlocked();
          return;
        }
      }
    });
    autoToggle.addEventListener("change", ()=> setMode(autoToggle.checked));
  }

  // initial paint
  refreshAutoEligibility();
  setMode(!!state.goals.autoEnabled);

  // Reset remains, but saves immediately
  if(resetBtn) resetBtn.addEventListener("click", ()=>{
    ensureGoalsShape();
    state.goals.manual = {
      weeklyMin: 600,
      avgLenTarget: 45,
      startFrom: "17:00",
      startTo: "21:00",
      sessionsPerWeekTarget: 8,
      qualityTarget: 4
    };
    state.goals.sessionsPerWeek = 8;

    if(state.goals.autoEnabled){
      const s = computeSuggestedGoals14d();
      applyFormFrom(s, true);
      state.goals.weeklyMin = s.weeklyMin;
    }else{
      applyFormFrom(state.goals.manual, false);
      state.goals.weeklyMin = state.goals.manual.weeklyMin;
    }

    refreshAutoPreview();
    saveState();
    updateAll();
  });
}


function renderGoalsPerSubject(){
  const wrap = $("goalPerSubjectWrap");
  if(!wrap) return;
  wrap.innerHTML = "";

  if(getStudyItems().length===0){
    const empty = document.createElement("div");
    empty.className = "small";
    empty.style.color = "var(--muted)";
    empty.textContent = "No subjects or projects yet — add them in Settings.";
    wrap.appendChild(empty);
    return;
  }

  getStudyItems().forEach(sub=>{
    const item = document.createElement("div");
    item.className = "subItem";

    const top = document.createElement("div");
    top.className = "subItemTop";
    const name = document.createElement("div");
    name.className = "name";
    name.textContent = sub;

    const meta = document.createElement("div");
    meta.className = "meta";
    meta.textContent = "min / week";

    top.appendChild(name);
    top.appendChild(meta);

    const row = document.createElement("div");
    row.className = "row";
    row.style.justifyContent = "space-between";
    row.style.alignItems = "center";
    row.style.gap = "10px";

    const inp = document.createElement("input");
    inp.className = "inp";
    inp.type = "number";
    inp.min = "0";
    inp.max = "5000";
    inp.step = "5";
    inp.style.width = "140px";
    inp.value = Number(state.goals.perSubject?.[sub]||0);
    inp.setAttribute("data-goal-subject", sub);
    inp.addEventListener("input", ()=> setGoalsSavedStatus(false));

    row.appendChild(document.createElement("div")); // spacer left
    row.appendChild(inp);

    item.appendChild(top);
    item.appendChild(row);
    wrap.appendChild(item);
  });
}

/**********************
 * Settings
 **********************/

function applyOverviewVisibility(){
  const cfg = state?.settings?.overview || defaultOverviewVisibility();
  OVERVIEW_CARDS.forEach(c=>{
    const el = $(c.id);
    if(!el) return;
    el.style.display = (cfg[c.id]===false) ? "none" : "";
  });
}

function initOverviewLayoutSettings(){
  const wrap = $("overviewLayoutList");
  if(!wrap) return;

  // Ensure config exists
  if(!state.settings.overview) state.settings.overview = defaultOverviewVisibility();
  // Build rows
  wrap.innerHTML = "";
  OVERVIEW_CARDS.forEach(c=>{
    const row = document.createElement("div");
    row.className = "row";
    row.style.justifyContent = "space-between";
    row.style.alignItems = "center";

    const left = document.createElement("div");
    left.innerHTML = `<div style="font-weight:850;">${c.label}</div><div class="small">Show in Overview</div>`;

    const right = document.createElement("label");
    right.className = "switch";
    right.style.flex = "0 0 auto";
    const inp = document.createElement("input");
    inp.type = "checkbox";
    inp.checked = state.settings.overview[c.id] !== false;
    const span = document.createElement("span");
    span.className = "slider";
    inp.addEventListener("change", ()=>{
      state.settings.overview[c.id] = !!inp.checked;
      saveState();
      applyOverviewVisibility();
    });
    right.appendChild(inp);
    right.appendChild(span);

    row.appendChild(left);
    row.appendChild(right);
    wrap.appendChild(row);
  });
}

function initSettings(){
  // Theme buttons
  document.querySelectorAll("[data-theme-btn]").forEach(b=>{
    b.addEventListener("click", ()=>{
      applyTheme(b.getAttribute("data-theme-btn"));
      updateAll();
      drawAnalytics();
    });
  });


  // Pop-up toggles
  state.settings = state.settings || {};
  if(!state.settings.popups) state.settings.popups = {nextPlan:true, coach:true, checkin:true, recBanner:true};

  const pNext = $("popupNextPlan");
  if(pNext){
    pNext.checked = (state.settings.popups.nextPlan !== false);
    pNext.addEventListener("change", ()=>{
      state.settings.popups.nextPlan = !!pNext.checked;
      saveState();
    });
  }

  const pCoach = $("popupCoach");
  if(pCoach){
    pCoach.checked = (state.settings.popups.coach !== false);
    pCoach.addEventListener("change", ()=>{
      state.settings.popups.coach = !!pCoach.checked;
      saveState();
    });
  }

  const pCheck = $("popupCheckin");
  if(pCheck){
    pCheck.checked = (state.settings.popups.checkin !== false);
    pCheck.addEventListener("change", ()=>{
      state.settings.popups.checkin = !!pCheck.checked;
      saveState();
      updateSettingCheckinHint();
    });
  }


  const pRec = $("popupRecBanner");
  if(pRec){
    pRec.checked = (state.settings.popups.recBanner !== false);
    pRec.addEventListener("change", ()=>{
      state.settings.popups.recBanner = !!pRec.checked;
      saveState();
      updateRecommendation();
      updateInsightBanner();
    });
  }


  // Strict toggle
  const t = $("strictToggle");
  if(t){
    t.checked = !!state.settings.strict;
    t.addEventListener("change", ()=>{
      state.settings.strict = !!t.checked;
      saveState();
    });
  }

  // Daily check-in schedule
  const cti = $("settingCheckinTime");
  if(cti){
    cti.value = (state.settings && state.settings.checkinTime) ? state.settings.checkinTime : "20:00";
    cti.addEventListener("change", ()=>{
      state.settings.checkinTime = cti.value || "20:00";
      saveState();
      updateSettingCheckinHint();
    });
  }
  const openCi = $("btnOpenCheckinNow");
  if(openCi) openCi.addEventListener("click", ()=>{
    // Settings preview should match the current time of day (not "what is due")
    const hr = (new Date()).getHours();
    const part = (hr < 12) ? "morning" : "evening";
    try{ openCheckinWithPart(part); }catch(e){ checkinModal.open({ source:"settings" }); }
  });
  updateSettingCheckinHint();

  const wipe = $("btnWipe");
  if(wipe) wipe.addEventListener("click", ()=>{
    const ok = confirm("Reset all StudyPulse data stored in this browser? This cannot be undone.");
    if(!ok) return;
    localStorage.removeItem(LS_KEY);
    state = defaultState();
    saveState();
    location.reload();
  });

  initOverviewLayoutSettings();
  applyOverviewVisibility();
}

/**********************
 * Overview metrics + charts (lightweight)
 **********************/
function startOfDay(ts){
  const d = new Date(ts);
  return new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
}
function startOfWeek(ts){
  const d = new Date(ts);
  const day = (d.getDay()+6)%7; // Monday=0
  const s = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime() - day*24*3600*1000;
  return s;
}

function minutesInRange(startMs, endMs){
  return sessionsInRange(startMs,endMs).reduce((a,s)=>a+(Number(s.minutes)||0), 0);
}
function sessionsCountInRange(startMs, endMs){
  return sessionsInRange(startMs,endMs).length;
}
function streakDays(){
  // consecutive LOCAL days up to today with >=1 session (avoids UTC day-key drift)
  const keyOf = (d)=>{
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const da = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${da}`;
  };
  const dates = new Set(
    (state.sessions||[])
      .map(s=>{
        const ts = Number(s?.startTs || s?.endTs || 0);
        if(!ts) return null;
        return keyOf(new Date(ts));
      })
      .filter(Boolean)
  );
  let d = new Date();
  let streak = 0;
  for(;;){
    const key = keyOf(d);
    if(!dates.has(key)) break;
    streak++;
    d = new Date(d.getTime() - 24*3600*1000);
  }
  return streak;
}

function updateReadinessUI(){
  const valEl = $("readinessVal");
  const arc = $("readinessArc");
  const titleEl = $("readinessStateTitle");
  const descEl = $("readinessStateDesc");
  const interpEl = $("readinessInterpret");

  const {score, source} = readinessToday();
  const band = readinessBand(score);

  // Update ring gradient hue (CSS vars) even when the Overview tab is not active
  const hue = readinessHue(score);
  try{ applyMetricHue(valEl, score); }catch(e){}
  document.documentElement.style.setProperty("--rgA", `hsl(${hue}, 80%, 55%)`);
  document.documentElement.style.setProperty("--rgB", `hsl(${hue+18}, 80%, 55%)`);
  document.documentElement.style.setProperty("--rgGlowA", `hsla(${hue}, 80%, 55% / .20)`);
  document.documentElement.style.setProperty("--rgGlowB", `hsla(${hue+18}, 80%, 55% / .12)`);

  const overviewActive = !!document.getElementById("page-overview")?.classList.contains("active");
  if(!state.ui) state.ui = {};

  // If the Overview page is not active, defer changing the visible ring/value so it can animate on return.
  if(!overviewActive){
    state.ui.pendingReadinessScore = score;
    return;
  }

  const prevShown = (typeof state.ui.lastReadinessShown === "number") ? state.ui.lastReadinessShown : score;
  const shouldAnimate = (typeof state.ui.lastReadinessShown === "number") && (prevShown !== score);

  // Numeric score
  if(valEl){
    if(shouldAnimate){
      const curTxt = (valEl.textContent || "").trim();
      if(!curTxt || curTxt === "--") valEl.textContent = String(prevShown);
      valEl.dataset.prev = String(prevShown);
    }
    // animateNumber reads the current rendered value and animates to the new target
    animateNumber(valEl, score, 650, "", false);
    valEl.dataset.prev = String(score);
  }

  // Ring visual (force a visible animation when returning to Overview)
  if(arc){
    const C = 439.823; // 2*pi*70
    const toP = clamp(score/100, 0, 1);
    arc.style.strokeDasharray = String(C);

    if(shouldAnimate){
      const fromP = clamp(prevShown/100, 0, 1);
      const fromOff = C*(1-fromP);
      const toOff = C*(1-toP);

      const prevTrans = arc.style.transition;
      arc.style.transition = "none";
      arc.style.strokeDashoffset = String(fromOff);
      // force reflow to ensure the next transition is visible
      void arc.getBoundingClientRect();
      arc.style.transition = prevTrans || "stroke-dashoffset 520ms ease-out";
      arc.style.strokeDashoffset = String(toOff);
    }else{
      arc.style.strokeDashoffset = String(C*(1-toP));
    }
  }

  // Optional descriptive text (elements may not exist in the current layout)
  if(titleEl) titleEl.textContent = band.title + (source==="baseline" ? " (estimated)" : "");
  if(descEl) descEl.textContent = band.desc;

  // Short interpretation (1–2 lines) under the ring
  if(interpEl){
    let msg1 = "";
    let msg2 = "";
    if(source === "baseline"){
      msg1 = "Estimated readiness — no check-in yet.";
      msg2 = "Complete today’s check-in for accuracy.";
    }else if(score >= 75){
      msg1 = "High readiness — push a deep-work block.";
      msg2 = "Best for your hardest tasks.";
    }else if(score >= 45){
      msg1 = "Moderate readiness — steady pace.";
      msg2 = "Mix deep work and review.";
    }else if(score >= 25){
      msg1 = "Low readiness — keep it short.";
      msg2 = "Do lighter work or revision.";
    }else{
      msg1 = "Very low readiness — protect recovery.";
      msg2 = "Do minimal work or rest.";
    }
    interpEl.textContent = msg1 + "\n" + msg2;
  }

  state.ui.lastReadinessShown = score;
  state.ui.pendingReadinessScore = null;
}


function updateMiniHeader(){
  const st = streakDays();
  const weekStart = startOfWeek(now());
  const weekEnd = weekStart + 7*24*3600*1000;
  const weekSessions = sessionsCountInRange(weekStart, weekEnd);
  const weekMin = minutesInRange(weekStart, weekEnd);

  if($("miniStreak")) $("miniStreak").textContent = String(st);
  if($("miniSessions")) $("miniSessions").textContent = String(weekSessions);
  if($("miniTime")) $("miniTime").textContent = `${Math.round(weekMin/60*10)/10}h`;
}

function updateOverviewTargets(){
  const dailyTarget = (getEffectiveGoals().weeklyMin||0)/7;
  const d0 = startOfDay(now());
  const d1 = d0 + 24*3600*1000;
  const minToday = minutesInRange(d0,d1);
  const strain = strainToday();

  const pct = dailyTarget>0 ? clamp(minToday/dailyTarget,0,1) : 0;

  if($("todayProgressText")) $("todayProgressText").textContent = `${Math.round(minToday)} / ${Math.round(dailyTarget)} min`;
  try{ applyMetricHue($("todayProgressText"), clamp(pct*100, 0, 100)); }catch(e){}
  if($("todayStrainText")) $("todayStrainText").textContent = `${Math.round(strain)} strain-min`;
  const bar = $("todayProgressBar");
  if(bar){
    animateBar(bar, pct);
    applyBarHue(bar, clamp(pct*100, 0, 100), .46);
  }
  const progCard = document.querySelector("#cardTodayTarget") || document.querySelector("#cardToday");
  if(progCard){
    let tick = progCard.querySelector(".milestoneTick");
    if(!tick){
      tick = document.createElement("div");
      tick.className = "milestoneTick";
      tick.innerHTML = `<svg viewBox="0 0 24 24" fill="none"><path d="M20 7L10.5 16.5L4 10" stroke="rgba(234,240,255,.92)" stroke-width="2.6" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      progCard.appendChild(tick);
    }
    if(pct>=1){
      tick.classList.add("show");
      setTimeout(()=>tick.classList.remove("show"), 900);
      if(celebrateOnce("daily_minutes")) celebrateGoal(progCard, "Daily target achieved.");
    }
  }

  // PATCH: Daily total card (number + bar vs today's goal)
  const todayGoal = Math.max(Number(state.baselines?.dailyMin||0), Number(dailyTarget||0));
  const pctDaily = todayGoal>0 ? clamp(minToday/todayGoal,0,1) : 0;

  if($("dailyTotalText")) $("dailyTotalText").textContent = `${Math.round(minToday)}m`;
  try{ applyMetricHue($("dailyTotalText"), clamp(pctDaily*100, 0, 100)); }catch(e){}
  if($("dailyTotalBar")){
    animateBar($("dailyTotalBar"), pctDaily);
    applyBarHue($("dailyTotalBar"), clamp(pctDaily*100, 0, 100), .40);
  }
  if($("dailyTotalNote")) $("dailyTotalNote").textContent = `${Math.round(pctDaily*100)}% of today’s goal (${Math.round(todayGoal)}m)`;

  // PATCH: Avg distractions per session — this week vs previous week
  const ws0 = startOfWeek(now());
  const ws1 = ws0 + 7*24*3600*1000;
  const prev0 = ws0 - 7*24*3600*1000;
  const prev1 = ws0;

  const wSess = sessionsInRange(ws0, ws1);
  const pSess = sessionsInRange(prev0, prev1);

  const avgDistr = (arr)=>{
    if(!arr || !arr.length) return 0;
    const total = arr.reduce((a,s)=>a + (Array.isArray(s.distractions) ? s.distractions.length : 0), 0);
    return total / Math.max(1, arr.length);
  };

  const dNow = avgDistr(wSess);
  const dPrev = avgDistr(pSess);

  const valEl = $("windowVal");
  const noteEl = $("windowNote");

  if(!dNow && !dPrev){
    if(valEl) valEl.textContent = "--";
    if(noteEl) noteEl.textContent = "Log more sessions to compare weeks";
    if(valEl) valEl.style.color = "rgba(234,240,255,.88)";
  }else if(dNow && !dPrev){
    if(valEl) valEl.textContent = dNow.toFixed(1);
    if(noteEl) noteEl.textContent = "Log sessions this week to unlock comparisons.";
    if(valEl) valEl.style.color = "rgba(234,240,255,.88)";
  }else if(!dNow && dPrev){
    if(valEl) valEl.textContent = "0.0";
    if(noteEl) noteEl.textContent = "Start your first session to generate this weekly trend.";
    if(valEl) valEl.style.color = "var(--bad)";
  }else{
    const delta = dNow - dPrev; // negative is improvement
    const improving = delta < -0.05;
    const worsening = delta > 0.05;

    if(valEl) valEl.textContent = dNow.toFixed(1);

    const arrow = improving ? "↓" : (worsening ? "↑" : "→");
    const label = improving ? "Improving" : (worsening ? "Getting worse" : "Flat");
    if(noteEl){
      const abs = Math.abs(delta).toFixed(1);
      noteEl.textContent = `${label} (${arrow}${abs} vs last week)`;
    }

    try{ applyMetricHue(valEl, clamp(100 - (dNow/5)*100, 0, 100)); }catch(e){}
  }



// PATCH: Sessions ended early — this week
const eeValEl = $("endedEarlyWeekVal");
const eeNoteEl = $("endedEarlyWeekNote");
if(eeValEl){
  const ended = wSess.filter(s=>!!s.endedEarly).length;
  const totalS = wSess.length;
  const pct = totalS ? Math.round((ended/totalS)*100) : 0;

  const minsLeftArr = wSess
    .filter(s=>!!s.endedEarly && Number(s.endEarlyMin||0)>0)
    .map(s=>Number(s.endEarlyMin||0));
  const avgLeft = minsLeftArr.length ? Math.round(minsLeftArr.reduce((a,b)=>a+b,0)/minsLeftArr.length) : 0;

  eeValEl.textContent = String(ended);
  if(eeNoteEl){
    if(!totalS){
      eeNoteEl.textContent = "Start your first session to populate this metric." ;
    }else if(!ended){
      eeNoteEl.textContent = `0/${totalS} sessions ended early.`;
    }else{
      eeNoteEl.textContent = `${ended}/${totalS} sessions ended early (${pct}%). Avg time left: ${avgLeft} min.`;
    }
  }

  try{ applyMetricHue(eeValEl, clamp(100 - pct, 0, 100)); }catch(e){}
}

}

function updateRetentionAlerts(){
  const list = $("retentionList");
  if(!list) return;

  const subs = getSubjectsOnly();
  if(subs.length === 0){
    list.innerHTML = '<div class="small">Add at least one subject in Settings to see retention alerts (projects are excluded).</div>';
    return;
  }

  // Last studied timestamp per subject
  const last = {};
  (Array.isArray(state.sessions) ? state.sessions : []).forEach(s=>{
    const sub = (s && s.subject) ? String(s.subject) : "";
    if(!sub) return;
    const ts = Number(s.startTs || s.ts || 0);
    if(!Number.isFinite(ts) || ts<=0) return;
    last[sub] = Math.max(last[sub] || 0, ts);
  });

  const nowTs = now();
  const rows = subs.map(sub=>{
    const ts = last[sub] || 0;
    const days = ts ? Math.floor((nowTs - ts) / (24*3600*1000)) : null;

    // Risk: proxy score (0–100). Never studied => 100.
    const risk = (days == null) ? 100 : clamp(days * 12, 0, 100);

    let tier = "Low";
    if(days == null || days >= 7) tier = "High";
    else if(days >= 3) tier = "Medium";

    let note = "Never logged";
    if(days != null){
      if(days <= 0) note = "Today";
      else if(days === 1) note = "1 day ago";
      else note = `${days} days ago`;
    }

    return { sub, risk, tier, note };
  }).sort((a,b)=> (b.risk - a.risk) || a.sub.localeCompare(b.sub));

  list.innerHTML = "";
  const shown = rows.slice(0, 6);
  shown.forEach(r=>{
    const row = document.createElement("div");
    row.className = "row";

    const left = document.createElement("div");
    const name = document.createElement("b");
    name.textContent = r.sub;
    const note = document.createElement("div");
    note.className = "small";
    note.textContent = r.note;
    left.appendChild(name);
    left.appendChild(note);

    const right = document.createElement("div");
    right.style.textAlign = "right";
    const tier = document.createElement("div");
    tier.className = "riskTier " + (r.tier==="Low" ? "riskTier--low" : (r.tier==="Medium" ? "riskTier--med" : "riskTier--high"));
    tier.textContent = r.tier;
    const score = document.createElement("div");
    score.className = "small";
    score.textContent = `${Math.round(r.risk)}/100`;
    right.appendChild(tier);
    right.appendChild(score);

    row.appendChild(left);
    row.appendChild(right);
    list.appendChild(row);
  });

  if(rows.length > shown.length){
    const more = document.createElement("div");
    more.className = "small";
    more.style.marginTop = "2px";
    more.style.opacity = ".75";
    more.textContent = `+${rows.length - shown.length} more`;
    list.appendChild(more);
  }
}


function updateRecommendation(){
  const banner = $("recBanner");
  const msg = $("recText");
  const sub = $("recSub");
  const confLine = $("recConf");

  // Setting: allow hiding the top banner from Settings → Pop-ups
  const allow = !(state.settings && state.settings.popups && state.settings.popups.recBanner === false);
  if(banner) banner.style.display = allow ? "" : "none";
  if(!allow) return;

  if(!msg || !sub) return;

  // If no subjects are set up, keep the original onboarding hint.
  const hasSubjects = getSubjectsOnly().length>0;
  if(!hasSubjects){
    msg.textContent = "Add at least one subject in Settings to unlock recommendations (projects are excluded).";
    sub.textContent = "Recommended based on readiness + your history.";
    if(confLine) confLine.textContent = "";
    if($("recDuration")) $("recDuration").textContent = "-- min";
    if($("recDurWhy")) $("recDurWhy").textContent = "—";
    if($("recMethod")) $("recMethod").textContent = "--";
    if($("recMethWhy")) $("recMethWhy").textContent = "—";
    if($("recSubject")) $("recSubject").textContent = "--";
    if($("recSubjWhy")) $("recSubjWhy").textContent = "—";
    return;
  }

  // Use the exact same engine as the Start Session popup.
  const plan = computeNextSessionPlan();

  // Top-line summary (kept concise)
  msg.textContent = `${plan.subject} • ${plan.minutes} min • ${plan.method}`;
  sub.textContent = "Recommended based on readiness + your history.";

  // Confidence (evidence-based)
  if(confLine){
    const n = Number(plan.similarN||0);
    const c = plan.confidence || "Low";
    confLine.textContent = n>0 ? `Confidence: ${c} (based on ${n} similar sessions).` : `Confidence: ${c} (insufficient similar sessions).`;
  }

  // Detailed rows (match Next session plan popup)
  if($("recDuration")) $("recDuration").textContent = `${plan.minutes} min`;
  if($("recDurWhy")) $("recDurWhy").textContent = plan.minutesWhy || "—";
  if($("recMethod")) $("recMethod").textContent = plan.method || "--";
  if($("recMethWhy")) $("recMethWhy").textContent = plan.methodWhy || "—";
  if($("recSubject")) $("recSubject").textContent = plan.subject || "--";
  if($("recSubjWhy")) $("recSubjWhy").textContent = plan.subjectWhy || "—";
}

function updateInsightBanner(){
  const wrap = $("insightBanner");
  const txt = $("insightText");
  const meta = $("insightMeta");
  if(!wrap || !txt) return;

  // Respect banner toggle: if user hides the overview banner, still allow insight banner (separate)
  // (We keep insight visible unless explicitly dismissed.)
  const hasData = Array.isArray(state.sessions) && state.sessions.length>0;

  const bucketHours = 1.5;
  const bucket = Math.floor(now()/(bucketHours*3600*1000));
  const dismissed = Number(localStorage.getItem("st_insight_dismiss_bucket")||"0");

  // If dismissed for this bucket, hide until the next bucket
  if(dismissed === bucket){
    wrap.style.display = "none";
    return;
  }

  const insights = computeInsightCandidates();
  if(!insights.length){
    wrap.style.display = hasData ? "none" : ""; // show onboarding only if no data
    txt.textContent = hasData ? "" : "Log a few sessions to unlock personalized coach insights.";
    if(meta) meta.textContent = "Updates more frequently as you build data.";
    return;
  }

  // Deterministic selection per bucket (changes every few hours)
  const pick = insights[Math.abs((bucket*2654435761) % insights.length)];
  wrap.style.display = "";
  txt.innerHTML = pick.html;
  if(meta) meta.textContent = pick.meta || "Updates more frequently as you build data.";
}

function computeInsightCandidates(){
  const out = [];

  const sess = (state.sessions||[]);
  if(!sess.length) return out;

  // Use full history for insights (don’t discard older data)
  const all = sess;
  const totalMin = all.reduce((a,s)=>a + Number(s.minutes||0), 0);

  const avgQ = (arr)=> arr.length ? (arr.reduce((a,s)=>a+Number(s.quality||0),0)/arr.length) : 0;

  // 1) Top method (avg quality, n≥5)
  const byM = {};
  all.forEach(s=>{
    const ms = sessionMethodsFrom(s);
    if(!ms.length) ms.push("Unspecified");
    ms.forEach(m=>{
      if(!byM[m]) byM[m]={sum:0,n:0};
      byM[m].sum += Number(s.quality||3);
      byM[m].n += 1;
    });
  });
  const methods = Object.entries(byM)
    .filter(([m,v])=>v.n>=5)
    .sort((a,b)=> (b[1].sum/b[1].n) - (a[1].sum/a[1].n));
  if(methods.length){
    const [m,v] = methods[0];
    out.push({
      html: `Top method by avg quality: <b>${escapeHtml(m)}</b> (${(v.sum/v.n).toFixed(1)}/5, n=${v.n}).`,
      meta: "Computed from your recent sessions (n≥5)."
    });
  }

  // 2) Best hour (avg quality, n≥5)
  const byH = Array.from({length:24}, ()=>({sum:0,n:0}));
  all.forEach(s=>{
    const h = new Date(Number(s.startTs||0)).getHours();
    byH[h].sum += Number(s.quality||3);
    byH[h].n += 1;
  });
  const bestH = byH
    .map((b,h)=>({h, q: b.n? b.sum/b.n : 0, n:b.n}))
    .filter(x=>x.n>=5)
    .sort((a,b)=>b.q-a.q)[0];
  if(bestH){
    out.push({
      html: `Best hour for quality: <b>${String(bestH.h).padStart(2,"0")}:00</b> (${bestH.q.toFixed(1)}/5, n=${bestH.n}).`,
      meta: "Hour-of-day average quality (n≥5)."
    });
  }

  // 3) Most common distraction
  const dist = {};
  all.forEach(s=>(s.distractions||[]).forEach(d=>{ dist[d]=(dist[d]||0)+1; }));
  const distTop = Object.entries(dist).sort((a,b)=>b[1]-a[1])[0];
  if(distTop){
    out.push({
      html: `Most common distraction: <b>${escapeHtml(distTop[0])}</b> (${distTop[1]}× in this range).`,
      meta: "From your logged distractions."
    });
  }

  // 4) Environment optimizer (avg quality diff, n≥5 each)
  const byE = {};
  all.forEach(s=>{
    const envs = Array.isArray(s.envs) && s.envs.length ? s.envs : (s.env ? [s.env] : []);
    if(!envs.length) envs.push("Unspecified");
    envs.forEach(e=>{
      if(!byE[e]) byE[e]={sum:0,n:0};
      byE[e].sum += Number(s.quality||3);
      byE[e].n += 1;
    });
  });
  const envs = Object.entries(byE).filter(([e,v])=>v.n>=5).sort((a,b)=>(b[1].sum/b[1].n)-(a[1].sum/a[1].n));
  if(envs.length>=2){
    const [best, vb] = envs[0];
    const [worst, vw] = envs[envs.length-1];
    const diff = (vb.sum/vb.n) - (vw.sum/vw.n);
    out.push({
      html: `Environment lift: <b>${escapeHtml(best)}</b> beats <b>${escapeHtml(worst)}</b> by ${diff.toFixed(1)} quality (n=${vb.n} vs n=${vw.n}).`,
      meta: "Avg quality by environment (n≥5)."
    });
  }

  // 5) Plan realism (planned vs actual)
  const planPairs = all.filter(s=>Number(s.plannedMin||0)>0 && Number(s.minutes||0)>0);
  if(planPairs.length>=6){
    const plannedAvg = planPairs.reduce((a,s)=>a+Number(s.plannedMin||0),0)/planPairs.length;
    const actualAvg = planPairs.reduce((a,s)=>a+Number(s.minutes||0),0)/planPairs.length;
    const ratio = plannedAvg>0 ? (actualAvg/plannedAvg) : 0;
    if(ratio && ratio<0.85){
      out.push({
        html: `Plan realism: your planned <b>${Math.round(plannedAvg)} min</b> becomes <b>${Math.round(actualAvg)} min</b> on average (n=${planPairs.length}). Consider planning shorter blocks.`,
        meta: "Planned vs actual session duration."
      });
    }else if(ratio && ratio>1.15){
      out.push({
        html: `Plan realism: you tend to go longer than planned (planned ${Math.round(plannedAvg)} → actual ${Math.round(actualAvg)} min, n=${planPairs.length}). You can safely schedule a bit more.`,
        meta: "Planned vs actual session duration."
      });
    }
  }

  // 6) Deep work rate (last 7 days)
  const c7 = now() - 7*24*3600*1000;
  const s7 = sess.filter(s=>Number(s.startTs||0) >= c7);
  const tot7 = s7.reduce((a,s)=>a+Number(s.minutes||0),0);
  const deep7 = s7.filter(s=>!!s.deep).reduce((a,s)=>a+Number(s.minutes||0),0);
  if(tot7>=60){
    const pct = (deep7/tot7)*100;
    out.push({
      html: `Deep work rate (last 7 days): <b>${Math.round(pct)}%</b> (${Math.round(deep7)} / ${Math.round(tot7)} min).`,
      meta: "Deep minutes ÷ total minutes."
    });
  }

  return out;
}

// Insight buttons (reappear later)
(function initInsightBanner(){
  const ok = $("insightOk");
  const no = $("insightNo");
  const wrap = $("insightBanner");
  const dismiss = ()=>{
    const bucketHours = 1.5;
    const bucket = Math.floor(now()/(bucketHours*3600*1000));
    localStorage.setItem("st_insight_dismiss_bucket", String(bucket));
    if(wrap){
      wrap.classList.add("fadeOut");
      setTimeout(()=>{ wrap.classList.remove("fadeOut"); wrap.style.display="none"; }, 180);
    }
  };
  ok?.addEventListener("click", dismiss);
  no?.addEventListener("click", dismiss);
})();

function escapeHtml(s){
  return String(s||"").replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[c]));
}

function sessionsByDateKey(dateKey){
  const start = new Date(dateKey + "T00:00:00").getTime();
  const end = start + 24*3600*1000;
  return (state.sessions||[]).filter(s=>Number(s.startTs||0) >= start && Number(s.startTs||0) < end);
}

function sumMinutes(sessions){
  return sessions.reduce((a,s)=>a + Number(s.minutes||0), 0);
}

function avgQuality(sessions){
  if(!sessions.length) return 0;
  return sessions.reduce((a,s)=>a + Number(s.quality||0), 0) / sessions.length;
}

function topBy(arr, keyFn){
  const map = new Map();
  for(const x of arr){
    const k = keyFn(x) || "";
    if(!k) continue;
    map.set(k, (map.get(k)||0) + 1);
  }
  let best = ["",0];
  for(const [k,v] of map.entries()){
    if(v>best[1]) best = [k,v];
  }
  return best[0];
}

function buildDailyCoachHtml(){
  // If no historical data yet, show a short explanation (day 1 friendly)
  const all = (state.sessions||[]);
  if(!all.length){
    return `<div class="box" style="margin-bottom:12px;">
      <h4>Daily coach</h4>
      <div class="small">Log a few sessions to unlock personalized coaching.</div>
    </div>
    <div class="box">
      <div class="small" style="line-height:1.6;">
        Start with 3–5 sessions. Then I’ll surface what improves quality (method, time, environment, distractions) using your own stats.
      </div>
    </div>`;
  }

  // Yesterday range
  const t = new Date();
  t.setHours(0,0,0,0);
  const todayStart = t.getTime();
  const yStart = todayStart - 24*3600*1000;
  const yEnd = todayStart;
  const ys = all.filter(s=>Number(s.startTs||0) >= yStart && Number(s.startTs||0) < yEnd);

  const yKey = new Date(yStart).toISOString().slice(0,10);

  const header = `<div class="box" style="margin-bottom:12px;">
    <h4>Daily coach</h4>
    <div class="small">What moved the needle yesterday (grounded in your data).</div>
  </div>`;

  if(!ys.length){
    return header + `<div class="box" style="margin-bottom:12px;">
      <div class="small" style="line-height:1.6;">
        No sessions were logged yesterday. Today’s best move: do one short, focused session to restart momentum.
      </div>
    </div>`;
  }

  // Baseline: last 7 days excluding yesterday
  const weekStart = todayStart - 7*24*3600*1000;
  const base = all.filter(s=>{
    const ts = Number(s.startTs||0);
    return ts >= weekStart && ts < yStart;
  });

  const avgQ = (arr)=> arr.length ? (arr.reduce((a,s)=>a+Number(s.quality||0),0)/arr.length) : 0;
  const yQ = avgQ(ys);
  const bQ = avgQ(base);
  const delta = (bQ>0) ? (yQ - bQ) : 0;

  // Windows for robust stats
  const cutoff30 = now() - 30*24*3600*1000;
  const hist = all.filter(s=>Number(s.startTs||0) >= cutoff30);
  const pool = hist.length ? hist : all;
  const overallQ = avgQ(pool);

  const candidates = [];

  // Candidate: Method mix vs your historical averages
  (function(){
    const used = {};
    ys.forEach(s=> sessionMethodsFrom(s).forEach(m=>{ used[m]=(used[m]||0)+1; }));
    const methodStats = {};
    pool.forEach(s=>{
      const ms = sessionMethodsFrom(s);
      if(!ms.length) ms.push("Unspecified");
      ms.forEach(m=>{
        if(!methodStats[m]) methodStats[m]={sum:0,n:0};
        methodStats[m].sum += Number(s.quality||3);
        methodStats[m].n += 1;
      });
    });

    const lines = Object.entries(used)
      .map(([m,ny])=>{
        const st = methodStats[m];
        if(!st || st.n<5) return null;
        const mq = st.sum/st.n;
        const eff = mq - overallQ;
        return {m, ny, mq, n:st.n, eff};
      })
      .filter(Boolean)
      .sort((a,b)=>Math.abs(b.eff)-Math.abs(a.eff));

    if(lines.length){
      const top = lines[0];
      const dir = top.eff>=0 ? "boosted" : "dragged down";
      candidates.push({
        score: Math.abs(top.eff),
        html: `Method effect: <b>${escapeHtml(top.m)}</b> ${dir} quality yesterday. Its historical avg is ${top.mq.toFixed(1)}/5 (n=${top.n}) vs your overall ${overallQ.toFixed(1)}/5.`
      });
    }
  })();

  // Candidate: Time-of-day (hours used yesterday vs your best hour)
  (function(){
    const byH = Array.from({length:24}, ()=>({sum:0,n:0}));
    pool.forEach(s=>{
      const h = new Date(Number(s.startTs||0)).getHours();
      byH[h].sum += Number(s.quality||3);
      byH[h].n += 1;
    });
    const best = byH.map((b,h)=>({h, q:b.n?b.sum/b.n:0, n:b.n}))
      .filter(x=>x.n>=5)
      .sort((a,b)=>b.q-a.q)[0];
    if(!best) return;

    const yHours = ys.map(s=>new Date(Number(s.startTs||0)).getHours());
    if(!yHours.length) return;

    const yModeHour = topBy(yHours.map(h=>({h})), x=>String(x.h));
    const hNum = Number(yModeHour);
    const b = byH[hNum];
    if(!b || b.n<3) return;
    const hAvg = b.sum/b.n;
    const eff = hAvg - overallQ;
    candidates.push({
      score: Math.abs(eff)*0.8,
      html: `Time effect: you mostly studied around <b>${String(hNum).padStart(2,"0")}:00</b>. That hour averages ${hAvg.toFixed(1)}/5 for you (n=${b.n}). Your best hour is <b>${String(best.h).padStart(2,"0")}:00</b> (${best.q.toFixed(1)}/5, n=${best.n}).`
    });
  })();

  // Candidate: Environment
  (function(){
    const envStats = {};
    pool.forEach(s=>{
      const envs = Array.isArray(s.envs)&&s.envs.length ? s.envs : (s.env ? [s.env] : []);
      if(!envs.length) envs.push("Unspecified");
      envs.forEach(e=>{
        if(!envStats[e]) envStats[e]={sum:0,n:0};
        envStats[e].sum += Number(s.quality||3);
        envStats[e].n += 1;
      });
    });
    const yEnv = {};
    ys.forEach(s=>{
      const envs = Array.isArray(s.envs)&&s.envs.length ? s.envs : (s.env ? [s.env] : []);
      if(!envs.length) envs.push("Unspecified");
      envs.forEach(e=>{ yEnv[e]=(yEnv[e]||0)+1; });
    });

    const lines = Object.entries(yEnv)
      .map(([e,ny])=>{
        const st = envStats[e];
        if(!st || st.n<5) return null;
        const eq = st.sum/st.n;
        const eff = eq - overallQ;
        return {e, ny, eq, n:st.n, eff};
      })
      .filter(Boolean)
      .sort((a,b)=>Math.abs(b.eff)-Math.abs(a.eff));

    if(lines.length){
      const top = lines[0];
      const dir = top.eff>=0 ? "helped" : "hurt";
      candidates.push({
        score: Math.abs(top.eff)*0.7,
        html: `Environment effect: <b>${escapeHtml(top.e)}</b> ${dir}. It averages ${top.eq.toFixed(1)}/5 for you (n=${top.n}) vs overall ${overallQ.toFixed(1)}/5.`
      });
    }
  })();

  // Candidate: Distractions (count + pattern)
  (function(){
    const yD = ys.flatMap(s=>Array.isArray(s.distractions)?s.distractions:[]);
    const bD = base.flatMap(s=>Array.isArray(s.distractions)?s.distractions:[]);
    const yRate = ys.length ? (yD.length/ys.length) : 0;
    const bRate = base.length ? (bD.length/base.length) : 0;
    const eff = (bRate>0) ? (yRate - bRate) : yRate;
    if(yD.length){
      const topD = topBy(yD.map(d=>({d})), x=>x.d);
      candidates.push({
        score: Math.abs(eff)*0.6,
        html: `Distraction load: <b>${yD.length}</b> distractions across ${ys.length} sessions (≈${yRate.toFixed(1)}/session). Top distraction: <b>${escapeHtml(topD||"—")}</b>.`
      });
    }
  })();

  // Candidate: Readiness
  (function(){
    const ry = readinessBaseFor(yKey);
    if(ry===null) return;
    const rb = [];
    for(let i=2;i<=7;i++){
      const d = new Date(todayStart - i*24*3600*1000);
      const k = d.toISOString().slice(0,10);
      const r = readinessBaseFor(k);
      if(r!==null) rb.push(r);
    }
    if(rb.length>=3){
      const rAvg = rb.reduce((a,x)=>a+x,0)/rb.length;
      const eff = (ry - rAvg)/100; // scale
      candidates.push({
        score: Math.abs(eff)*0.5,
        html: `Readiness context: yesterday’s readiness was <b>${ry}</b> vs your recent avg <b>${Math.round(rAvg)}</b> (n=${rb.length} days).`
      });
    }
  })();

  const moved = candidates
    .sort((a,b)=>b.score-a.score)
    .slice(0,4)
    .map(x=>x.html);

  const needleBox = `<div class="box" style="margin-bottom:12px;">
    <div style="font-weight:850; margin-bottom:8px;">What moved the needle yesterday</div>
    <ul class="small" style="margin:0; padding-left:18px; line-height:1.5;">
      ${moved.map(x=>`<li>${x}</li>`).join("")}
    </ul>
    <div class="small" style="margin-top:8px; opacity:.85;">Yesterday: ${yQ.toFixed(1)}/5 (${ys.length} sessions) • Prior 7D baseline: ${bQ ? bQ.toFixed(1) : "—"}/5 (${base.length} sessions) • Δ ${delta>=0?"+":""}${delta.toFixed(1)}</div>
  </div>`;

  // Light “today plan” based on readiness + strain (kept brief)
  const goals = getEffectiveGoals();
  const rToday = readinessBaseFor(todayKey());
  const strainToday = computeDailyStrain(todayKey());
  const plan = [];
  if(rToday!==null){
    if(rToday>=75) plan.push("Today is a high-readiness day → schedule your hardest block early.");
    else if(rToday>=55) plan.push("Moderate readiness → keep sessions shorter and tightly defined.");
    else plan.push("Low readiness → do low-friction tasks or deload volume to avoid burnout.");
  }
  if(strainToday > (goals.strainUpper||14)) plan.push("Strain is high → cap total study and add recovery before another deep session.");
  else if(strainToday < (goals.strainLower||10)) plan.push("Strain is low → one focused block will move the needle.");

  const planBox = plan.length ? `<div class="box" style="margin-bottom:12px;">
    <div style="font-weight:850; margin-bottom:8px;">Best move today</div>
    <ul class="small" style="margin:0; padding-left:18px; line-height:1.5;">
      ${plan.slice(0,3).map(x=>`<li>${x}</li>`).join("")}
    </ul>
  </div>` : "";

  return header + needleBox + planBox + `<div class="small" style="opacity:.9;">Tip: This coach only reports computed stats (it won’t invent facts).</div>`;
}

function buildWeeklyCoachHtml(){
  // Last complete week (Mon–Sun) report shown on the first check-in of a new week
  const nowD = new Date();
  const day = nowD.getDay(); // 0 Sun, 1 Mon...
  const daysSinceMon = (day + 6) % 7;
  const thisMon = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate() - daysSinceMon);
  thisMon.setHours(0,0,0,0);

  const lastMon = new Date(thisMon.getTime() - 7*24*3600*1000);
  const lastSunEnd = new Date(thisMon.getTime()); // exclusive

  const wkSessions = (state.sessions||[]).filter(s=>{
    const ts = Number(s.startTs||0);
    return ts >= lastMon.getTime() && ts < lastSunEnd.getTime();
  });

  const totalMin = sumMinutes(wkSessions);
  const q = avgQuality(wkSessions);
  const deepCount = wkSessions.filter(s=>s.deep).length;
  const topSubject = topBy(wkSessions, s=>s.subject);

  // Most used method: expand multi-method sessions (Option A)
  const methCounts = {};
  wkSessions.forEach(s=>{
    const ms = sessionMethodsFrom(s);
    if(!ms.length) ms.push("Unspecified");
    ms.forEach(m=>{ methCounts[m] = (methCounts[m]||0) + 1; });
  });
  const topMethod = Object.entries(methCounts).sort((a,b)=>b[1]-a[1])[0]?.[0] || null;

  const topEnv = topBy(wkSessions, s=>s.env);

  const goals = getEffectiveGoals();
  const target = goals.weeklyMin||0;
  const rate = target>0 ? (totalMin/target) : 0;

  const bullets = [];
  if(target>0){
    bullets.push(`Weekly minutes: <b>${Math.round(totalMin)}</b> / ${Math.round(target)} (${Math.round(rate*100)}%).`);
  }else{
    bullets.push(`Weekly minutes: <b>${Math.round(totalMin)}</b>.`);
  }
  if(q>0) bullets.push(`Average quality: <b>${q.toFixed(1)}/5</b>.`);
  bullets.push(`Deep sessions: <b>${deepCount}</b>.`);
  if(topSubject) bullets.push(`Most studied subject: <b>${escapeHtml(topSubject)}</b>.`);
  if(topMethod) bullets.push(`Most used method: <b>${escapeHtml(topMethod)}</b>.`);
  if(topEnv) bullets.push(`Most common environment: <b>${escapeHtml(topEnv)}</b>.`);

  const next = [];
  if(target>0 && totalMin < target) next.push("Pick two fixed ‘anchor’ sessions this week (same time, same place) to stabilize volume.");
  if(q>0 && q<3.8) next.push("Raise quality: simplify session goals and end with a short retrieval checkpoint.");
  if(deepCount<2) next.push("Add 1–2 deep sessions (45–90 min) with distraction control to accelerate progress.");
  next.push("Review Analytics to identify your best time-of-day and replicate it.");

  // Distraction autopsy (root cause + fix)
  const dist = {};
  wkSessions.forEach(s=>(s.distractions||[]).forEach(d=>{ dist[d]=(dist[d]||0)+1; }));
  const topD = Object.entries(dist).sort((a,b)=>b[1]-a[1])[0];
  let autopsy = "";
  if(topD){
    const d = topD[0], n = topD[1];
    const dSess = wkSessions.filter(s=>(s.distractions||[]).includes(d));
    const ended = dSess.filter(s=>!!s.endedEarly && Number(s.endEarlyMin||0)>0);
    const avgEnd = ended.length>=3 ? Math.round(ended.reduce((a,s)=>a+Number(s.endEarlyMin||0),0)/ended.length) : null;

    const fixMap = {
      "Phone": ["Put your phone in another room (physical distance)", "Enable Focus/Do Not Disturb + block notifications for 30 min"],
      "Social": ["Block the site/app for 30 min", "Replace urge with a 30s breathing reset + resume timer"],
      "Noise": ["Use noise-cancelling / white noise", "Choose a quieter environment for deep sessions"],
      "People": ["Tell others your stop time (clear boundary)", "Use a ‘do not disturb’ cue (headphones / sign)"],
      "Hunger": ["Quick snack + water before starting", "Plan sessions after meals for deep work"],
      "Tired": ["Shorter block (20–30 min) + break", "Switch to low-friction tasks when readiness is low"]
    };

    // Fallback mapping: try partial match
    const key = Object.keys(fixMap).find(k=> String(d).toLowerCase().includes(k.toLowerCase()));
    const fixes = fixMap[key] || ["Add friction to the distraction before you start (remove access)", "Set a single allowed break time (e.g., after 25 min) instead of micro-checks"];

    const pattern = avgEnd ? `Pattern: shows up in ended-early sessions, usually around <b>${avgEnd} min</b>.` : `Pattern: appears in <b>${dSess.length}</b> sessions this week.`;
    autopsy = `<div class="box" style="margin-bottom:12px;">
      <div style="font-weight:850; margin-bottom:8px;">Distraction autopsy</div>
      <div class="small" style="line-height:1.6;">
        Top distraction: <b>${escapeHtml(d)}</b> (${n}× this week). ${pattern}<br>
        Fix (2-step friction plan): 1) ${escapeHtml(fixes[0])}. 2) ${escapeHtml(fixes[1])}.
      </div>
    </div>`;
  }

  const header = `<div class="box" style="margin-bottom:12px;">
    <h4>Weekly coach</h4>
    <div class="small">Summary of last week (Mon–Sun) + what to adjust next.</div>
  </div>`;

  const body = `<div class="box" style="margin-bottom:12px;">
    <div style="font-weight:850; margin-bottom:8px;">Last week at a glance</div>
    <div class="small" style="line-height:1.55;">${bullets.map(b=>`• ${b}`).join("<br>")}</div>
  </div>`;

  const actions = `<div class="box" style="margin-bottom:12px;">
    <div style="font-weight:850; margin-bottom:8px;">Focus for this week</div>
    <ul class="small" style="margin:0; padding-left:18px; line-height:1.5;">
      ${next.slice(0,5).map(x=>`<li>${x}</li>`).join("")}
    </ul>
  </div>`;

  return header + body + actions + autopsy + `<div class="small" style="opacity:.9;">Weekly coach appears once per week after your first check-in.</div>`;
}

function maybeShowCoachAfterCheckin(){
  const allowCoachPopup = !(state.settings && state.settings.popups && state.settings.popups.coach === false);
  if(!allowCoachPopup) return;

  // Daily coach every check-in
  if($("coachTitle")) $("coachTitle").textContent = "Coach";
  if($("coachSubtitle")) $("coachSubtitle").textContent = "Personalized recommendations";

  const content = $("coachContent");
  if(content){
    let _html = "";
    try{ _html = buildDailyCoachHtml(); }catch(e){ _html = ""; }
    if(!_html || !String(_html).trim()){
      _html = `<div class="box"><b>Coach</b><div class="small">No specific recommendation yet — do a quick check-in and log any events (exam, commute, sports, etc.) so the coach can personalize.</div></div>`;
    }
    content.innerHTML = _html;
  }
  coachModal.open();

  // Weekly coach once per week (after first check-in in a new week)
  if(!state.ui) return;
  if(!("lastWeeklyCoachMon" in state.ui)) state.ui.lastWeeklyCoachMon = 0;

  const nowD = new Date();
  const day = nowD.getDay();
  const daysSinceMon = (day + 6) % 7;
  const thisMon = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate() - daysSinceMon);
  thisMon.setHours(0,0,0,0);

  if(state.ui.lastWeeklyCoachMon !== thisMon.getTime()){
    // Only show weekly coach after a FULL completed week of daily use (7/7 days).
    const lastMon = new Date(thisMon.getTime() - 7*24*3600*1000);
    const lastSunEnd = new Date(thisMon.getTime());

    const keyForDate = (d)=>{
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const da = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    };

    // Build activity set from sessions + check-ins
    const activity = new Set();
    (Array.isArray(state.sessions) ? state.sessions : []).forEach(s=>{
      const ts = Number(s && (s.startTs || s.ts) || 0);
      if(!Number.isFinite(ts) || ts<=0) return;
      activity.add(keyForDate(new Date(ts)));
    });
    if(state.dailyCheckins){
      Object.keys(state.dailyCheckins).forEach(k=>{
        const v = state.dailyCheckins[k];
        if(v && (v.morning || v.evening)) activity.add(k);
      });
    }

    const weekKeys = [];
    for(let i=0;i<7;i++){
      const d = new Date(lastMon.getTime() + i*24*3600*1000);
      d.setHours(0,0,0,0);
      weekKeys.push(keyForDate(d));
    }

    const fullWeekDailyUse = weekKeys.every(k=>activity.has(k));

    if(fullWeekDailyUse){
      // Show weekly coach AFTER daily coach closes.
      const once = ()=>{
        const b = coachModal.back();
        if(b) b.removeEventListener("click", onBack, true);
        if($("coachTitle")) $("coachTitle").textContent = "Coach";
        if($("coachSubtitle")) $("coachSubtitle").textContent = "Weekly summary";
        if(content){
          let _w = "";
          try{ _w = buildWeeklyCoachHtml(); }catch(e){ _w = ""; }
          if(!_w || !String(_w).trim()){
            _w = `<div class="box"><b>Weekly coach</b><div class="small">No weekly insights yet — keep logging sessions and check-ins daily to unlock trends.</div></div>`;
          }
          content.innerHTML = _w;
        }
        coachModal.open();
      };
      const onBack = (e)=>{ /* ignore */ };

      const origClose = coachModal.close.bind(coachModal);
      coachModal.close = ()=>{
        origClose();
        coachModal.close = origClose;
        state.ui.lastWeeklyCoachMon = thisMon.getTime();
        saveState();
        setTimeout(once, 140);
      };
    }
    // If not a full week of daily use, do nothing — do NOT mark lastWeeklyCoachMon.
  }}

function drawSparkline(canvasId, points){
  const c = $(canvasId);
  if(!c) return;
  const ctx = c.getContext("2d");
  const w = c.clientWidth, h = c.clientHeight;
  const dpr = window.devicePixelRatio||1;
  c.width = Math.floor(w*dpr); c.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,w,h);

  if(points.length<2) return;
  const min = Math.min(...points), max = Math.max(...points);
  const rng = (max-min)||1;
  const pad = 6;
  const xstep = (w-2*pad)/(points.length-1);

  ctx.beginPath();
  points.forEach((p,i)=>{
    const x = pad + i*xstep;
    const y = h - pad - ((p-min)/rng)*(h-2*pad);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(234,240,255,.70)";
  ctx.stroke();
}

function updateOverviewCharts(){
  // Focus momentum sparkline from last 14 sessions (focus rating)
  const last = state.sessions.slice(-14).map(s=>effectiveFocus(s));
  drawSparkline("focusSpark", last.length? last : [3,3]);
}


function updateEmptyStates(){
  // Compatibility / safety: earlier versions referenced this in updateAll.
  // Keep it lightweight; actual visibility rules are handled elsewhere.
  const hasSessions = Array.isArray(state.sessions) && state.sessions.length>0;
  const hasCheckin = !!(state.dailyCheckins && state.dailyCheckins[todayKey()]);
  // Optional empty-state hints (elements may not exist in every layout)
  const ovHint = $("overviewEmptyHint");
  if(ovHint){
    ovHint.textContent = (!hasSessions && !hasCheckin)
      ? "Start with a Daily check-in or log a session to populate your dashboard."
      : (!hasSessions ? "Log a session to populate today’s metrics." : "Dashboard updated.");
  }
}

function updateAll(){
  // Robust step runner: missing functions won't break the whole dashboard.
  const stepNames = [
    "updateEmptyStates",
    "applyOverviewVisibility",
    "updateMiniHeader",
    "updateReadinessUI",
    "updateOverviewPrimaryMetrics",
    "updateOverviewTargets",
    "updateRetentionAlerts",
    "updateRecommendation",
    "updateInsightBanner",
    "updateStartPage",
    "updateOverviewCharts",
    "updateGoalsSnapshot",
    "updateGoalsAdherence",
    "updateAnalyticsSummary"
  ];
  stepNames.forEach(name=>{
    const fn = window[name];
    if(typeof fn !== "function") return;
    try{ fn(); }catch(err){ console.warn("[updateAll]", name, err); }
  });
}


/**********************
 * Goals snapshot (right panel)
 **********************/
function updateGoalsSnapshot(){
  const snap = $("weeklyText");
  if(!snap) return;

  const weekStart = startOfWeek(now());
  const weekEnd = weekStart + 7*24*3600*1000;
  const mins = minutesInRange(weekStart, weekEnd);
  const target = Number(getEffectiveGoals().weeklyMin||0);
  const pct = target>0 ? Math.round((mins/target)*100) : 0;

  snap.textContent = `${Math.round(mins)} min this week (${pct}% of target)`;
}

/**********************
 * Analytics summary (existing weekly summary card)
 **********************/
function updateAnalyticsSummary(){
  const end = now();
  const start = end - 7*24*3600*1000;
  const sess = sessionsInRange(start,end);
  const total = sess.reduce((a,s)=>a+Number(s.minutes||0),0);
  const avgLen = sess.length ? (total/sess.length) : 0;
  const longest = sess.length ? Math.max(...sess.map(s=>Number(s.minutes||0))) : 0;

  if($("anTotalTime")) $("anTotalTime").textContent = `${Math.round(total)} min`;
  if($("anAvgLen")) $("anAvgLen").textContent = `${Math.round(avgLen)} min`;
  if($("anLongest")) $("anLongest").textContent = `${Math.round(longest)} min`;

  const avgQ = sess.length ? (sess.reduce((a,s)=>a+Number(s.quality||3),0)/sess.length) : 0;
  const avgFocus = sess.length ? (sess.reduce((a,s)=>a+Number(s.focus||3),0)/sess.length) : 0;

  if($("anAvgQuality")) $("anAvgQuality").textContent = sess.length ? avgQ.toFixed(1) : "--";
  if($("anAvgFocus")) $("anAvgFocus").textContent = sess.length ? avgFocus.toFixed(1) : "--";

  const avgDistr = sess.length ? (sess.reduce((a,s)=>a+(s.distractions?.length||0),0)/sess.length) : 0;
  if($("anAvgDistr")) $("anAvgDistr").textContent = sess.length ? avgDistr.toFixed(1) : "--";

  

// Deltas vs previous 7 days (green/red indicators)
const prevStart = start - 7*24*3600*1000;
const prevSess = sessionsInRange(prevStart, start);

const pAvgQ = prevSess.length ? (prevSess.reduce((a,s)=>a+Number(s.quality||3),0)/prevSess.length) : null;
const pAvgFocus = prevSess.length ? (prevSess.reduce((a,s)=>a+Number(s.focus||3),0)/prevSess.length) : null;
const pAvgDistr = prevSess.length ? (prevSess.reduce((a,s)=>a+(s.distractions?.length||0),0)/prevSess.length) : null;

function setDelta(elId, delta, betterHigher=true){
  const el = $(elId);
  if(!el){
    return;
  }
  el.classList.remove("up","down","neutral");
  if(delta===null || !isFinite(delta) || Math.abs(delta) < 0.05){
    el.textContent = "—";
    el.classList.add("neutral");
    return;
  }
  const up = delta > 0;
  const arrow = up ? "▲" : "▼";
  el.textContent = `${arrow} ${Math.abs(delta).toFixed(1)}`;
  const improved = betterHigher ? up : !up; // for distractions, lower is better
  el.classList.add(improved ? "up" : "down");
}

if(sess.length && prevSess.length){
  setDelta("anAvgQualityDelta", avgQ - pAvgQ, true);
  setDelta("anAvgFocusDelta", avgFocus - pAvgFocus, true);
  setDelta("anAvgDistrDelta", avgDistr - pAvgDistr, false);
}else{
  setDelta("anAvgQualityDelta", null, true);
  setDelta("anAvgFocusDelta", null, true);
  setDelta("anAvgDistrDelta", null, false);
}
// Peak hour
  const hourBuckets = Array.from({length:24}, ()=>({sum:0,n:0}));
  sess.forEach(s=>{
    const h = new Date(s.startTs).getHours();
    hourBuckets[h].sum += Number(s.quality||3);
    hourBuckets[h].n += 1;
  });
  let bestH = null, bestV = -1, bestN=0;
  hourBuckets.forEach((b,h)=>{
    if(b.n>=2){
      const v = b.sum/b.n;
      if(v>bestV){ bestV=v; bestH=h; bestN=b.n; }
    }
  });
  if($("anPeakHour")) $("anPeakHour").textContent = (bestH===null) ? "--" : `${String(bestH).padStart(2,"0")}:00`;
  if($("anPeakConf")) $("anPeakConf").textContent = (bestH===null) ? "--" : `${bestV.toFixed(1)} avg`;
  if($("anPeakN")) $("anPeakN").textContent = (bestH===null) ? "--" : `${bestN} sessions`;
}

/**********************
 * Analytics graphs
 **********************/
function getRangeWindow(kind){
  const end = now();
  if(kind==="month") return {start: end - 30*24*3600*1000, end};
  if(kind==="year") return {start: end - 365*24*3600*1000, end};
  return {start: end - 7*24*3600*1000, end};
}

function prepCanvas(canvas){
  const ctx = canvas.getContext("2d");
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const dpr = window.devicePixelRatio||1;
  canvas.width = Math.floor(w*dpr);
  canvas.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,w,h);
  return {ctx,w,h};
}

function axes(ctx, w, h, pad){
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(pad, pad);
  ctx.lineTo(pad, h-pad);
  ctx.lineTo(w-pad, h-pad);
  ctx.stroke();
}

function axisLabels(ctx, w, h, pad, xLabel, yLabel, opts={}){
  // Make axis titles visually distinct from tick labels (readability).
  const color = opts.color || "rgba(255,255,255,.84)";
  const font = opts.font || "900 12px system-ui";
  const xY = (typeof opts.xY === "number") ? opts.xY : (h - 6);
  const yX = (typeof opts.yX === "number") ? opts.yX : 14;

  ctx.save();
  ctx.fillStyle = color;
  ctx.font = font;

  // X label (centered)
  if(xLabel){
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    ctx.fillText(String(xLabel), w/2, xY);
  }

  // Y label (centered, rotated)
  if(yLabel){
    ctx.save();
    ctx.translate(yX, h/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    ctx.fillText(String(yLabel), 0, 0);
    ctx.restore();
  }

  ctx.restore();
}


function drawScatter(canvasId, points){
  const canvas = $(canvasId);
  if(!canvas) return;
  const {ctx,w,h} = prepCanvas(canvas);
  const pad = 40;
  axes(ctx,w,h,pad);

  if(!points || !points.length){
    ctx.fillStyle = "rgba(255,255,255,.75)";
    ctx.font = "12px system-ui";
    ctx.fillText("No sessions in range", pad, h/2);
    return;
  }

  const xmax = Math.max(10, ...points.map(p=>p.x));
  const ymin = 1, ymax = 5;

  // Grid + ticks
  ctx.font = "10px system-ui";
  ctx.fillStyle = "rgba(255,255,255,.56)";
  // X ticks
  for(let i=0;i<=4;i++){
    const v = Math.round((xmax*i)/4);
    const x = pad + (i/4)*(w-2*pad);
    ctx.fillText(String(v), x-6, h-pad+14);
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, h-pad); ctx.stroke();
  }
  // Y ticks (1..5)
  for(let v=1; v<=5; v++){
    const y = (h-pad) - ((v-ymin)/(ymax-ymin))*(h-2*pad);
    ctx.textAlign="right"; ctx.fillText(String(v), pad-10, y+4); ctx.textAlign="left";
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
  }

  // Axis labels
  axisLabels(ctx,w,h,pad,"Session duration (min)","Quality (1–5)");

// Points
  points.forEach(p=>{
    const x = pad + (p.x/xmax)*(w-2*pad);
    const y = (h-pad) - ((p.y-ymin)/(ymax-ymin))*(h-2*pad);
    ctx.fillStyle = "rgba(124,92,255,.75)";
    ctx.beginPath();
    ctx.arc(x,y,3.3,0,Math.PI*2);
    ctx.fill();
  });
}

function drawBars(canvasId, labels, values){
  const canvas = $(canvasId);
  if(!canvas) return;
  const {ctx,w,h} = prepCanvas(canvas);
  const pad = 40;
  axes(ctx,w,h,pad);

  if(!labels || !labels.length){
    ctx.fillStyle = "rgba(255,255,255,.75)";
    ctx.font = "12px system-ui";
    ctx.fillText("Start a session to see data", pad, h/2);
    return;
  }

  // Quality is on a 1–5 scale; keep the axis stable for readability
  const vmax = 5;
  ctx.font = "10px system-ui";
  ctx.fillStyle = "rgba(255,255,255,.56)";

  // Y ticks
  for(let v=1; v<=5; v++){
    const y = (h-pad) - (v/vmax)*(h-2*pad);
    ctx.textAlign="right"; ctx.fillText(String(v), pad-10, y+4); ctx.textAlign="left";
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
  }

  // Axis labels
  axisLabels(ctx,w,h,pad,"Method","Avg quality (1–5)");

const barW = (w-2*pad)/labels.length * 0.62;
  labels.forEach((lab,i)=>{
    const v = values[i] || 0;
    const x = pad + i*((w-2*pad)/labels.length) + ( ((w-2*pad)/labels.length) - barW)/2;
    const bh = (v/vmax)*(h-2*pad);
    const y = (h-pad) - bh;

    ctx.fillStyle = "rgba(38,213,198,.62)";
    ctx.fillRect(x, y, barW, bh);

    // x label (truncate)
    ctx.fillStyle = "rgba(255,255,255,.78)";
    ctx.font = "11px system-ui";
    const t = String(lab).length>10 ? String(lab).slice(0,10)+"…" : String(lab);
    ctx.fillText(t, x, h-pad+14);

    // value label
    ctx.fillStyle = "rgba(255,255,255,.70)";
    ctx.font = "10px system-ui";
    ctx.fillText(v.toFixed(1), x, y-6);
  });
}

function drawHeatmap(canvasId, hourVals){
  const c=$(canvasId); if(!c) return;
  const {ctx,w,h}=prepCanvas(c);
  const pad=18;
  const cols = 24, rows = 1;
  const cellW = (w-2*pad)/cols;
  const cellH = (h-2*pad)/6; // make blocks larger; leave space for label grid

  // draw 24 blocks
  for(let i=0;i<cols;i++){
    const q = hourVals[i]; // null or 1..5
    const x = pad + i*cellW;
    const y = pad + (h-2*pad)/2 - cellH/2;
    const t = (q===null) ? 0 : (q-1)/4; // 0..1
    // color by readiness-like hue (red->green)
    const hue = 0 + t*120;
    const alpha = q===null ? 0.08 : 0.30 + t*0.35;
    ctx.fillStyle = `hsla(${hue},92%,58%,${alpha})`;
    ctx.fillRect(x, y, cellW-2, cellH);
  }

  ctx.fillStyle="rgba(234,240,255,.55)";
  ctx.font="10px system-ui";
  for(let i=0;i<24;i+=3){
    const x = pad + i*cellW;
    ctx.fillText(String(i).padStart(2,"0"), x+2, h-pad-6);
  }
}

function drawPareto(canvasId, data){
  const canvas = $(canvasId);
  if(!canvas) return;
  const {ctx,w,h} = prepCanvas(canvas);
  const pad = 40;
  axes(ctx,w,h,pad);

  if(!data || !data.length){
    ctx.fillStyle = "rgba(255,255,255,.75)";
    ctx.font = "12px system-ui";
    ctx.fillText("No distraction data", pad, h/2);
    return;
  }

  // Sort by frequency desc; keep top 10 for readability
  const items = [...data].sort((a,b)=>b.value-a.value).slice(0,10);
  const labels = items.map(d=>d.label);
  const values = items.map(d=>d.value);
  const vmax = Math.max(1, ...values);

  // Y ticks
  ctx.fillStyle = "rgba(255,255,255,.56)";
  ctx.font = "10px system-ui";
  for(let i=0;i<=4;i++){
    const v = Math.round((vmax*i)/4);
    const y = (h-pad) - (i/4)*(h-2*pad);
    ctx.textAlign="right"; ctx.fillText(String(v), pad-10, y+4); ctx.textAlign="left";
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
  }
  // Labels
  axisLabels(ctx,w,h,pad,null,"Count",{color:"rgba(255,255,255,.68)"});

const barW = (w-2*pad)/labels.length * 0.62;

  labels.forEach((lab, i)=>{
    const v = values[i];
    const x = pad + i*((w-2*pad)/labels.length) + ( ((w-2*pad)/labels.length) - barW)/2;
    const bh = (v/vmax)*(h-2*pad);
    const y = (h-pad) - bh;

    const a = 0.18 + 0.60*(v/vmax); // saturation/alpha by frequency
    ctx.fillStyle = `rgba(255,176,32,${a.toFixed(3)})`;
    ctx.fillRect(x, y, barW, bh);

    // x labels (truncate)
    ctx.fillStyle = "rgba(255,255,255,.78)";
    ctx.font = "11px system-ui";
    const t = String(lab).length>10 ? String(lab).slice(0,10)+"…" : String(lab);
    ctx.fillText(t, x, h-pad+14);
  });
}

function drawAnalytics(){
  const rangeSel = $("analyticsRange");
  const kind = rangeSel ? rangeSel.value : "week";
  const {start,end} = getRangeWindow(kind);
  const sess = sessionsInRange(start,end);

  // 1) scatter: minutes vs quality
  const scatterPts = sess.map(s=>({x:Number(s.minutes||0), y:Number(s.quality||3)}));
  drawScatter("gScatter", scatterPts);

  // 2) bars by method (Option A: a session can count in multiple methods)
  const byM = {};
  sess.forEach(s=>{
    const ms = sessionMethodsFrom(s);
    if(!ms.length) ms.push("Unspecified");
    ms.forEach(m=>{
      if(!byM[m]) byM[m] = {sum:0, n:0};
      byM[m].sum += Number(s.quality||3);
      byM[m].n += 1;
    });
  });

  const mEntries = Object.entries(byM).sort((a,b)=>b[1].n - a[1].n).slice(0,12);
  const mLabels = mEntries.map(([k,v])=>`${k} (n=${v.n})`);
  const mValues = mEntries.map(([k,v])=>v.n ? (v.sum/v.n) : 0);
  drawBars("gMethod", mLabels, mValues);

  // 3) heatmap: hour × avg quality
  const heat = Array.from({length:24},()=>({sum:0,n:0}));
  sess.forEach(s=>{
    const h = new Date(s.startTs).getHours();
    heat[h].sum += Number(s.quality||3);
    heat[h].n += 1;
  });
  const heatVals = heat.map(d=> d.n? d.sum/d.n : 0);
  drawHeatmap("gHeat", heatVals);

  // 4) deep work rate over time: deep minutes ÷ total minutes
  const deepSeries = [];
  const ms = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

  if(kind === "year"){
    const startD = new Date(start.getFullYear(), start.getMonth(), 1);
    const endD = new Date(end.getFullYear(), end.getMonth(), 1);
    // ensure 12 points by month within the window
    let d = new Date(startD);
    d.setDate(1);
    while(d < endD){
      const y = d.getFullYear(), m = d.getMonth();
      const a = new Date(y, m, 1).getTime();
      const b = new Date(y, m+1, 1).getTime();
      const inM = sess.filter(s=> Number(s.startTs||0) >= a && Number(s.startTs||0) < b);
      const tot = inM.reduce((x,s)=>x+Number(s.minutes||0),0);
      const deep = inM.filter(s=>!!s.deep).reduce((x,s)=>x+Number(s.minutes||0),0);
      deepSeries.push({label: ms[m], y: tot>0 ? (deep/tot)*100 : null});
      d = new Date(y, m+1, 1);
    }
  } else {
    // Daily points
    let d = new Date(start);
    d.setHours(0,0,0,0);
    const endT = new Date(end);
    endT.setHours(0,0,0,0);
    while(d < endT){
      const a = d.getTime();
      const b = a + 24*3600*1000;
      const inD = sess.filter(s=> Number(s.startTs||0) >= a && Number(s.startTs||0) < b);
      const tot = inD.reduce((x,s)=>x+Number(s.minutes||0),0);
      const deep = inD.filter(s=>!!s.deep).reduce((x,s)=>x+Number(s.minutes||0),0);
      deepSeries.push({label: `${ms[d.getMonth()]} ${d.getDate()}`, y: tot>0 ? (deep/tot)*100 : null});
      d = new Date(b);
    }
  }
  drawDeepRate("gDeepRate", deepSeries);

  // 5) Distraction Pareto (counts)
  const dist = {};
  sess.forEach(s=> (s.distractions||[]).forEach(d=>{ dist[d]=(dist[d]||0)+1; }));
  const items = Object.entries(dist).map(([k,v])=>({label:k, value:v}))
    .sort((a,b)=>b.value-a.value)
    .slice(0,10);
  drawPareto("gPareto", items);

  // 6) readiness vs quality (use base readiness on the session day)
  const pts = sess.map(s=>{
    const date = new Date(s.startTs).toISOString().slice(0,10);
    const base = readinessBaseFor(date);
    const x = base===null ? clamp(Math.round(((state.baselines.energy + state.baselines.focus)/2)*20),0,100) : base;
    return {x, y:Number(s.quality||3)};
  });
  drawReadyOutcome("gReadyOutcome", pts);
}


function drawReadyOutcome(canvasId, points){
  const canvas = $(canvasId);
  if(!canvas) return;
  const {ctx,w,h} = prepCanvas(canvas);
  const pad = 40;
  axes(ctx,w,h,pad);

  if(!points || !points.length){
    ctx.fillStyle = "rgba(255,255,255,.75)";
    ctx.font = "12px system-ui";
    ctx.fillText("No sessions with readiness data", pad, h/2);
    return;
  }

  const xmin = 0, xmax = 100;
  const ymin = 1, ymax = 5;

  ctx.font = "10px system-ui";
  ctx.fillStyle = "rgba(255,255,255,.56)";

  // X ticks (0–100)
  [0,25,50,75,100].forEach(v=>{
    const x = pad + (v/xmax)*(w-2*pad);
    ctx.fillText(String(v), x-6, h-pad+14);
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, h-pad); ctx.stroke();
  });

  // Y ticks (1–5)
  for(let v=1; v<=5; v++){
    const y = (h-pad) - ((v-ymin)/(ymax-ymin))*(h-2*pad);
    ctx.textAlign="right"; ctx.fillText(String(v), pad-10, y+4); ctx.textAlign="left";
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
  }

  // Labels
  axisLabels(ctx,w,h,pad,"Readiness (0–100)","Session quality (1–5)");

// Points
  points.forEach(p=>{
    const x = pad + (Math.max(xmin, Math.min(xmax, p.x))/xmax)*(w-2*pad);
    const y = (h-pad) - ((p.y-ymin)/(ymax-ymin))*(h-2*pad);
    ctx.fillStyle = "rgba(124,92,255,.72)";
    ctx.beginPath(); ctx.arc(x,y,3.2,0,Math.PI*2); ctx.fill();
  });
}


function drawDeepRate(canvasId, series){
  const canvas = $(canvasId);
  if(!canvas) return;
  const {ctx,w,h} = prepCanvas(canvas);
  const pad = 40;
  axes(ctx,w,h,pad);

  if(!series || !series.length){
    ctx.fillStyle = "rgba(255,255,255,.75)";
    ctx.font = "12px system-ui";
    ctx.fillText("No sessions in range", pad, h/2);
    return;
  }

  const pts = series.filter(p=>p.y!==null && !isNaN(p.y));
  if(!pts.length){
    ctx.fillStyle = "rgba(255,255,255,.75)";
    ctx.font = "12px system-ui";
    ctx.fillText("No deep work data", pad, h/2);
    return;
  }

  const ymin = 0, ymax = 100;

  // Y ticks
  ctx.font = "10px system-ui";
  ctx.fillStyle = "rgba(255,255,255,.56)";
  [0,25,50,75,100].forEach(v=>{
    const y = (h-pad) - (v/100)*(h-2*pad);
    ctx.textAlign="right"; ctx.fillText(v+"%", pad-10, y+4); ctx.textAlign="left";
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
  });

  // Axis labels
  axisLabels(ctx,w,h,pad,"Date","Deep work rate (%)");

// X spacing (uniform)
  const n = series.length;
  const xAt = (i)=> pad + (i/(Math.max(1,n-1)))*(w-2*pad);
  const yAt = (v)=> (h-pad) - ((v-ymin)/(ymax-ymin))*(h-2*pad);

  // Line
  ctx.strokeStyle = "rgba(38,213,198,.70)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  series.forEach((p,i)=>{
    if(p.y===null || isNaN(p.y)) return;
    const x = xAt(i);
    const y = yAt(p.y);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  });
  ctx.stroke();

  // Points
  series.forEach((p,i)=>{
    if(p.y===null || isNaN(p.y)) return;
    const x = xAt(i);
    const y = yAt(p.y);
    ctx.fillStyle = "rgba(38,213,198,.80)";
    ctx.beginPath(); ctx.arc(x,y,3.0,0,Math.PI*2); ctx.fill();
  });

  // X labels (sparse)
  ctx.fillStyle = "rgba(255,255,255,.75)";
  ctx.font = "10px system-ui";
  const labelEvery = n<=7 ? 1 : (n<=14 ? 2 : (n<=30 ? 5 : 10));
  series.forEach((p,i)=>{
    if(i%labelEvery!==0 && i!==n-1) return;
    const x = xAt(i);
    const t = String(p.label||"");
    if(!t) return;
    ctx.fillText(t, x-8, h-pad+14);
  });
}

function initAnalytics(){
  const sel = $("analyticsRange");
  if(sel) sel.addEventListener("change", drawAnalytics);
}

/**********************
 * Tooltips
 **********************/

function initTimerViewMenus(){
  // Timer view is fixed (digital) — removes the ring behind the clock.
  try{
    const v = "digital";
    const visual = $("timerVisual");
    const full = $("fullOverlay");
    if(visual){
      visual.classList.remove("timerVisual--digital","timerVisual--bar","timerVisual--ring");
      visual.classList.add("timerVisual--"+v);
    }
    if(full){
      full.classList.remove("timerVisual--digital","timerVisual--bar","timerVisual--ring");
      full.classList.add("timerVisual--"+v);
    }
  }catch(e){}
}


function initTooltips(){
  const tip = $("tip");
  if(!tip) return;

  const place = (x,y)=>{
    const pad = 14;
    const rect = tip.getBoundingClientRect();
    let left = x + 12;
    let top  = y + 12;
    if(left + rect.width + pad > window.innerWidth) left = window.innerWidth - rect.width - pad;
    if(top + rect.height + pad > window.innerHeight) top = y - rect.height - 12;
    tip.style.left = `${Math.max(pad,left)}px`;
    tip.style.top  = `${Math.max(pad,top)}px`;
  };

  const show = (text, x, y)=>{
    const t = (text||"").trim();
    if(!t){ hide(); return; }
    tip.textContent = t;
    tip.style.display = "block";
    tip.style.visibility = "visible";
    tip.setAttribute("aria-hidden","false");
    place(x,y);
    tip.classList.add("show");
  };

  const hide = ()=>{
    tip.classList.remove("show");
    tip.setAttribute("aria-hidden","true");
    tip.style.visibility = "hidden";
  };

  const handler = (e)=>{
    const el = e.target?.closest?.(".info[data-tip]");
    if(!el) return;
    show(el.getAttribute("data-tip")||"", e.clientX, e.clientY);
  };

  document.addEventListener("mousemove", handler);
  document.addEventListener("mouseover", handler);

  document.addEventListener("mouseout", (e)=>{
    const leaving = e.target?.closest?.(".info[data-tip]");
    const entering = e.relatedTarget?.closest?.(".info[data-tip]");
    if(leaving && !entering) hide();
  });

  window.addEventListener("scroll", hide, {passive:true});
}



/**********************
 * Micro-animations helpers
 **********************/
function pulseValue(el){
  if(!el) return;
  el.classList.remove("value-pulse");
  void el.offsetWidth;
  el.classList.add("value-pulse");
}

function animateNumber(el, to, duration=650, suffix="", pulse=true){
  if(!el) return;
  const fromTxt = (el.textContent||"").replace(/[^\d.-]/g,"");
  const from = Number(fromTxt);
  const target = Number(to);
  if(!Number.isFinite(target)){
    el.textContent = String(to);
    if(pulse) pulseValue(el);
    return;
  }
  const a0 = Number.isFinite(from) ? from : target;
  const start = performance.now();
  function step(t){
    const p = clamp((t-start)/duration,0,1);
    const e = 1-Math.pow(1-p,3);
    const v = a0 + (target-a0)*e;
    el.textContent = `${Math.round(v)}${suffix}`;
    if(p<1) requestAnimationFrame(step);
    else if(pulse) pulseValue(el);
  }
  requestAnimationFrame(step);
}


function animateBar(el, pct){
  if(!el) return;
  const to = `${clamp(pct,0,1)*100}%`;
  el.dataset.targetW = to;

  // Respect reduced-motion
  try{
    if(window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches){
      el.style.transition = "none";
      el.style.width = to;
      return;
    }
  }catch(e){}

  el.style.transition = "width 420ms cubic-bezier(.2,.9,.2,1)";
  el.style.width = to;
}

function nudgeBars(container){
  if(!container) return;
  try{
    if(window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
  }catch(e){}

  const bars = Array.from(container.querySelectorAll(".barFill"));
  bars.forEach(el=>{
    const targetStr = el.dataset.targetW || el.style.width || "0%";
    const target = clamp(parseFloat(targetStr)||0, 0, 100);

    // Current computed width (% of parent). This avoids visual "jump" on tab switches.
    let from = target;
    try{
      const cw = parseFloat(getComputedStyle(el).width || "0");
      const pw = Math.max(1, parseFloat(getComputedStyle(el.parentElement).width || "1"));
      from = clamp((cw/pw)*100, 0, 100);
    }catch(e){}

    // If already essentially at target, skip (prevents jitter).
    if(Math.abs(from - target) < 0.2) return;

    el.style.setProperty("--from", from.toFixed(3) + "%");
    el.style.setProperty("--to", target.toFixed(3) + "%");
    el.classList.remove("bar-anim"); // reset
    void el.offsetWidth; // reflow to re-trigger animation
    el.classList.add("bar-anim");
    el.style.width = target.toFixed(1) + "%";

    const cleanup = ()=>{
      el.classList.remove("bar-anim");
      el.removeEventListener("animationend", cleanup);
    };
    el.addEventListener("animationend", cleanup);
  });
}

function nudgeOverviewBars(){
  const page = document.getElementById("page-overview");
  nudgeBars(page);
}



function isoDayKey(){
  return new Date().toISOString().slice(0,10);
}
function celebrateOnce(key){
  try{
    const k = `st_celeb_${key}_${isoDayKey()}`;
    if(localStorage.getItem(k)) return false;
    localStorage.setItem(k,"1");
    return true;
  }catch(e){ return true; }
}
function confettiBurst(card, count=18){
  if(!card) return;
  const colors = ["var(--accent)","var(--accent2)","var(--good)","var(--warn)","rgba(234,240,255,.85)"];
  for(let i=0;i<count;i++){
    const p = document.createElement("i");
    p.className = "confettiPiece";
    const ang = Math.random()*Math.PI*2;
    const dist = 70 + Math.random()*95;
    const dx = Math.cos(ang)*dist;
    const dy = Math.sin(ang)*dist + 34; // bias downward a touch
    p.style.setProperty("--dx", `${dx.toFixed(1)}px`);
    p.style.setProperty("--dy", `${dy.toFixed(1)}px`);
    p.style.setProperty("--rot", `${Math.round((Math.random()*540-270))}deg`);
    p.style.left = `${35 + Math.random()*30}%`;
    p.style.top = `${38 + Math.random()*18}%`;
    p.style.background = colors[(Math.random()*colors.length)|0];
    card.appendChild(p);
    setTimeout(()=>{ try{ p.remove(); }catch(e){} }, 980);
  }
}
function celebrateGoal(card, msg){
  confettiBurst(card, 18);
  try{ showToast("Nice—goal met", msg || "Daily target achieved.", 3200); }catch(e){}
}


let coachT = null;
function hideCoach(){
  const box = $("coachToast");
  if(!box) return;
  box.classList.remove("show");
  box.setAttribute("aria-hidden","true");
}

function computeBreakRecommendation(session){
  const mins = Math.max(0, Number(session?.minutes||0));
  const effort = clamp(Number(session?.effort||3), 1, 5);
  const focus = clamp(Number(session?.focus||3), 1, 5);
  const frustration = clamp(Number(session?.frustration||3), 1, 5);
  const distractions = Array.isArray(session?.distractions) ? session.distractions : [];

  // Baseline break length (rules of thumb aligned with common study guidance)
  // ~25–50m work -> 5–10m break; ~50–90m -> ~10–15m; 90m+ -> 15–30m
  let base = 5;
  if(mins < 15) base = 2;
  else if(mins < 25) base = 3;
  else if(mins < 50) base = 6;
  else if(mins < 90) base = 10;
  else if(mins < 120) base = 15;
  else base = 20;

  // Adjust for intensity / emotional load
  const intensity = (effort + frustration) / 2; // 1..5
  if(intensity >= 4.4) base += 4;
  else if(intensity >= 3.8) base += 2;
  else if(intensity <= 2.0 && mins < 60) base -= 1;

  const breakMin = clamp(Math.round(base), 2, 30);

  // Activity suggestion (short + long forms)
  let activityShort = "Water + stand up + 20–20–20 (eyes).";
  let activityLong = "Drink water, stand up, and do the 20–20–20 rule: look 20 feet away for 20 seconds.";

  if(frustration >= 4){
    activityShort = "Reset: slow breathing + short walk.";
    activityLong = "Reset your nervous system: 60–90 seconds of slow breathing, then a short walk. When you return, write one clear next step before resuming.";
  }else if(distractions.length >= 3){
    activityShort = "Environment reset: tidy + phone out of reach.";
    activityLong = "Do a quick environment reset: clear the desk, silence notifications, put your phone out of reach, then re-open only what you need for the next block.";
  }else if(focus <= 2){
    activityShort = "Fresh air + movement (avoid scrolling).";
    activityLong = "Get fresh air and move for a few minutes. Avoid social media; you want recovery, not a second attention drain.";
  }else if(effort >= 4){
    activityShort = "Walk + light snack (if needed).";
    activityLong = "Take a short walk and, if you’re hungry, a light snack. This is a good recovery break after high effort work.";
  }

  return {
    breakMin,
    activityShort,
    activityLong,
    label: `${breakMin} min break`
  };
}

function showCoachBreak(session, opts = {}){
  // Top-left coach toast: used for break recommendations after logging.
  // Returns true if shown.
  if(!(state.settings?.popups?.coach ?? true)) return false;

  const toast = $("coachToast");
  if(!toast) return false;

  const force = !!opts.force;
  const durationMs = Number.isFinite(Number(opts.durationMs)) ? Number(opts.durationMs) : 11000;

  // Throttle unless forced (avoid spam)
  if(!force){
    try{
      const bucket = Math.floor(now() / (3*60*60*1000));
      const k = "st_coach_bucket";
      const last = Number(localStorage.getItem(k) || -1);
      if(last === bucket) return false;
      localStorage.setItem(k, String(bucket));
    }catch(e){}
  }

  const rec = computeBreakRecommendation(session);
  const mins = Math.round(Number(session?.minutes||0));
  const q = Number(session?.quality || session?.baseQuality || 0);

  const titleEl = toast.querySelector(".coachTitle") || $("coachToastTitle");
  const bodyEl = toast.querySelector(".coachBody") || $("coachMsg");

  const title = String(opts.title || "Break recommendation");
  if(titleEl) titleEl.textContent = title;

  // Minimal body when the toast is meant to be very brief (e.g., 0.5s)
  if(bodyEl){
    // Keep this extremely brief: break duration + one action cue.
    const top = `${rec.breakMin} min break`;
    const mid = rec.activityShort || rec.activityLong || "Stand up, water, eyes off screen.";
    bodyEl.innerHTML = `
      <div style="font-weight:950; color: rgba(234,240,255,.92); margin-bottom:6px;">${top}</div>
      <div style="color: rgba(234,240,255,.86); font-weight:800; line-height:1.2;">${mid}</div>
    `;
  }

  toast.classList.add("show");
  clearTimeout(showCoachBreak._t);
  showCoachBreak._t = setTimeout(()=>toast.classList.remove("show"), durationMs);
  return true;
}


/**********************
 * Toast + "Random" after save
 **********************/
let toastT = null;
function showToast(title, msg, ms=2600){
  const t = $("toast");
  if(!t) return;
  $("toastTitle").textContent = title || "";
  $("toastMsg").textContent = msg || "";
  t.classList.add("show");
  t.setAttribute("aria-hidden","false");
  if(toastT) clearTimeout(toastT);
  toastT = setTimeout(()=>{
    t.classList.remove("show");
    t.setAttribute("aria-hidden","true");
  }, ms);
}

let rewardPillT = null;
function getDailyGoalMinutes(){
  // Prefer the Settings / Baselines input if present; fallback to adaptive baseline.
  const v = Number(($("baseTargetDailyMin")?.value||"").trim());
  const safe = (Number.isFinite(v) && v>0) ? clamp(v,0,600) : Number(state.baselines?.dailyMin||120);
  return clamp(safe, 0, 600);
}
function todayMinutesTotal(){
  const d0 = startOfDay(now());
  const d1 = d0 + 24*3600*1000;
  return minutesInRange(d0,d1);
}
function showRewardPill(line1, line2="Streak preserved ✅", ms=3400){
  const pill = $("rewardPill");
  if(!pill) return;
  $("rewardLine1").textContent = String(line1||"");
  $("rewardLine2").textContent = String(line2||"");
  pill.classList.add("show");
  pill.setAttribute("aria-hidden","false");
  // Click anywhere to dismiss
  if(!pill.__wired){
    pill.__wired = true;
    pill.addEventListener("click", ()=>{
      pill.classList.remove("show");
      pill.setAttribute("aria-hidden","true");
    });
  }
  if(rewardPillT) clearTimeout(rewardPillT);
  rewardPillT = setTimeout(()=>{
    pill.classList.remove("show");
    pill.setAttribute("aria-hidden","true");
  }, ms);
}

function nextRewardPillCopy(session){
  // Cycles through different reward pill copy each time a session is logged.
  const key = "sp_reward_variant_idx";
  let idx = 0;
  try{
    idx = Number(localStorage.getItem(key) || "0");
    if(!Number.isFinite(idx)) idx = 0;
  }catch(e){}

  const m = Math.max(0, Math.round(Number(session?.minutes||0)));
  const goal = getDailyGoalMinutes();
  const done = todayMinutesTotal();
  const pct = goal > 0 ? Math.round((done/goal)*100) : 0;
  const left = clamp(Math.round(goal - done), 0, 9999);

  const rec = computeBreakRecommendation(session);
  const safe = (s)=>String(s||"").replace(/\s+/g," ").trim();
  let act = safe(rec.activityShort || rec.activityLong || "reset");
  if(act.length > 46) act = act.slice(0, 46).trimEnd() + "…";

  const variants = [
    ()=>({ l1: `+${m} min toward today’s goal`, l2: `Progress: ${pct}%` }),
    ()=>({ l1: `Session logged: ${m} min`, l2: `Break: ${rec.breakMin} min — ${act}` }),
    ()=>({ l1: `Momentum +${m} min`, l2: `Keep it clean ✨` }),
    ()=>({ l1: `Goal left: ${left} min`, l2: `Break: ${rec.breakMin} min — ${act}` }),
    ()=>({ l1: `Deep work banked ✅`, l2: `+${m} min logged` }),
    ()=>({ l1: `Streak protected ✅`, l2: `Next: ${rec.breakMin} min break` }),
  ];

  const out = variants[idx % variants.length]();
  idx = (idx + 1) % variants.length;
  try{ localStorage.setItem(key, String(idx)); }catch(e){}
  return out;
}



function computeFinishStruggle(windowN=10){
  // Uses the last N countdown sessions to estimate "finish consistency"
  const list = (state.sessions||[]).filter(s=>{
    const mode = String(s.mode||"countdown");
    const planned = Number(s.plannedMin||0);
    return (mode==="countdown") && (planned>=5) && !s.usedStopClock;
  }).slice(-windowN);

  const n = list.length;
  if(n < 5) return { n, score: 0, band: "low", finishRate: 1, avgCompletion: 1, suggestMin: 20 };

  const compl = list.map(s=> clamp(Number(s.completionPct ?? 0), 0, 1));
  const finished = list.map(s=> (!s.endedEarly) || (Number(s.completionPct||0) >= 0.95));
  const earlyQuit = list.map(s=> (s.endedEarly && (Number(s.completionPct||0) < 0.70)));

  const finishRate = finished.filter(Boolean).length / n;
  const avgCompletion = compl.reduce((a,b)=>a+b,0) / n;
  const earlyQuitRate = earlyQuit.filter(Boolean).length / n;

  // Curated score (0 good -> 100 struggling)
  // - Not finishing is the biggest signal
  // - Low completion compresses the score even if not flagged "endedEarly"
  // - Early quits (<70%) are weighted as a strong friction indicator
  const score = clamp(
    (1 - finishRate) * 55 +
    (1 - avgCompletion) * 25 +
    (earlyQuitRate) * 20
  , 0, 100);

  // Suggest a shorter session length based on their typical planned time
  const avgPlanned = list.reduce((a,s)=>a+clamp(Number(s.plannedMin||25), 5, 600),0)/n;
  const suggestMin = clamp(Math.round((avgPlanned*0.60)/5)*5, 10, 30);

  const band = (score >= 65) ? "high" : (score >= 40 ? "med" : "low");
  return { n, score, band, finishRate, avgCompletion, earlyQuitRate, suggestMin };
}

function updateFinishCoach(){
  // Toast-only coach (extreme cases only).
  // Goal: avoid a permanent box and avoid spamming the user.
  if(state.active) return;

  const m = computeFinishStruggle(10);

  // "Extreme" gate: enough data + very high struggle score.
  if(m.n < 7) return;
  if(m.score < 80) return;

  // Don't overlap other top-left toasts (e.g., break recommendation).
  const t = $("toast");
  if(t && t.classList.contains("show")) return;

  if(!state.ui) state.ui = {};
  const nowTs = Date.now();
  const last = Number(state.ui.finishCoachToastAt || 0);

  // Cooldown: show at most once every 8 hours.
  if(nowTs - last < 8*60*60*1000) return;

  state.ui.finishCoachToastAt = nowTs;
  saveState();

  const suggest = m.suggestMin;
  showToast("Finish coach", `${suggest} min blocks • 1 task • phone away`, 3400);
}


function markCommitTouched(){
  if(!state.ui) state.ui = {};
  state.ui.commitTouched = true;
}

function computeStartAssist(windowN=12){
  const list = (state.sessions||[]).slice(-windowN);
  const n = list.length;
  if(n < 4) return { key:"", score:0 };

  const avgNum = (k, defV)=> {
    const vals = list.map(s=> Number(s?.[k]));
    const ok = vals.filter(v=>Number.isFinite(v));
    if(!ok.length) return defV;
    return ok.reduce((a,b)=>a+b,0) / ok.length;
  };

  const avgFocus = avgNum("focus", 3);
  const avgFrustration = avgNum("frustration", 2);
  const avgRetrieval = avgNum("retrieval", 3);
  const avgDistractions = (()=>{
    const vals = list.map(s=>(s?.distractions||[]).length);
    return vals.reduce((a,b)=>a+b,0) / Math.max(1, vals.length);
  })();

  const deepRate = (()=>{
    const vals = list.map(s=>!!s?.deep);
    return vals.filter(Boolean).length / Math.max(1, vals.length);
  })();

  const endEarlyRate = (()=>{
    const vals = list.map(s=>!!s?.endedEarly);
    return vals.filter(Boolean).length / Math.max(1, vals.length);
  })();

  const finish = computeFinishStruggle(10);

  // Candidate struggle scores (0 good -> 100 struggling)
  const cands = [
    {
      key:"focus",
      score: clamp(((3.6 - avgFocus) / 2.6) * 100, 0, 100),
      meta:{avgFocus}
    },
    {
      key:"distractions",
      score: clamp(((avgDistractions - 1.0) / 2.0) * 100, 0, 100),
      meta:{avgDistractions}
    },
    {
      key:"frustration",
      score: clamp(((avgFrustration - 2.4) / 2.6) * 100, 0, 100),
      meta:{avgFrustration}
    },
    {
      key:"consistency",
      score: clamp(Number(finish?.score||0), 0, 100),
      meta:{finish}
    },
    {
      key:"deepwork",
      score: clamp(((0.28 - deepRate) / 0.28) * 100, 0, 100),
      meta:{deepRate}
    },
    {
      key:"retrieval",
      score: clamp(((3.2 - avgRetrieval) / 2.2) * 100, 0, 100),
      meta:{avgRetrieval}
    }
  ];

  cands.sort((a,b)=>b.score-a.score);
  return { ...cands[0], n };
}

function updateCommitBonus(){
  const el = $("commitBonusPill");
  if(!el) return;

  const touched = !!(state.ui && state.ui.commitTouched);
  const minutes = Number($("sessMinutes")?.value || 0);
  const rawMeth = String($("sessMethod")?.value || "").trim();
  const selectedMethods = rawMeth ? rawMeth.split(",").map(s=>s.trim()).filter(Boolean) : [];
  const hasConfig = (Number.isFinite(minutes) && minutes>0) && (selectedMethods.length>0);

  if(state.active || !touched || !hasConfig){
    el.style.display = "none";
    return;
  }

  const assist = computeStartAssist(12);
  if(!assist || !assist.key || Number(assist.score||0) < 35){
    el.style.display = "none";
    return;
  }

  const actions = [];
  const setStrict = (on=true)=>{
    const t = $("strictToggle");
    if(t){
      t.checked = !!on;
      t.dispatchEvent(new Event("change", {bubbles:true}));
    }else{
      state.settings = state.settings || {};
      state.settings.strict = !!on;
      saveState();
    }
  };
  const setMinutes = (m)=>{
    const inp = $("sessMinutes");
    if(inp){
      inp.value = String(m);
      inp.dispatchEvent(new Event("input", {bubbles:true}));
      inp.dispatchEvent(new Event("change", {bubbles:true}));
    }
  };
  const goFullscreen = ()=>{
    const b = $("btnFullscreen");
    if(b) b.click();
  };

  let headline = "Quick assist";
  let sub = "Based on your recent sessions.";

  if(assist.key === "focus"){
    const af = Math.round((assist.meta?.avgFocus||0) * 10) / 10;
    headline = `🎁 Commit bonus: +10 Focus points if you finish`;
    sub = `Your focus ratings have been lower lately (avg ${af}/5). Try Strict mode + Fullscreen for one clean block.`;
    actions.push({id:"strict", label:(state.settings?.strict ? "Strict ON" : "Enable Strict"), primary: !state.settings?.strict});
    actions.push({id:"full", label:"Fullscreen"});
  }else if(assist.key === "distractions"){
    const ad = Math.round((assist.meta?.avgDistractions||0) * 10) / 10;
    headline = `📵 Distraction guard`;
    sub = `You’ve had more interruptions lately (avg ${ad}/session). Enable Strict mode and keep this block “single-task”.`;
    actions.push({id:"strict", label:(state.settings?.strict ? "Strict ON" : "Enable Strict"), primary: !state.settings?.strict});
    actions.push({id:"full", label:"Fullscreen"});
  }else if(assist.key === "consistency"){
    const sug = assist.meta?.finish?.suggestMin || 20;
    headline = `⏱ Consistency assist`;
    sub = `You’ve ended sessions early more often recently. Try a shorter block to rebuild completion momentum.`;
    actions.push({id:"mins", label:`Set ${sug} min`, primary:true, val:sug});
  }else if(assist.key === "deepwork"){
    const dr = Math.round((assist.meta?.deepRate||0)*100);
    headline = `🧠 Deep work boost`;
    sub = `Deep-work blocks have been rare lately (${dr}% of recent sessions). Consider one 45+ min block with ≤1 distraction.`;
    actions.push({id:"mins", label:"Set 45 min", primary:true, val:45});
    actions.push({id:"full", label:"Fullscreen"});
  }else if(assist.key === "frustration"){
    const fr = Math.round((assist.meta?.avgFrustration||0)*10)/10;
    headline = `🧊 Frustration reset`;
    sub = `Frustration has been higher lately (avg ${fr}/5). Try a shorter timer + start with 5 min retrieval before notes.`;
    actions.push({id:"mins", label:"Set 20 min", primary:true, val:20});
  }else if(assist.key === "retrieval"){
    headline = `🧠 Retrieval first`;
    sub = `Your retrieval ratings look lower lately. Consider starting with 5–10 min active recall before switching methods.`;
  }

  const btnHtml = actions.length
    ? `<div class="cbBtns">${actions.map(a=>`<button type="button" class="cbBtn ${a.primary?'primary':''}" data-cb="${a.id}" data-val="${a.val ?? ''}">${a.label}</button>`).join("")}</div>`
    : "";

  el.innerHTML = `<div class="cbRow"><div class="cbText">${headline}<span class="cbSub">${sub}</span></div>${btnHtml}</div>`;
  el.style.display = "block";

  if(!el.__wired){
    el.__wired = true;
    el.addEventListener("click", (e)=>{
      const b = e.target && e.target.closest && e.target.closest("[data-cb]");
      if(!b) return;
      const k = b.getAttribute("data-cb");
      const v = Number(b.getAttribute("data-val"));
      if(k==="strict") setStrict(true);
      if(k==="full") goFullscreen();
      if(k==="mins" && Number.isFinite(v) && v>0) setMinutes(v);
      try{ markCommitTouched(); }catch(e){}
      try{ updateCommitBonus(); }catch(e){}
    });
  }
}


let tourDoneT = null;
function showTourDoneToast(){
  const box = $("tourDoneToast");
  if(!box){ try{ showToast("Tour complete", "You’re set. Explore the tabs and start logging sessions.", 3800); }catch(e){}; return; }
  $("tourDoneTitle").textContent = "Tour complete";
  $("tourDoneMsg").textContent = "You’re set. Explore the tabs and start logging sessions.";
  $("tourDoneMeta").textContent = "Tip: Do a quick daily check-in to calibrate readiness.";
  box.classList.add("show");
  box.setAttribute("aria-hidden","false");
  if(tourDoneT) clearTimeout(tourDoneT);
  tourDoneT = setTimeout(()=>{ try{ hideTourDoneToast(); }catch(e){} }, 12000);
}
function hideTourDoneToast(){
  const box = $("tourDoneToast");
  if(!box) return;
  box.classList.remove("show");
  box.setAttribute("aria-hidden","true");
}
(function initTourDoneToast(){
  const d = $("tourDoneDismissBtn");
  const s = $("tourDoneStartBtn");
  if(d) d.addEventListener("click", ()=>{ hideTourDoneToast(); });
  if(s) s.addEventListener("click", ()=>{
    hideTourDoneToast();
    try{ document.querySelector('.tabbtn[data-tab="start"]').click(); }catch(e){}
  });
})();


const RANDOM_AFTER_SAVE = [
  "Tiny consistency beats big intensity. Log, review, repeat.",
  "Two minutes of retrieval at the end of a session compounds fast.",
  "If you were distracted, shorten the block next time—not your standards.",
  "High readiness day? Do the hardest subtopic first.",
  "Low readiness day? Win with structure: shorter blocks + clear checkpoints."
];

/**********************
 * Distraction-aware focus (used for trends)
 **********************/
function effectiveFocus(s){
  const raw = Number(s.focus||3);
  const dCount = (s.distractions||[]).length;
  const strict = !!state.settings.strict;
  const pen = dCount * (strict ? 0.50 : 0.25);
  return clamp(Math.round(raw - pen), 1, 5);
}

/**********************
 * Fullscreen timer overlay
 **********************/
const fullTimer = {
  el: ()=>$("fullOverlay"),
  open(){
    const o=this.el(); if(!o) return;
    o.classList.add("show");
    o.setAttribute("aria-hidden","false");
    syncFullTimerUI();
  },
  close(){
    const o=this.el(); if(!o) return;
    o.classList.remove("show");
    o.setAttribute("aria-hidden","true");
  }
};

function syncFullTimerUI(){
  const subj = state.active?.subject || $("sessSubject")?.value || "--";
  if($("fullSubject")) $("fullSubject").textContent = subj || "--";
  if($("fullTime")) $("fullTime").textContent = ($("timerDisplay")?.textContent||"00:00");
  try{ updateTimerViewVisuals(getDisplaySeconds()); }catch(e){}
  // mirror button labels/states
  const ss = $("btnStartStop");
  if($("fullStartStop") && ss) $("fullStartStop").textContent = ss.textContent || "Start";
  if($("fullReset") && $("btnResetTimer")) $("fullReset").disabled = $("btnResetTimer").disabled;
  if($("fullFinish") && $("btnStopAndLog")) $("fullFinish").disabled = $("btnStopAndLog").disabled;
}

/**********************
 * Goals adherence
 **********************/
function setGoalsSavedStatus(isSaved){
  const dot = $("goalsStatusDot");
  const txt = $("goalsStatusText");
  if(dot){ dot.classList.toggle("saved", !!isSaved); }
  if(txt){ txt.textContent = isSaved ? "Saved" : "Not saved"; }
}

function updateGoalsAdherence(){
  const weekStart = startOfWeek(now());
  const weekEnd = weekStart + 7*24*3600*1000;
  const sess = sessionsInRange(weekStart, weekEnd);

  const g = getEffectiveGoals();

  const mins = sess.reduce((a,s)=>a+Number(s.minutes||0),0);
  const pctMin = g.weeklyMin>0 ? clamp(mins/g.weeklyMin,0,1) : 0;

  // Average session length
  const avgLen = sess.length ? (mins / sess.length) : 0;
  const pctAvgLen = g.avgLenTarget>0 ? clamp((avgLen/g.avgLenTarget),0,1) : 0;

  // Start window adherence: % sessions starting inside preferred window
  const within = sess.filter(s=>inWindow(s.startTs, g.startFrom, g.startTo)).length;
  const startPct = sess.length ? (within/sess.length) : 0;
  const pctStart = clamp(startPct,0,1);

  // Low-distraction adherence: % sessions with ≤2 distractions
  const lowCount = sess.filter(s=>{
    const dis = Array.isArray(s.distractions) ? s.distractions : [];
    return dis.length <= 2;
  }).length;
  const lowPct = sess.length ? (lowCount/sess.length) : 0;
  const pctLow = (g.lowDistrPctTarget>0) ? clamp(lowPct/(g.lowDistrPctTarget/100),0,1) : 0;

  // Average quality vs target
  const qvals = sess.map(s=>Number(s.quality||s.baseQuality||0)).filter(v=>v>0);
  const avgQ = qvals.length ? (qvals.reduce((a,v)=>a+v,0)/qvals.length) : 0;
  const pctQ = (g.qualityTarget>0) ? clamp(avgQ/g.qualityTarget,0,1) : 0;

  if($("adhWeeklyMinText")) $("adhWeeklyMinText").textContent = `${Math.round(mins)} / ${Math.round(g.weeklyMin||0)} min`;
  if($("adhWeeklyMinBar")) animateBar($("adhWeeklyMinBar"), pctMin);

  if($("adhAvgLenText")) $("adhAvgLenText").textContent = sess.length ? `${avgLen.toFixed(0)} / ${Number(g.avgLenTarget||0)} min` : `-- / ${Number(g.avgLenTarget||0)} min`;
  if($("adhAvgLenBar")) animateBar($("adhAvgLenBar"), pctAvgLen);

  if($("adhStartWindowText")) $("adhStartWindowText").textContent = `${Math.round(startPct*100)}% sessions`;
  if($("adhStartWindowBar")) animateBar($("adhStartWindowBar"), pctStart);

  if($("adhLowDistrText")) $("adhLowDistrText").textContent = `${Math.round(lowPct*100)}% / ${Math.round(Number(g.lowDistrPctTarget||0))}%`;
  if($("adhLowDistrBar")) animateBar($("adhLowDistrBar"), pctLow);

  if($("adhQualityText")) $("adhQualityText").textContent = avgQ ? `${avgQ.toFixed(1)} / ${Number(g.qualityTarget||0)}` : `-- / ${Number(g.qualityTarget||0)}`;
  if($("adhQualityBar")) animateBar($("adhQualityBar"), pctQ);
}

/**********************
 * Misc helpers
 **********************/
function hint(text){
  const el = $("timerHint");
  if(el) el.textContent = text;
  else alert(text);
}

/**********************
 * Wire remaining buttons
 **********************/
function initMisc(){
  const go = $("btnGoStart");
  if(go) go.addEventListener("click", ()=>{
    // activate Start tab
    const btn = document.querySelector('.tabbtn[data-tab="start"]');
    btn?.click();
  });
}

/**********************
 * Boot
 **********************/

/**********************
 * Guided Tour (one-time, new users)
 **********************/
function maybeStartTourAfterOnboarding(){
  try{
    if(!state.ui) return;
    if(state.ui.tourDone){
      if(state.ui.pendingTour){ state.ui.pendingTour = false; saveState(); }
      return;
    }
    if(!state.ui.pendingTour) return;

    // Avoid starting while modals are open (daily check-in, end modal, onboarding)
    const openModal = $("modalCheckinBack")?.classList.contains("show")
      || $("modalCoachBack")?.classList.contains("show")
      || $("endModalBack")?.classList.contains("show")
      || $("modalOnboardBack")?.classList.contains("show");
    if(openModal) return;

    // Ensure we are on Overview before starting the tour
    document.querySelector('.tabbtn[data-tab="overview"]')?.click();

    // Wait a tick for layout to settle, then start
    setTimeout(()=>{ try{ startTour(); }catch(e){} }, 220);
  }catch(e){}
}

function startTour(){
  const overlay = $("tourOverlay");
  const hole = $("tourHole");
  const card = $("tourCard");
  const stepTxt = $("tourStepText");
  const title = $("tourTitle");
  const body = $("tourBody");
  const nextBtn = $("tourNextBtn");
  const skipBtn = $("tourSkipBtn");

  if(!overlay || !hole || !card || !title || !body || !nextBtn) return;

  // Remove skip button (per PDF)
  if(skipBtn){ skipBtn.style.display = "none"; skipBtn.setAttribute("aria-hidden","true"); }

  const steps = [
    { sel: "#cardReadiness", t: "Cognitive readiness", b: "This ring is your day’s capacity. It comes from the daily check-in and decreases as strain accumulates." },
    { sel: "#subStrain", t: "Cognitive strain", b: "Strain increases with duration and difficulty. It resets each day. Use it to pace yourself across the week." },
    { sel: "#cardReadiness .info", t: "Info tooltips", b: "Tap the “i” icons for definitions and how each metric is calculated." },
    { sel: '.tabbtn[data-tab="start"]', t: "Start Session tab", b: "Click the Start Session tab to continue. We’ll then show you how to start/stop a session.", action:"requireClick" },
    { sel: "#btnStartStop", t: "Start / stop", b: "Press Start to begin. When you end a session, you’ll log quick ratings, distractions, and environment.", ensureTab:"start" },
    { sel: '.tabbtn[data-tab="analytics"]', t: "Analytics tab", b: "Click Analytics to view trends and patterns.", action:"requireClick" },
    { sel: "#gScatter", t: "Trends", b: "Your analytics update as you log sessions. Use them to find your best time-of-day, methods, and environments.", ensureTab:"analytics" },
    { sel: '.tabbtn[data-tab="settings"]', t: "Settings", b: "Click Settings to set baselines, strict mode, subjects, and goals.", action:"requireClick" },
    { sel: "#cardExplicitGoals", t: "Explicit goals", b: "Set weekly minutes, daily strain, and per-subject targets. These goals drive pacing and recommendations.", ensureTab:"settings", openAcc:"#cardExplicitGoals" },
];

  let i = 0;
  let cleanup = null;

  const setCleanup = (fn)=>{
    try{ if(cleanup) cleanup(); }catch(e){}
    cleanup = fn || null;
  };

  const open = ()=>{
    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden","false");
    render();
    window.addEventListener("resize", render);
    window.addEventListener("scroll", render, true);
  };

  const close = (completed=true)=>{
    overlay.classList.remove("show");
    overlay.setAttribute("aria-hidden","true");
    window.removeEventListener("resize", render);
    window.removeEventListener("scroll", render, true);
    setCleanup(null);

    if(completed){
      if(!state.ui) state.ui = { lastOpenDate: todayKey(), lastCheckinPromptDate: "", onboarded: true, lastCheckinAt: 0, lastCheckinPromptAt: 0, tourDone: false, pendingTour: false };
      state.ui.tourDone = true;
      state.ui.pendingTour = false;
      saveState();
      try{ showTourDoneToast(); }catch(e){}
    }
  };

  const placeCardNear = (rect)=>{
    const pad = 10;
    const cw = card.getBoundingClientRect().width || 360;

    let left = rect.left - 10;
    let top = rect.bottom + 14;

    if(top + 180 > window.innerHeight) top = rect.top - 14 - 180;
    top = clamp(top, 10, window.innerHeight - 200);

    if(left + cw > window.innerWidth - 10) left = window.innerWidth - cw - 10;
    left = clamp(left, 10, window.innerWidth - cw - 10);

    card.style.left = `${left}px`;
    card.style.top = `${top}px`;
  };

  const render = ()=>{
    const step = steps[i];

    // Ensure correct tab is visible when required
    if(step.ensureTab){
      try{ document.querySelector(`.tabbtn[data-tab="${step.ensureTab}"]`)?.click(); }catch(e){}
    }

    // Optionally open a settings accordion card
    if(step.openAcc){
      try{
        const c = document.querySelector(step.openAcc);
        if(c) c.classList.remove("collapsed");
      }catch(e){}
    }


    const el = document.querySelector(step.sel);
    if(!el){
      // Skip missing elements gracefully
      if(i < steps.length-1){ i++; render(); }
      return;
    }

    try{ el.scrollIntoView({behavior:"smooth", block:"center"}); }catch(e){}

    const r = el.getBoundingClientRect();
    const pad = 10;
    const x = clamp(r.left - pad, 8, window.innerWidth - 8);
    const y = clamp(r.top - pad, 8, window.innerHeight - 8);
    const w = clamp(r.width + pad*2, 40, window.innerWidth - 16);
    const h = clamp(r.height + pad*2, 40, window.innerHeight - 16);

    hole.style.left = `${x}px`;
    hole.style.top = `${y}px`;
    hole.style.width = `${w}px`;
    hole.style.height = `${h}px`;

    stepTxt.textContent = `Step ${i+1} of ${steps.length}`;
    title.textContent = step.t;
    body.textContent = step.b;

    placeCardNear(r);

    // Default next button
    nextBtn.disabled = false;
    nextBtn.textContent = (i === steps.length-1) ? "Finish" : "Next";
    nextBtn.onclick = ()=>{ if(i < steps.length-1){ i++; render(); } else { close(true); } };

    // Steps requiring user click
    setCleanup(null);
    if(step.action === "requireClick"){
      nextBtn.disabled = true;
      nextBtn.textContent = "Click to continue";
      const handler = ()=>{
        setCleanup(null);
        setTimeout(()=>{ i = clamp(i+1, 0, steps.length-1); render(); }, 120);
      };
      el.addEventListener("click", handler, { once:true });
      setCleanup(()=>{ try{ el.removeEventListener("click", handler); }catch(e){} });
    }
  };

  // Allow closing by clicking outside the tour card
  overlay.onclick = (e)=>{
    const inside = card.contains(e.target);
    if(!inside) close(true);
  };

  open();
}


/**********************
 * Overlays: Next session plan + quick end reflection
 **********************/
const nextPlanOverlay = {
  back: ()=>$("nextPlanBack"),
  open(){
    const b = this.back();
    if(!b) return;
    b.classList.add("show");
    b.setAttribute("aria-hidden","false");
  },
  close(){
    const b = this.back();
    if(!b) return;
    b.classList.remove("show");
    b.setAttribute("aria-hidden","true");
  }
};

function computeBestMethod(){
  const nowTs = now();
  const start30 = nowTs - 30*24*3600*1000;
  const sess = (state.sessions||[]).filter(s=>Number(s.startTs||0) >= start30);
  if(!sess.length) return {method:"Practice", why:"No history yet — defaulting to Practice problems."};

  const by = new Map();
  for(const s of sess){
    const m = String(s.method||"").trim();
    if(!m) continue;
    const q = clamp(Number(s.quality||s.baseQuality||0), 1, 5);
    const cur = by.get(m) || {sum:0, n:0};
    cur.sum += q;
    cur.n += 1;
    by.set(m, cur);
  }

  let best = null;
  for(const [m,v] of by.entries()){
    if(v.n < 2) continue;
    const avg = v.sum / v.n;
    if(!best || avg > best.avg) best = {method:m, avg, n:v.n};
  }
  if(best) return {method: best.method, why: `Historically highest quality (${best.avg.toFixed(1)}/5, n=${best.n}).`};

  // Not enough samples — choose most frequent method
  const freq = {};
  sess.forEach(s=>{
    const m = String(s.method||"").trim();
    if(!m) return;
    freq[m] = (freq[m]||0) + 1;
  });
  const top = Object.entries(freq).sort((a,b)=>b[1]-a[1])[0]?.[0] || "Practice";
  return {method: top, why:"Limited history — using your most common method."};
}

function computeSuggestedSubject(){
  const subs = getSubjectsOnly();
  if(!subs.length) return {subject:"", why:"Add at least one subject in Settings to unlock recommendations (projects are for logging only)."};

  // Last studied timestamp per subject
  const last = {};
  (Array.isArray(state.sessions) ? state.sessions : []).forEach(s=>{
    const sub = (s && s.subject) ? String(s.subject) : "";
    if(!sub) return;
    const ts = Number(s.startTs || 0);
    if(!Number.isFinite(ts) || ts<=0) return;
    last[sub] = Math.max(last[sub] || 0, ts);
  });

  const nowTs = now();
  const rows = subs.map(sub=>{
    const ts = last[sub] || 0;
    const days = ts ? Math.floor((nowTs - ts) / (24*3600*1000)) : null;
    const risk = (days == null) ? 100 : clamp(days * 12, 0, 100);
    return {sub, risk, days};
  }).sort((a,b)=> (b.risk - a.risk) || a.sub.localeCompare(b.sub));

  const pick = rows[0];
  if(!pick) return {subject: subs[0] || "", why:"No history yet — starting with your first subject."};
  if(pick.days == null) return {subject: pick.sub, why:"Never logged — highest retention risk."};
  if(pick.days <= 0) return {subject: pick.sub, why:"Due today — quick reinforcement."};
  if(pick.days === 1) return {subject: pick.sub, why:"Last studied 1 day ago — good spacing window."};
  return {subject: pick.sub, why:`Last studied ${pick.days} days ago — higher retention risk.`};
}

function computeRecommendedDuration(){
  const r = readinessToday().score;
  const st = strainToday();
  let dur = 30;
  let why = "Balanced block.";

  if(r >= 80){ dur = 70; why = "High readiness — longer deep block is efficient."; }
  else if(r >= 65){ dur = 55; why = "Good readiness — medium-long block recommended."; }
  else if(r >= 50){ dur = 40; why = "Medium readiness — keep it structured and time-boxed."; }
  else if(r >= 35){ dur = 28; why = "Low readiness — short, high-quality block."; }
  else{ dur = 20; why = "Very low readiness — keep it light and brief."; }

  // If strain is already high, shorten slightly
  const upper = Number(getEffectiveGoals().strainUpper || 14);
  if(st > upper + 3){
    dur = Math.max(15, dur - 10);
    why += " Strain is already high, so we shorten to protect recovery.";
  }

  dur = clamp(Math.round(dur/5)*5, 10, 240);
  return {minutes: dur, why};
}

function sessionMethodsFrom(s){
  if(!s) return [];
  if(Array.isArray(s.methods) && s.methods.length) return s.methods.map(x=>String(x||"").trim()).filter(Boolean);
  const m = String(s.method||"").trim();
  return m ? [m] : [];
}

function computePlanConfidence(subject, method){
  const subj = String(subject||"");
  const meth = String(method||"");
  if(!subj || !meth) return {conf:"Low", n:0};

  const cutoff = now() - 90*24*3600*1000;
  const sims = (state.sessions||[]).filter(s=>{
    const ts = Number(s.startTs||0);
    if(ts < cutoff) return false;
    if(String(s.subject||"") !== subj) return false;
    return sessionMethodsFrom(s).includes(meth);
  });

  const n = sims.length;
  let conf = "Very low";
  if(n >= 10) conf = "High";
  else if(n >= 5) conf = "Medium";
  else if(n >= 2) conf = "Low";
  return {conf, n};
}

function computeNextSessionPlan(){
  const dur = computeRecommendedDuration();
  const meth = computeBestMethod();
  const subj = computeSuggestedSubject();
  const c = computePlanConfidence(subj.subject, meth.method);
  return {
    minutes: dur.minutes,
    minutesWhy: dur.why,
    method: meth.method,
    methodWhy: meth.why,
    subject: subj.subject,
    subjectWhy: subj.why,
    confidence: c.conf,
    similarN: c.n
  };
}

function renderNextPlan(plan){
  if($("nextPlanConfidence")) $("nextPlanConfidence").textContent = plan && plan.confidence ? `Confidence: ${plan.confidence} (based on ${plan.similarN||0} similar sessions).` : "";
  if($("nextPlanDuration")) $("nextPlanDuration").textContent = `${plan.minutes} min`;
  if($("nextPlanDurWhy")) $("nextPlanDurWhy").textContent = plan.minutesWhy || "—";
  if($("nextPlanMethod")) $("nextPlanMethod").textContent = plan.method || "--";
  if($("nextPlanMethWhy")) $("nextPlanMethWhy").textContent = plan.methodWhy || "—";
  if($("nextPlanSubject")) $("nextPlanSubject").textContent = plan.subject || "--";
  if($("nextPlanSubjWhy")) $("nextPlanSubjWhy").textContent = plan.subjectWhy || "—";
}

function applyNextPlan(plan){
  if(!plan) return;
  if($("sessMinutes")) $("sessMinutes").value = String(plan.minutes || 25);
  if($("sessMethod")) {
    $("sessMethod").value = String(plan.method || "");
    if(!state.ui) state.ui = {};
    state.ui.sessMethods = (plan.method ? [String(plan.method)] : []);
    try{ syncSessionMethodPicker(); }catch(e){}
  }
  if($("sessSubject")) $("sessSubject").value = String(plan.subject || "");
  if(!state.active){
    setTimerDisplay(getIdleSeconds());
    updateTimerViewVisuals(getIdleSeconds());
    if($("timerHint")) $("timerHint").textContent = "Plan applied. Ready when you are.";
  }
}

function maybeShowNextPlanOverlay(){
  if(state.active) return;
  if($("tourOverlay")?.classList.contains("show")) return;
  if(!state.ui) state.ui = {};

  const allowNextPlan = !(state.settings && state.settings.popups && state.settings.popups.nextPlan === false);
  if(!allowNextPlan) return;

  // Show at most once until a session is logged.
  // (After accept/reject, do not show again when you switch tabs.)
  if(state.ui.nextPlan){
    const st = state.ui.nextPlan.status;
    if(st === "accepted" || st === "rejected") return;
  }else{
    state.ui.nextPlan = {status:"pending", plan: computeNextSessionPlan(), createdAt: now()};
    saveState();
  }

  const np = state.ui.nextPlan;
  if(!np || np.status !== "pending") return;

  renderNextPlan(np.plan);
  nextPlanOverlay.open();
}

function initNextPlanOverlay(){
  const b = $("nextPlanBack");
  if(!b) return;

  // Intentionally do not allow dismiss without Accept/Reject
  b.addEventListener("click", (e)=>{ if(e.target === b){ /* ignore */ } });

  $("nextPlanReject")?.addEventListener("click", ()=>{
    if(!state.ui) state.ui = {};
    if(state.ui.nextPlan) state.ui.nextPlan.status = "rejected";
    saveState();
    nextPlanOverlay.close();
  });

  $("nextPlanAccept")?.addEventListener("click", ()=>{
    if(!state.ui) state.ui = {};
    const plan = state.ui.nextPlan?.plan;
    applyNextPlan(plan);
    if(state.ui.nextPlan) state.ui.nextPlan.status = "accepted";
    saveState();
    nextPlanOverlay.close();
  });
}

/* Quick end */
const quickEndOverlay = {
  back: ()=>$("quickEndBack"),
  selected: null,
  open(){
    const b = this.back();
    if(!b) return;
    this.selected = null;
    if($("quickEndSelected")) $("quickEndSelected").textContent = "—";
    if($("quickEndNote")) $("quickEndNote").textContent = "Pick one option to enable Finish.";
    if($("quickEndFinish")) $("quickEndFinish").disabled = true;
    $("quickEndChoices")?.querySelectorAll(".pillBig").forEach(p=>p.classList.remove("active"));
    b.classList.add("show");
    b.setAttribute("aria-hidden","false");
  },
  close(){
    const b = this.back();
    if(!b) return;
    b.classList.remove("show");
    b.setAttribute("aria-hidden","true");
  }
};

function applyQuickPreset(preset){
  const map = {
    great: {focus:4, retrieval:4, perf:4, effort:3, frustration:1, distractions:[]},
    okay:  {focus:3, retrieval:3, perf:3, effort:3, frustration:2, distractions:[]},
    rough: {focus:2, retrieval:2, perf:2, effort:4, frustration:4, distractions:["Thoughts"]}
  };
  const p = map[preset] || map.okay;

  if($("endFocus")) $("endFocus").value = String(p.focus);
  if($("endRetrieval")) $("endRetrieval").value = String(p.retrieval);
  if($("endPerf")) $("endPerf").value = String(p.perf);
  if($("endEffort")) $("endEffort").value = String(p.effort);
  if($("endFrustration")) $("endFrustration").value = String(p.frustration);

  $("endFocusVal") && ($("endFocusVal").textContent = String(p.focus));
  $("endRetrievalVal") && ($("endRetrievalVal").textContent = String(p.retrieval));
  $("endPerfVal") && ($("endPerfVal").textContent = String(p.perf));
  $("endEffortVal") && ($("endEffortVal").textContent = String(p.effort));
  $("endFrustrationVal") && ($("endFrustrationVal").textContent = String(p.frustration));

  $("endDistractRow")?.querySelectorAll(".pillOpt").forEach(el=>el.classList.remove("active"));
  if(Array.isArray(p.distractions) && p.distractions.length){
    $("endDistractRow")?.querySelectorAll(".pillOpt").forEach(el=>{
      if(p.distractions.includes(el.textContent.trim())) el.classList.add("active");
    });
  }

  if($("endEnv")) $("endEnv").value = "";
  if($("endNotes")) $("endNotes").value = "";
}

function initQuickEndOverlay(){
  const b = $("quickEndBack");
  if(!b) return;

  b.addEventListener("click", (e)=>{ if(e.target === b) quickEndOverlay.close(); });
  $("quickEndClose")?.addEventListener("click", ()=> quickEndOverlay.close());

  $("quickEndChoices")?.querySelectorAll(".pillBig").forEach(p=>{
    p.addEventListener("click", ()=>{
      $("quickEndChoices")?.querySelectorAll(".pillBig").forEach(x=>x.classList.remove("active"));
      p.classList.add("active");
      const preset = p.getAttribute("data-preset") || "okay";
      quickEndOverlay.selected = preset;
      applyQuickPreset(preset);
      try{ if(!state.ui) state.ui={}; state.ui.lastQuickPreset = preset; }catch(e){}
if($("quickEndSelected")) $("quickEndSelected").textContent = p.textContent.trim();
      if($("quickEndNote")) $("quickEndNote").textContent = "Ready to log with defaults. Use Details for edits.";
      if($("quickEndFinish")) $("quickEndFinish").disabled = false;
    });
  });

  $("quickEndDetails")?.addEventListener("click", ()=>{
    quickEndOverlay.close();
    endModal.open({preservePreset:true});
  });

  $("quickEndFinish")?.addEventListener("click", ()=>{
    if(!state.active){
      hint("No active session to log.");
      quickEndOverlay.close();
      return;
    }
    saveSessionFromModal();
    quickEndOverlay.close();
  });
}


function boot(){
  const safe = (fn, name)=>{
    try{ fn(); }
    catch(e){ console.error("[StudyTrack] Init failed:", name, e); }
  };

  // Apply persisted theme on load (and highlight the active theme button in Settings)
  try{
    const initialTheme = (state && state.settings && state.settings.theme) ? state.settings.theme : (document.body.getAttribute("data-theme") || "midnight");
    applyTheme(initialTheme);
  }catch(e){
    console.error("[StudyTrack] applyTheme on load failed", e);
  }

  // Tabs
  safe(initTabs, "tabs");
  safe(initTimerViewMenus, "timer view menus");
  safe(initTooltips, "tooltips");
  try{ $("coachDismissBtn")?.addEventListener("click", hideCoach); }catch(e){ console.error("[StudyTrack] coach wire failed", e); }

  // Settings + subjects
  safe(initSettings, "settings");
  safe(initSettingsAccordion, "settings accordion");
  safe(initFeedbackForm, "feedback form");
  safe(initSubjectsSettings, "subjects settings");
  safe(initProjectsSettings, "projects settings");
  try{ fillSessionSubjectSelect(); }catch(e){ console.error("[StudyTrack] fillSessionSubjectSelect failed", e); }
  safe(initSessionMethodPicker, "session method picker");

  // Goals
  safe(initGoals, "goals");

  // Daily check-in
  safe(initDailyCheckin, "daily check-in");

  // Timer + end modal + overlays
  safe(initDistractionPills, "distraction pills");
  safe(initEnvPills, "environment pills");
safe(initEndModal, "end modal");
  safe(initNextPlanOverlay, "next plan overlay");
  safe(initQuickEndOverlay, "quick end overlay");
  safe(initTimer, "timer");

  // Onboarding
  safe(initOnboarding, "onboarding");

  // Analytics
  safe(initAnalytics, "analytics");

  // Other
  safe(initMisc, "misc");

  try{ updateAll(); }catch(e){ console.error("[StudyTrack] updateAll failed", e); }
  try{ drawAnalytics(); }catch(e){ console.error("[StudyTrack] drawAnalytics failed", e); }

  // Prompt daily check-in on load if missing
  try{ maybePromptCheckin(false); }catch(e){ console.error("[StudyTrack] maybePromptCheckin failed", e); }

  // daily rollover checker
  setInterval(()=>{
    const t = todayKey();
    if(state.ui?.lastOpenDate !== t){
      state.ui.lastOpenDate = t;
      saveState();
      // reset active session on rollover (safest)
      maybePromptCheckin(false);
      updateAll();
      drawAnalytics();
    }
  }, 30*1000);

  window.addEventListener("resize", ()=>{
    updateOverviewCharts();
    drawAnalytics();
  });
}

document.addEventListener("DOMContentLoaded", boot);


/* ==========================
   PATCH v21 — Cognitive load: 2x check-ins + events + schedule + drain
   (Added per PDF "Untitled document (4)")
   ========================== */
(function(){
  // Utility helpers (use existing if present)
  const _ = (id)=> (typeof $ === "function" ? $(id) : document.getElementById(id));
  const clampN = (v,a,b)=> (typeof clamp === "function" ? clamp(v,a,b) : Math.min(b, Math.max(a, v)));
  const nowMs = ()=> (typeof now === "function" ? now() : Date.now());

  const DAY_MS = 24*3600*1000;

  const COG_EVENTS = [
    // NOTE: load values are in "strain-minutes equivalents" (higher = more draining).
    // effects add extra readiness penalties via stress/motivation/clarity proxies (small point additions).
    { key:"exam",        label:"Exam / Test",                 load:60,  schedKey:"exam",     effects:{ stress:6, motivation:2, clarity:4 } },
    { key:"presentation",label:"Presentation / oral",         load:45,  schedKey:"school",   effects:{ stress:5, motivation:1, clarity:3 } },
    { key:"deadline",    label:"Deadline crunch",             load:40,  schedKey:"homework", effects:{ stress:4, motivation:2, clarity:2 } },

    { key:"class_n",     label:"Class (normal)",              load:25,  schedKey:"school",   effects:{ stress:2, motivation:0, clarity:1 } },
    { key:"class_h",     label:"Class (high-focus)",          load:40,  schedKey:"school",   effects:{ stress:3, motivation:1, clarity:2 } },
    { key:"homework",    label:"Homework (light)",            load:18,  schedKey:"homework", effects:{ stress:1, motivation:0, clarity:1 } },
    { key:"homework_h",  label:"Homework (intense)",          load:30,  schedKey:"homework", effects:{ stress:2, motivation:1, clarity:2 } },

    { key:"commute",     label:"Commute",                     load:10,  schedKey:"commute",  effects:{ stress:1, motivation:0, clarity:0 } },
    { key:"sports",      label:"Sports / training",           load:20,  schedKey:"gym",      effects:{ stress:-1, motivation:+1, clarity:+1 } },

    { key:"parttime",    label:"Part-time shift",             load:22,  schedKey:"work",     effects:{ stress:2, motivation:0, clarity:1 } },
    { key:"chores",      label:"Chores / errands",            load:12,  schedKey:"chores",   effects:{ stress:1, motivation:0, clarity:0 } },
    { key:"social",      label:"Social pressure",             load:14,  schedKey:"social",   effects:{ stress:2, motivation:0, clarity:0 } },
    { key:"conflict",    label:"Argument / conflict",         load:28,  schedKey:"social",   effects:{ stress:4, motivation:1, clarity:2 } },

    { key:"screen",      label:"Screen overload",             load:16,  schedKey:"screen",   effects:{ stress:1, motivation:1, clarity:2 } },
    { key:"sleep",       label:"Poor sleep (today)",          load:22,  schedKey:"sleep",    effects:{ stress:2, motivation:2, clarity:3 } },
    { key:"ill",         label:"Headache / ill",              load:20,  schedKey:"ill",      effects:{ stress:2, motivation:1, clarity:3 } },
    { key:"caffeine",    label:"Caffeine crash",              load:14,  schedKey:"caffeine", effects:{ stress:1, motivation:1, clarity:2 } },
    // --- Extended activity database (hidden, used for custom matching) ---
    { key:"group_project", label:"Group project meeting", load:28, primary:false, aliases:["group work","project meeting","team meeting"], effects:{ stress:2, motivation:1, clarity:2 } },
    { key:"tutoring", label:"Tutoring / mentoring", load:20, primary:false, aliases:["peer mentoring","helping a friend"], effects:{ stress:1, motivation:2, clarity:2 } },
    { key:"lab_report", label:"Lab report / write-up", load:32, primary:false, aliases:["practical report","write up"], effects:{ stress:2, motivation:1, clarity:3 } },
    { key:"tok_essay", label:"TOK work", load:26, primary:false, aliases:["tok essay","tok exhibition","theory of knowledge"], effects:{ stress:2, motivation:1, clarity:3 } },
    { key:"ee_research", label:"Extended Essay work", load:34, primary:false, aliases:["extended essay","ee"], effects:{ stress:3, motivation:1, clarity:3 } },
    { key:"cas_reflection", label:"CAS reflection / planning", load:14, primary:false, aliases:["cas","creativity activity service"], effects:{ stress:1, motivation:1, clarity:1 } },
    { key:"ia_drafting", label:"IA drafting", load:30, primary:false, aliases:["internal assessment","ia"], effects:{ stress:2, motivation:1, clarity:3 } },
    { key:"uni_apps", label:"University applications", load:22, primary:false, aliases:["college apps","applications","personal statement"], effects:{ stress:3, motivation:0, clarity:1 } },
    { key:"past_papers", label:"Past paper practice", load:30, primary:false, aliases:["past papers","exam practice"], effects:{ stress:2, motivation:1, clarity:2 } },
    { key:"math_drill", label:"Timed problem drills", load:28, primary:false, aliases:["timed practice","drills"], effects:{ stress:2, motivation:1, clarity:2 } },
    { key:"flashcards_heavy", label:"Flashcards (heavy)", load:16, primary:false, aliases:["anki","spaced repetition"], effects:{ stress:0, motivation:1, clarity:2 } },
    { key:"essay_writing", label:"Essay writing", load:26, primary:false, aliases:["writing essay","paper 1","paper 2"], effects:{ stress:2, motivation:1, clarity:3 } },
    { key:"reading_dense", label:"Dense reading", load:20, primary:false, aliases:["heavy reading","textbook reading"], effects:{ stress:1, motivation:0, clarity:2 } },
    { key:"note_cleanup", label:"Organising notes", load:10, primary:false, aliases:["整理 notes","tidy notes","rewrite notes"], effects:{ stress:0, motivation:1, clarity:1 } },
    { key:"catch_up", label:"Catch-up session", load:24, primary:false, aliases:["catch up","behind schedule"], effects:{ stress:3, motivation:0, clarity:1 } },
    { key:"sleep_debt", label:"Sleep debt (last night)", load:35, primary:false, aliases:["slept badly","poor sleep","insomnia"], effects:{ stress:3, motivation:0, clarity:3 } },
    { key:"late_caffeine", label:"Late caffeine", load:12, primary:false, aliases:["coffee late","energy drink"], effects:{ stress:1, motivation:0, clarity:1 } },
    { key:"social_media_binge", label:"Social media binge", load:18, primary:false, aliases:["doomscroll","scrolling","tiktok"], effects:{ stress:2, motivation:0, clarity:2 } },
    { key:"gaming_late", label:"Gaming late", load:20, primary:false, aliases:["played games","gaming"], effects:{ stress:1, motivation:0, clarity:2 } },
    { key:"argument", label:"Stressful argument", load:30, primary:false, aliases:["fight","argument","conflict"], effects:{ stress:5, motivation:0, clarity:3 } },
    { key:"family_obligation", label:"Family obligation", load:16, primary:false, aliases:["family event","family duty"], effects:{ stress:2, motivation:0, clarity:1 } },
    { key:"commute_long", label:"Long commute", load:14, primary:false, aliases:["long commute","travel time"], effects:{ stress:1, motivation:0, clarity:1 } },
    { key:"sports_training", label:"Sports training", load:22, primary:false, aliases:["practice","training","gym session"], effects:{ stress:1, motivation:2, clarity:0 } },
    { key:"illness", label:"Feeling unwell", load:28, primary:false, aliases:["sick","ill","headache"], effects:{ stress:2, motivation:0, clarity:2 } },
    { key:"big_deadline", label:"Major deadline (multi-subject)", load:44, primary:false, aliases:["major deadline","multiple deadlines"], effects:{ stress:5, motivation:1, clarity:2 } },
    { key:"creative_work", label:"Creative portfolio work", load:18, primary:false, aliases:["art portfolio","design portfolio","pp"], effects:{ stress:1, motivation:2, clarity:1 } },
    { key:"presentation_prep", label:"Preparing a presentation", load:22, primary:false, aliases:["slides","present"], effects:{ stress:2, motivation:1, clarity:2 } },
    { key:"oral_practice", label:"Language oral practice", load:18, primary:false, aliases:["oral","speaking practice","mock oral"], effects:{ stress:2, motivation:1, clarity:2 } },
    { key:"coding_project", label:"Coding / CS project", load:24, primary:false, aliases:["programming","coding"], effects:{ stress:2, motivation:2, clarity:2 } },
    { key:"research_reading", label:"Research reading (papers)", load:22, primary:false, aliases:["papers","journal article"], effects:{ stress:1, motivation:0, clarity:3 } },
    { key:"administration", label:"Admin tasks", load:8, primary:false, aliases:["emails","forms","planning"], effects:{ stress:0, motivation:0, clarity:1 } },


  ];

  function parseDateKeyToDate(dateKey){
    // yyyy-mm-dd
    const [y,m,d] = (dateKey||"").split("-").map(n=>Number(n));
    return new Date(y, (m||1)-1, d||1);
  }
  function msAtTimeOnDate(dateKey, hhmm){
    const d = parseDateKeyToDate(dateKey);
    const [hh,mm] = (hhmm||"00:00").split(":").map(n=>Number(n));
    d.setHours(hh||0, mm||0, 0, 0);
    return d.getTime();
  }
  function dayStartMsFromMs(t){
    const d = new Date(t);
    d.setHours(0,0,0,0);
    return d.getTime();
  }
  function todayKeySafe(){
    return (typeof todayKey === "function") ? todayKey() : (new Date()).toISOString().slice(0,10);
  }

  function ensureSchema(){
    if(!window.state) return;
    state.events = Array.isArray(state.events) ? state.events : [];
if(!state.settings) state.settings = {};
    // Migrate old single check-in time
    if(!state.settings.checkinTimeAM) state.settings.checkinTimeAM = "08:00";
    if(!state.settings.checkinTimePM) state.settings.checkinTimePM = "18:00";
    if(!state.settings.wakeStart) state.settings.wakeStart = "07:00";
    if(!state.settings.wakeEnd) state.settings.wakeEnd = "23:00";
    // Back-compat: if old checkinTime exists, treat it as PM if PM not customized
    if(state.settings.checkinTime && !state.settings._migrated2x){
      const t = (String(state.settings.checkinTime)||"").trim();
      if(/^\d{2}:\d{2}$/.test(t)) state.settings.checkinTimePM = t;
      state.settings._migrated2x = true;
    }
    // Migrate dailyCheckins entries
    if(!state.dailyCheckins) state.dailyCheckins = {};
    Object.keys(state.dailyCheckins).forEach(k=>{
      const ci = state.dailyCheckins[k];
      if(!ci || typeof ci !== "object") return;
      if(ci.morning || ci.evening) return;
      // Old shape -> assume evening
      state.dailyCheckins[k] = { morning:null, evening:ci };
    });
    if(!state.ui) state.ui = {};
    if(!("lastCheckinPromptKey" in state.ui)) state.ui.lastCheckinPromptKey = "";
  }

  // Ensure a safe post-update hook exists (used by check-in + event toggles).
  // This centralizes UI refresh so save handlers don't rely on missing functions.
  if(typeof window.updateAfterLoadChange !== "function"){
    window.updateAfterLoadChange = function(){
      try{ if(typeof updateAll === "function") updateAll(); }catch(e){}
      try{
        // Keep check-in prompt hints accurate after saving
        if(typeof updateSettingCheckinHint_2x === "function") updateSettingCheckinHint_2x();
        else if(typeof updateSettingCheckinHint === "function") updateSettingCheckinHint();
      }catch(e){}
      try{
        // Ensure readiness interpretation text refreshes even if the user saved check-in while not on Overview
        if(typeof updateReadinessUI === "function") updateReadinessUI();
      }catch(e){}
    };
  }

  function getCheckinsForDate(dateKey){
    const entry = state.dailyCheckins?.[dateKey];
    if(!entry) return {morning:null, evening:null};
    if(entry.morning || entry.evening) return { morning: entry.morning||null, evening: entry.evening||null };
    return {morning:null, evening:entry};
  }
  function latestCheckinForDate(dateKey){
    const {morning, evening} = getCheckinsForDate(dateKey);
    if(evening && evening.savedAt) return { part:"evening", ci:evening };
    if(morning && morning.savedAt) return { part:"morning", ci:morning };
    // fallback: if exists but no savedAt, prefer evening
    if(evening) return { part:"evening", ci:evening };
    if(morning) return { part:"morning", ci:morning };
    return null;
  }

  // Override readinessBaseFor to use latest (morning/evening)
  function readinessBaseFor_2x(date){
    const latest = latestCheckinForDate(date);
    if(!latest || !latest.ci) return null;
    const ci = latest.ci;
    const sleep = clampN(ci.sleepQ,1,5);
    const stress = clampN(ci.stress,1,5);
    const mot = clampN(ci.motivation,1,5);
    const clar = clampN(ci.clarity,1,5);
    const stressInv = 6 - stress;
    const weighted = (sleep*0.30 + stressInv*0.25 + mot*0.22 + clar*0.23);
    return clampN(Math.round(weighted*20), 0, 100);
  }

  function wakeWindowForDate(dateKey){
    const ws = state.settings?.wakeStart || "07:00";
    const we = state.settings?.wakeEnd || "23:00";
    const s = msAtTimeOnDate(dateKey, ws);
    const e = msAtTimeOnDate(dateKey, we);
    return { start:s, end:e };
  }

  function passiveDrainPointsForNow(){
    // -1 readiness every 55 minutes awake, scaled by low sleep/high stress (from latest check-in today)
    const dateKey = todayKeySafe();
    const t = nowMs();
    const {start, end} = wakeWindowForDate(dateKey);
    if(t <= start) return 0;
    const tClamped = Math.min(t, end);
    const awakeMin = Math.max(0, (tClamped - start)/60000);
    let mult = 1.0;

    const latest = latestCheckinForDate(dateKey);
    if(latest && latest.ci){
      const sleepQ = clampN(latest.ci.sleepQ,1,5);
      const stress = clampN(latest.ci.stress,1,5);
      if(sleepQ <= 2) mult *= 1.25;
      if(stress >= 4) mult *= 1.20;
    }
    const base = awakeMin / 55;
    return clampN(Math.floor(base * mult), 0, 25);
  }

  function computeEventLoadMinInRange(startMs, endMs){
    const arr = Array.isArray(state.events) ? state.events : [];
    let total = 0;
    for(const ev of arr){
      if(!ev) continue;
      const t = Number(ev.ts||0);
      if(!Number.isFinite(t)) continue;
      if(t>=startMs && t<endMs){
        total += Math.max(0, Number(ev.load||0));
      }
    }
    return total;
  }

  function overlapMinutes(a0,a1,b0,b1){
    const s = Math.max(a0,b0);
    const e = Math.min(a1,b1);
    return Math.max(0, (e-s)/60000);
  }

  function computeEventExtraPenaltyPointsInRange(startMs, endMs){
    // Sum small readiness penalties from events (stress/motivation/clarity proxies).
    const arr = Array.isArray(state.events) ? state.events : [];
    let pts = 0;
    for(const ev of arr){
      if(!ev) continue;
      const t = Number(ev.ts||0);
      if(!Number.isFinite(t) || t<startMs || t>=endMs) continue;
      const fx = ev.effects || null;
      if(!fx) continue;
      // Map effects (roughly 0–6) to points (kept small to avoid dominating strain).
      pts += Math.max(0, Number(fx.stress||0)) * 0.8;
      pts += Math.max(0, Number(fx.motivation||0)) * 0.5;
      pts += Math.max(0, Number(fx.clarity||0)) * 0.7;
    }
    return clampN(Math.round(pts), 0, 18);
  }

  function computeTotalStrainMinInRange(startMs, endMs){
    // session strain minutes (existing) + manual event loads
const sessionMin = (typeof sessionsInRange==="function" && typeof strainForSession==="function")
      ? sessionsInRange(startMs,endMs).reduce((a,s)=>a+strainForSession(s), 0)
      : 0;
        const evMin = computeEventLoadMinInRange(startMs,endMs);
    return Math.max(0, sessionMin + evMin);
  }

  // Override strainToday and readinessToday to incorporate schedule/events and passive drain
  function strainToday_2x(){
    const t = nowMs();
    const start = dayStartMsFromMs(t);
    const endNow = t;
    return computeTotalStrainMinInRange(start, endNow);
  }

  function readinessToday_2x(){
    const date = todayKeySafe();
    const base = readinessBaseFor_2x(date);

    let baseScore = null;
    let source = "checkin";
    if(base === null){
      let est = clampN(Math.round(((state.baselines?.energy + state.baselines?.focus)/2) * 20), 0, 100);
      if(!Number.isFinite(est)) est = 50;
      baseScore = est;
      source = "baseline";
    }else{
      baseScore = Number(base);
    }

    const t = nowMs();
    const start = dayStartMsFromMs(t);
    const dayMs = DAY_MS;
    const endNow = t;

    const strainMinToday = computeTotalStrainMinInRange(start, endNow);
    const strainMinYesterday = computeTotalStrainMinInRange(start-dayMs, start);
    const strainMinLast3Avg = computeTotalStrainMinInRange(start-3*dayMs, start) / 3;

    const p0 = clampN(Math.round(strainMinToday / 18), 0, 35);
    const p1 = clampN(Math.round(strainMinYesterday / 28), 0, 20);
    const p3 = clampN(Math.round(strainMinLast3Avg / 36), 0, 12);

    const passive = passiveDrainPointsForNow();

    const extraEv = computeEventExtraPenaltyPointsInRange(start, endNow);
    const penalty = clampN(p0 + p1 + p3 + passive + extraEv, 0, 75);
    const score = clampN(Math.round(baseScore - penalty), 0, 100);

    return { score, base:baseScore, penalty, source, passive, strainMinToday, extraEv, extraSch }; clampN(Math.round(baseScore - penalty), 0, 100);

    return { score, base:baseScore, penalty, source, passive, strainMinToday };
  }

  // Override drawDeepRate to prevent axis label overlap
  function drawDeepRate_2x(canvasId, series){
    const canvas = _(canvasId);
    if(!canvas) return;
    const prep = (typeof prepCanvas==="function") ? prepCanvas(canvas) : null;
    if(!prep) return;
    const {ctx,w,h} = prep;
    const pad = 56; // increased from 40 to avoid label overlap
    if(typeof axes==="function") axes(ctx,w,h,pad);

    if(!series || !series.length){
      ctx.fillStyle = "rgba(255,255,255,.75)";
      ctx.font = "12px system-ui";
      ctx.fillText("No sessions in range", pad, h/2);
      return;
    }

    const pts = series.filter(p=>p.y!==null && !isNaN(p.y));
    if(!pts.length){
      ctx.fillStyle = "rgba(255,255,255,.75)";
      ctx.font = "12px system-ui";
      ctx.fillText("No deep work data", pad, h/2);
      return;
    }

    ctx.font = "10px system-ui";
    ctx.fillStyle = "rgba(255,255,255,.56)";
    [0,25,50,75,100].forEach(v=>{
      const y = (h-pad) - (v/100)*(h-2*pad);
      ctx.textAlign="right";
      ctx.fillText(v+"%", pad-12, y+4);
      ctx.textAlign="left";
      ctx.strokeStyle = "rgba(255,255,255,.06)";
      ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
    });

    // axis labels: shift left label down slightly by using existing helper if present
    if(typeof axisLabels==="function"){
      axisLabels(ctx,w,h,pad,"Date","Deep work rate (%)");
    }else{
      ctx.fillStyle="rgba(255,255,255,.65)";
      ctx.font="11px system-ui";
      ctx.fillText("Date", w/2-12, h-10);
      ctx.save();
      ctx.translate(14, h/2+30);
      ctx.rotate(-Math.PI/2);
      ctx.fillText("Deep work rate (%)", 0,0);
      ctx.restore();
    }

    const ymin = 0, ymax = 100;
    const n = series.length;
    const xAt = (i)=> pad + (i/(Math.max(1,n-1)))*(w-2*pad);
    const yAt = (v)=> (h-pad) - ((v-ymin)/(ymax-ymin))*(h-2*pad);

    // Line
    ctx.strokeStyle = "rgba(38,213,198,.9)";
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    series.forEach((p,i)=>{
      const x=xAt(i);
      const y=yAt(clampN(p.y,0,100));
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // Points
    ctx.fillStyle = "rgba(38,213,198,.95)";
    series.forEach((p,i)=>{
      const x=xAt(i);
      const y=yAt(clampN(p.y,0,100));
      ctx.beginPath(); ctx.arc(x,y,3.2,0,Math.PI*2); ctx.fill();
    });
  }

  function checkinTargetMsForPart(dateKey, part){
    const tStr = (part==="morning") ? (state.settings?.checkinTimeAM || "08:00") : (state.settings?.checkinTimePM || "18:00");
    return msAtTimeOnDate(dateKey, tStr);
  }

  function nextPromptText(){
    const dateKey = todayKeySafe();
    const t = nowMs();
    const ci = getCheckinsForDate(dateKey);
    const amDone = !!ci.morning;
    const pmDone = !!ci.evening;

    const amT = checkinTargetMsForPart(dateKey,"morning");
    const pmT = checkinTargetMsForPart(dateKey,"evening");
    const midT = msAtTimeOnDate(dateKey, "12:00");

    // Morning: only due BEFORE midday. After midday, we treat it as "missed" and only schedule the evening check-in.
    if(!amDone && t < amT) return `Next prompt: today at ${state.settings.checkinTimeAM} (morning)`;
    if(!amDone && t >= amT && t < midT) return `Next prompt: now (morning check-in due)`;

    // After midday, skip morning and move to evening.
    if(!pmDone && t < pmT) return `Next prompt: today at ${state.settings.checkinTimePM} (evening)`;
    if(!pmDone && t >= pmT) return `Next prompt: now (evening check-in due)`;

    // both done -> tomorrow morning
    return `Next prompt: tomorrow at ${state.settings.checkinTimeAM} (morning)`;
  }

  function updateSettingCheckinHint_2x(){
    const el = _("settingCheckinNextHint");
    if(!el) return;
    el.textContent = nextPromptText();
  }

  function chooseDuePart(forceOpen){
    const dateKey = todayKeySafe();
    const t = nowMs();
    const ci = getCheckinsForDate(dateKey);
    const amDone = !!ci.morning;
    const pmDone = !!ci.evening;
    const amT = checkinTargetMsForPart(dateKey,"morning");
    const pmT = checkinTargetMsForPart(dateKey,"evening");
    const midT = msAtTimeOnDate(dateKey, "12:00");

    // Rule: if the user opens the site after midday and missed the morning check-in,
    // we do NOT prompt morning retroactively — we only prompt the evening check-in.
    const morningAllowedNow = t < midT;

    if(forceOpen){
      // Respect the same midday rule for force-open to avoid showing both parts in one day.
      if(!pmDone && (!morningAllowedNow || amDone)) return "evening";
      if(!amDone && morningAllowedNow) return "morning";
      if(!pmDone) return "evening";
      return (t < pmT) ? "evening" : "morning";
    }

    if(!amDone && morningAllowedNow && t >= amT) return "morning";
    if(!pmDone && t >= pmT) return "evening";
    return null;
  }

  function maybePromptCheckin_2x(forceOpen=false){
    const dateKey = todayKeySafe();
    const t = nowMs();

    // Ensure ui shape
    if(!state.ui) state.ui = {};
    if(!("onboarded" in state.ui)) state.ui.onboarded = ((Array.isArray(state.subjects)&&state.subjects.length>0) || (Array.isArray(state.projects)&&state.projects.length>0));
    if(!("lastCheckinPromptKey" in state.ui)) state.ui.lastCheckinPromptKey = "";
    if(!("lastCheckinPromptAt" in state.ui)) state.ui.lastCheckinPromptAt = 0;

    // Do not prompt before onboarding is completed
    const onboardBack = _("modalOnboardBack");
    if(!state.ui.onboarded || onboardBack?.classList.contains("show")){
      if(typeof saveState==="function") saveState();
      return;
    }

    const part = chooseDuePart(forceOpen);
    if(!part){
      updateSettingCheckinHint_2x();
      return;
    }

    const key = `${dateKey}:${part}`;
    if(!forceOpen && state.ui.lastCheckinPromptKey === key){
      updateSettingCheckinHint_2x();
      return;
    }

    const allow = !(state.settings && state.settings.popups && state.settings.popups.checkin === false);
    if(!allow){
      updateSettingCheckinHint_2x();
      return;
    }

    openCheckinWithPart(part);
    state.ui.lastCheckinPromptKey = key;
    state.ui.lastCheckinPromptAt = t;
    if(typeof saveState==="function") saveState();
    updateSettingCheckinHint_2x();
  }

  function openCheckinWithPart(part){
    window.__ciPart = part;
    const h3 = document.querySelector("#modalCheckinBack h3");
    const p = document.querySelector("#modalCheckinBack .mhead p");
    if(h3) h3.textContent = (part==="morning") ? "Morning check-in ✨" : "Evening check-in ✨";
    if(p) p.textContent = "Quick inputs that set your readiness baseline. Evening updates immediately.";
    // Update toggle state
    const bM = _("ciPartMorning");
    const bE = _("ciPartEvening");
    if(bM && bE){
      bM.classList.toggle("active", part==="morning");
      bE.classList.toggle("active", part==="evening");
    }
    // Ensure Event logging UI exists (important for first-time users)
    try{ injectCheckinEnhancements(); }catch(e){}
    // Refresh event buttons to avoid overlap with schedule
    renderEventButtons();
    if(typeof checkinModal !== "undefined" && checkinModal && typeof checkinModal.open==="function"){
      checkinModal.open({ source:"manual" });
    }
  }

  function renderEventButtons(){
    const wrap = _("ciEventButtons");
    if(!wrap) return;

    const dateKey = todayKeySafe();

    // Build selected set for today
    state.dayEventToggles = state.dayEventToggles || {};
    const selected = new Set(Array.isArray(state.dayEventToggles[dateKey]) ? state.dayEventToggles[dateKey] : []);

    // Persisted "pinned" custom matches (appear as extra preset buttons)
    if(!state.ui) state.ui = {};
    if(!Array.isArray(state.ui.eventPins)) state.ui.eventPins = [];
    if(!Array.isArray(state.ui.eventCustomDefs)) state.ui.eventCustomDefs = [];
    const pinnedKeys = state.ui.eventPins;
    const customDefs = state.ui.eventCustomDefs;


    wrap.innerHTML = "";

    // Preset buttons: keep this short (most common), and keep the extended DB hidden unless matched via custom input.
    const PRESET_EVENT_KEYS = ["exam","class_n","homework","sports","chores","social","screen","ill"];
    const shown = COG_EVENTS.filter(e=>{
      if(!e) return false;
      if(e.primary === false) return false; // hidden DB items
      return PRESET_EVENT_KEYS.includes(e.key);
    });

    // Add pinned matches (from internal DB) and custom user-defined events
    const pinned = (pinnedKeys||[]).map(k => COG_EVENTS.find(e=>e && e.key===k)).filter(Boolean);
    pinned.forEach(ev=>{ if(!shown.some(x=>x.key===ev.key)) shown.push(ev); });
    (customDefs||[]).forEach(ev=>{ if(ev && ev.key && !shown.some(x=>x.key===ev.key)) shown.push(ev); });

    shown.forEach(e=>{
      const btn = document.createElement("button");
      btn.type="button";
      btn.className="chip ciEventBtn";
      btn.style.cursor="pointer";
      btn.textContent = e.label;

      const applyActive = ()=>{
        btn.classList.toggle("selected", selected.has(e.key));
        btn.setAttribute("aria-pressed", selected.has(e.key) ? "true" : "false");
      };
      applyActive();

      btn.addEventListener("click", ()=>{
        const isOn = selected.has(e.key);

        state.events = Array.isArray(state.events) ? state.events : [];

        if(isOn){
          // Toggle OFF: remove from selected + remove the most recent matching event today
          selected.delete(e.key);
          const start = msAtTimeOnDate(dateKey, "00:00");
          const end = start + DAY_MS;
          for(let i=state.events.length-1;i>=0;i--){
            const ev = state.events[i];
            if(!ev) continue;
            const t = Number(ev.ts||0);
            if(ev.key===e.key && t>=start && t<end){
              state.events.splice(i,1);
              break;
            }
          }
        }else{
          // Toggle ON: add to selected + add one event record
          selected.add(e.key);
          state.events.push({ key:e.key, label:e.label, load:e.load, effects: (e.effects||null), ts: nowMs() });
        }

        state.dayEventToggles[dateKey] = Array.from(selected);

        if(typeof saveState==="function") saveState();
        applyActive();
      try{ if(typeof updateAfterLoadChange==="function") updateAfterLoadChange(); }catch(e){}
      });

      wrap.appendChild(btn);
    });
  }
  // --- Custom Event matching (simple fuzzy match) ---
  function normTxt(s){
    return String(s||"")
      .toLowerCase()
      .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
      .replace(/[^a-z0-9]+/g," ")
      .trim();
  }
  function tokenSet(s){
    const t = normTxt(s).split(/\s+/).filter(Boolean);
    return new Set(t);
  }
  function jaccard(a,b){
    if(a.size===0 || b.size===0) return 0;
    let inter=0;
    a.forEach(x=>{ if(b.has(x)) inter++; });
    const union = a.size + b.size - inter;
    return union ? (inter/union) : 0;
  }
  function bestEventMatch(q){
    const query = normTxt(q);
    if(!query) return null;
    const qTokens = tokenSet(query);

    let best = null;
    let bestScore = 0;

    (Array.isArray(COG_EVENTS) ? COG_EVENTS : []).forEach(ev=>{
      const candidates = [ev.label, ev.key].concat(Array.isArray(ev.aliases)? ev.aliases : []);
      let score = 0;
      candidates.forEach(c=>{
        const cNorm = normTxt(c);
        if(!cNorm) return;
        const cTokens = tokenSet(cNorm);
        const jac = jaccard(qTokens, cTokens);
        const substr = (cNorm.includes(query) || query.includes(cNorm)) ? 1 : 0;
        const s = (jac*0.55) + (substr*0.45);
        if(s > score) score = s;
      });
      if(score > bestScore){
        bestScore = score;
        best = ev;
      }
    });

    if(!best) return null;
    return { ev: best, score: bestScore };
  }

  function showNoMatchPill(msg){
    // Reuse the existing toast for a lightweight animated notice
    try{ showToast("No match", msg || "No record found."); }catch(e){}
  }

  function toggleEventForToday(ev){
    if(!ev) return;
    const dateKey = todayKeySafe();
    state.dayEventToggles = state.dayEventToggles || {};
    const selected = new Set(Array.isArray(state.dayEventToggles[dateKey]) ? state.dayEventToggles[dateKey] : []);

    state.events = Array.isArray(state.events) ? state.events : [];
    const isOn = selected.has(ev.key);

    if(isOn){
      selected.delete(ev.key);
      const start = msAtTimeOnDate(dateKey, "00:00");
      const end = start + DAY_MS;
      for(let i=state.events.length-1;i>=0;i--){
        const e2 = state.events[i];
        if(!e2) continue;
        const t = Number(e2.ts||0);
        if(e2.key===ev.key && t>=start && t<end){
          state.events.splice(i,1);
          break;
        }
      }
    }else{
      selected.add(ev.key);
      state.events.push({ key:ev.key, label:ev.label, load:ev.load, effects:(ev.effects||null), ts: nowMs() });
    }

    state.dayEventToggles[dateKey] = Array.from(selected);
    if(typeof saveState==="function") saveState();
    renderEventButtons();
    updateAfterLoadChange();
  }

  function wireEventCustom(){
    const inp = _("ciEventCustom");
    const btn = _("btnCiEventCustom");
    const hint = _("ciEventCustomHint");
    if(!inp || !btn) return;
    if(inp.dataset && inp.dataset.wired==="1") return;
    if(inp.dataset) inp.dataset.wired="1";

    const norm = (s)=> String(s||"").toLowerCase().trim();

    const findMatch = (q)=>{
      const qq = norm(q);
      if(!qq) return null;
      // Prefer exact label match, then key match, then partial label match.
      let exact = null;
      for(const ev of COG_EVENTS){
        if(!ev) continue;
        const lbl = norm(ev.label);
        const key = norm(ev.key);
        if(lbl===qq || key===qq) { exact = ev; break; }
      }
      if(exact) return exact;
      for(const ev of COG_EVENTS){
        if(!ev) continue;
        const lbl = norm(ev.label);
        const key = norm(ev.key);
        if(lbl.includes(qq) || key.includes(qq)) return ev;
      }
      return null;
    };

    const ensurePins = ()=>{
      if(!state.ui) state.ui = {};
      if(!Array.isArray(state.ui.eventPins)) state.ui.eventPins = [];
      if(!Array.isArray(state.ui.eventCustomDefs)) state.ui.eventCustomDefs = [];
    };

    const pinInternal = (ev)=>{
      ensurePins();
      if(!state.ui.eventPins.includes(ev.key)) state.ui.eventPins.unshift(ev.key);
      // keep it tidy
      state.ui.eventPins = state.ui.eventPins.slice(0, 8);
      if(typeof saveState==="function") saveState();
      renderEventButtons();
    };

    const addCustom = (label)=>{
      ensurePins();
      const base = norm(label).replace(/[^a-z0-9]+/g,"_").replace(/^_+|_+$/g,"").slice(0,24) || "custom";
      let key = "custom_" + base;
      let n = 2;
      while(COG_EVENTS.some(e=>e && e.key===key) || state.ui.eventCustomDefs.some(e=>e && e.key===key)){
        key = "custom_" + base + "_" + (n++);
      }
      const ev = { key, label: String(label).trim(), load: 18, effects:{ stress:1, motivation:0, clarity:1 } };
      state.ui.eventCustomDefs.unshift(ev);
      state.ui.eventCustomDefs = state.ui.eventCustomDefs.slice(0, 10);
      if(typeof saveState==="function") saveState();
      renderEventButtons();
      return ev;
    };

    const act = ()=>{
      const q = (inp.value||"").trim();
      if(!q) return;
      const match = findMatch(q);
      if(match){
        pinInternal(match);
        if(hint) hint.textContent = `Added "${match.label}" above. Tap it to toggle for today.`;
      }else{
        const ev = addCustom(q);
        if(hint) hint.textContent = `Created "${ev.label}" above. Tap it to toggle for today.`;
      }
      inp.value = "";
    };

    btn.onclick = act;
    inp.addEventListener("keydown", (e)=>{
      if(e.key==="Enter"){
        e.preventDefault();
        act();
      }
    });
    inp.addEventListener("input", ()=>{
      const q = (inp.value||"").trim();
      if(!hint) return;
      if(!q){
        hint.textContent = "Tip: type a name and press Add. If it matches a known event, it will appear as a button above.";
        return;
      }
      const match = findMatch(q);
      hint.textContent = match ? `Match found: ${match.label}. Press Add to pin it above.` : "No match yet. Press Add to create a custom event button.";
    });
  }



  function renderLoggedEventsToday(){
    const list = _("ciEventList");
    if(list) list.innerHTML = "";
  }

  function injectCheckinEnhancements(){
    const back = _("modalCheckinBack");
    if(!back) return;

    const mbody = back.querySelector(".mbody");
    if(!mbody) return;

    // Full-width Event logging section near bottom (above footer)
    if(!_("ciEventButtons")){
      const sec = document.createElement("div");
      sec.style.marginTop = "14px";
      sec.innerHTML = `
        <div class="box" style="width:100%; grid-column: 1 / -1;">
          <h4>Event logging</h4>
          <div class="small" style="opacity:.85; margin-top:4px;">
            Tap events that happened today. Selected events apply cognitive load immediately and update readiness mid-day.
          </div>
          <div id="ciEventButtons" class="ciEventRow" style="display:flex; flex-wrap:wrap; gap:8px; width:100%; margin-top:10px;"></div>

          <div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
            <input class="inp" id="ciEventCustom" placeholder="Type a custom event (e.g., &quot;group project meeting&quot;)" style="flex:1"/>
            <button class="btn" id="btnCiEventCustom" type="button">Add</button>
          </div>
<div class="small" id="ciEventCustomHint" style="opacity:.8; margin-top:6px;">Tip: type a name and press Add. If it matches a known event, it will appear as a button above.</div>
        </div>
      `;
      mbody.appendChild(sec);
    }
    try{ wireEventCustom(); }catch(e){}
  }

  function injectSettingsEnhancements(){
    // Add 2x check-in time + waking hours inside existing card
    const card = _("cardCheckinTime");
    if(card && !_("settingCheckinTimeAM")){
      const body = card.querySelector(".accBody");
      if(body){
        const form = body.querySelector(".form");
        if(form){
          // hide old single time input but keep it for compatibility
          const old = _("settingCheckinTime");
          if(old){
            const oldField = old.closest(".field");
const oldVal = state.settings.checkinTimePM || "18:00";
try{ oldField && oldField.remove(); }catch(e){}
// Keep a hidden compatibility input (some older code may still read #settingCheckinTime)
const hiddenOld = document.createElement("input");
hiddenOld.type = "hidden";
hiddenOld.id = "settingCheckinTime";
hiddenOld.value = oldVal;
body.appendChild(hiddenOld);
          }

          const block = document.createElement("div");
          block.className = "field";
          block.style.gridColumn = "span 2";
          block.innerHTML = `
            <div class="lbl">Morning check-in time</div>
            <input class="inp" id="settingCheckinTimeAM" type="time" value="${state.settings.checkinTimeAM || "08:00"}"/>
            
          `;
          const block2 = document.createElement("div");
          block2.className = "field";
          block2.style.gridColumn = "span 2";
          block2.innerHTML = `
            <div class="lbl">Evening check-in time</div>
            <input class="inp" id="settingCheckinTimePM" type="time" value="${state.settings.checkinTimePM || "18:00"}"/>
            
          `;
          const wh = document.createElement("div");
          wh.className = "field";
          wh.style.gridColumn = "span 2";
          wh.innerHTML = `
            <div class="lbl">Waking hours</div>
            <div class="row" style="gap:10px; margin-top:6px;">
              <input class="inp" id="settingWakeStart" type="time" value="${state.settings.wakeStart || "07:00"}" style="max-width:140px;"/>
              <div class="small" style="opacity:.75; align-self:center;">to</div>
              <input class="inp" id="settingWakeEnd" type="time" value="${state.settings.wakeEnd || "23:00"}" style="max-width:140px;"/>
            </div>
            <div class="small" style="margin-top:6px; opacity:.78;">Used for passive readiness drain (ring won’t freeze).</div>
          `;

          // Insert after existing field set
          form.appendChild(block);
          form.appendChild(block2);
          form.appendChild(wh);
        }
      }
    }

    // Insert schedule card after check-in card
    

  }

  function wireNewSettingsInputs(){
    const am = _("settingCheckinTimeAM");
    const pm = _("settingCheckinTimePM");
    const ws = _("settingWakeStart");
    const we = _("settingWakeEnd");
    if(am){
      am.value = state.settings.checkinTimeAM || "08:00";
      am.addEventListener("change", ()=>{
        state.settings.checkinTimeAM = am.value || "08:00";
        if(typeof saveState==="function") saveState();
        updateSettingCheckinHint_2x();
      });
    }
    if(pm){
      pm.value = state.settings.checkinTimePM || "18:00";
      pm.addEventListener("change", ()=>{
        state.settings.checkinTimePM = pm.value || "18:00";
        // keep back-compat field aligned
        state.settings.checkinTime = state.settings.checkinTimePM;
        if(typeof saveState==="function") saveState();
        updateSettingCheckinHint_2x();
      });
    }
    if(ws){
      ws.value = state.settings.wakeStart || "07:00";
      ws.addEventListener("change", ()=>{
        state.settings.wakeStart = ws.value || "07:00";
        if(typeof saveState==="function") saveState();
        updateAfterLoadChange();
      });
    }
    if(we){
      we.value = state.settings.wakeEnd || "23:00";
      we.addEventListener("change", ()=>{
        state.settings.wakeEnd = we.value || "23:00";
        if(typeof saveState==="function") saveState();
        updateAfterLoadChange();
      });
    }

    // Replace "Open check-in now" to open due part
    const btn = _("btnOpenCheckinNow");
    if(btn){
      btn.onclick = ()=> maybePromptCheckin_2x(true);
    }
  }

  function wireSaveCheckin(){
    const btn = _("btnSaveCheckin");
    if(!btn) return;
    btn.onclick = ()=>{
      const date = todayKeySafe();
      const part = window.__ciPart || chooseDuePart(true) || "evening";
      if(!state.dailyCheckins) state.dailyCheckins = {};
      if(!state.dailyCheckins[date] || !(state.dailyCheckins[date].morning || state.dailyCheckins[date].evening)){
        state.dailyCheckins[date] = { morning:null, evening:null };
      }
      const entry = state.dailyCheckins[date];

      const ciObj = {
        sleepQ: Number(_("ciSleepQ")?.value||3),
        stress: Number(_("ciStress")?.value||3),
        motivation: Number(_("ciMotivation")?.value||3),
        clarity: Number(_("ciClarity")?.value||3),
        savedAt: nowMs(),
        part
      };

      entry[part] = ciObj;

      // Save state and update baselines from latest check-in (dominant signal)
      try{
        if(typeof updateBaselinesFromCheckin==="function"){
          // call original, but it expects old shape; we'll provide latest via overridden function below
          updateBaselinesFromCheckin(date);
        }
      }catch(e){}

      if(typeof saveState==="function") saveState();
      if(typeof checkinModal!=="undefined" && checkinModal && typeof checkinModal.close==="function") checkinModal.close();

      // immediate UI update (baseline may jump after evening)
      updateAfterLoadChange();

      // Coach popup after check-in (keep existing behavior)
      try{ if(typeof maybeShowCoachAfterCheckin==="function") maybeShowCoachAfterCheckin(); }catch(e){}
    };
  }

  function patchCoachTrends(){
    if(typeof buildDailyCoachHtml !== "function") return;
    const orig = buildDailyCoachHtml;
    window.buildDailyCoachHtml = function(){
      let html = "";
      try{ html = orig(); }catch(e){ html=""; }

      // Only show trends after ~14 days of use
      const days = Object.keys(state.dailyCheckins||{}).filter(k=>{
        const c = state.dailyCheckins[k];
        if(!c) return false;
        if(c.morning || c.evening) return !!(c.morning || c.evening);
        return true;
      });
      if(days.length < 14) return html;

      // Trend: compare total load on days with certain events vs without (simple descriptive)
      const dayLoads = {};
      days.forEach(k=>{
        const start = msAtTimeOnDate(k,"00:00");
        const end = start + DAY_MS;
        dayLoads[k] = computeTotalStrainMinInRange(start,end);
      });

      const eventByDay = {};
      (state.events||[]).forEach(ev=>{
        if(!ev || !ev.ts) return;
        const d = new Date(ev.ts);
        const key = d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0")+"-"+String(d.getDate()).padStart(2,"0");
        if(!eventByDay[key]) eventByDay[key] = new Set();
        eventByDay[key].add(ev.key);
      });

      function avg(arr){ return arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length) : null; }

      const buckets = [
        { key:"exam", title:"Exam/Test days" },
        { key:"sports", title:"Sports/training days" },
        { key:"stress", title:"High-stress logged days" }
      ];

      const lines = [];
      buckets.forEach(b=>{
        const withIt = [];
        const without = [];
        days.forEach(k=>{
          const has = eventByDay[k]?.has(b.key);
          const val = dayLoads[k];
          if(!Number.isFinite(val)) return;
          (has ? withIt : without).push(val);
        });
        if(withIt.length >= 3 && without.length >= 3){
          const a = avg(withIt), b0 = avg(without);
          lines.push(`<li><b>${b.title}:</b> avg total load ${Math.round(a)} vs ${Math.round(b0)} on other days.</li>`);
        }
      });

      if(!lines.length) return html;

      html += `
        <div class="hr"></div>
        <div class="small" style="opacity:.8; margin-top:10px;"><b>Activity trends (last ~2+ weeks)</b></div>
        <div class="small" style="opacity:.75; margin-top:4px;">These are descriptive patterns from your logs (not preset judgments). More data = clearer trends.</div>
        <ul class="small" style="margin-top:8px; opacity:.9; line-height:1.45;">
          ${lines.join("")}
        </ul>
      `;
      return html;
    };
  }

  function patchOverviewStrain(){
    // Override updateOverviewPrimaryMetrics to include schedule/event loads while keeping the rest identical where possible.
    if(typeof updateOverviewPrimaryMetrics !== "function") return;
    const orig = updateOverviewPrimaryMetrics;
    window.updateOverviewPrimaryMetrics = function(){
      try{
        // Call original first (updates many dependent UI pieces)
        orig();
      }catch(e){}
      try{
        // Then overwrite strain value using total load (sessions + schedule + events)
        const t = nowMs();
        const start = dayStartMsFromMs(t);
        const endNow = t;
        const todaySessions = (typeof sessionsInRange==="function") ? sessionsInRange(start,endNow) : [];
        const strainMin = computeTotalStrainMinInRange(start,endNow);
        const strainPts = (typeof strainPointsFromStrainMin==="function") ? strainPointsFromStrainMin(strainMin) : 0;

        const strainValEl = _("strainVal");
        const strainSubEl = _("strainSub");
        const strainTargetEl = _("strainTargetChip") || _("strainTarget");
        if(strainSubEl) strainSubEl.textContent = `Sessions today: ${todaySessions.length} • External load: ${Math.round((strainMin - todaySessions.reduce((a,s)=>a+strainForSession(s),0))||0)}m`;

        const gMin = (state.goals?.strainMin ?? 200);
        const gMax = (state.goals?.strainMax ?? 420);
        const tMin = (typeof strainPointsFromStrainMin==="function") ? strainPointsFromStrainMin(gMin) : 0;
        const tMax = Math.max(0.0001, (typeof strainPointsFromStrainMin==="function") ? strainPointsFromStrainMin(gMax) : 1);
        const curPct = clampN((strainPts / tMax) * 100, 0, 999);

        if(strainValEl) strainValEl.textContent = `${Math.round((todaySessions.length || strainMin>0) ? curPct : 0)}%`;
        if(typeof applyMetricHue==="function"){ try{ applyMetricHue(strainValEl, clampN(100 - Math.min(curPct,100), 0, 100)); }catch(e){} }
        if(strainTargetEl){
          const lowPct = clampN((tMin / tMax) * 100, 0, 100);
          const lowTxt = Math.round(lowPct);
          strainTargetEl.textContent = (lowTxt >= 100) ? "Target: 100%" : `Target: ${lowTxt}–100%`;
        }
      }catch(e){}
    };
  }

  function patchReadinessUI(){
    if(typeof updateReadinessUI !== "function") return;
    const orig = updateReadinessUI;
    window.updateReadinessUI = function(){
      // Force readinessToday() to use our 2x version by temporarily swapping
      const prev = window.readinessToday;
      try{ window.readinessToday = readinessToday_2x; }catch(e){}
      try{ orig(); }catch(e){}
      try{ window.readinessToday = prev; }catch(e){}
      // Also show passive drain hint if element exists
      try{
        const interpEl = _("readinessInterpret");
        if(interpEl){
          const r = readinessToday_2x();
          if(r && Number.isFinite(r.passive) && r.passive>0){
            interpEl.innerHTML = interpEl.innerHTML.replace(/<br><span class="small">.*?<\/span>$/,"");
            // Passive drain is applied in the math; keep UI clean (no extra line here).
          }
        }
      }catch(e){}
    };
  }

  function patchReadinessBaseAndBaselines(){
    // Override readinessBaseFor + updateBaselinesFromCheckin to use latest check-in for the date
    window.readinessBaseFor = readinessBaseFor_2x;

    if(typeof updateBaselinesFromCheckin === "function"){
      const orig = updateBaselinesFromCheckin;
      window.updateBaselinesFromCheckin = function(date){
        // Use latest check-in object and then run the original logic by temporarily setting state.dailyCheckins[date] to that object
        try{
          const latest = latestCheckinForDate(date);
          if(!latest || !latest.ci) return;
          const saved = state.dailyCheckins[date];
          state.dailyCheckins[date] = latest.ci;
          orig(date);
          state.dailyCheckins[date] = saved;
        }catch(e){}
      };
    }
  }

  function patchDeepWork(){
    window.drawDeepRate = drawDeepRate_2x;
  }

  function patchPromptLoop(){
    // Replace maybePromptCheckin usage in the 30s interval loop by overwriting global maybePromptCheckin
    window.maybePromptCheckin = maybePromptCheckin_2x;
    window.updateSettingCheckinHint = updateSettingCheckinHint_2x;
  }

  function patchStrainToday(){
    window.strainToday = strainToday_2x;
    // readinessToday global for any other users
    window.readinessToday = readinessToday_2x;
  }

  function patchAnalytics(){
    // Ensure deep work works and analytics redraw uses patched drawDeepRate
    try{ patchDeepWork(); }catch(e){}
  }

  function finalize(){
    ensureSchema();
    injectCheckinEnhancements();
    injectSettingsEnhancements();
    wireNewSettingsInputs();
renderEventButtons();
    // Ensure schedule presets are always available when Settings is opened (tour or normal navigation)
    try{
      const settingsTabBtn = document.querySelector('.tabbtn[data-tab="settings"]');
      if(settingsTabBtn && !settingsTabBtn.dataset.schedUiWired){
        settingsTabBtn.dataset.schedUiWired="1";
        settingsTabBtn.addEventListener("click", ()=> setTimeout(()=>{ try{ injectSettingsEnhancements(); }catch(e){} }, 80));
      }
    }catch(e){}
    wireSaveCheckin();

    patchPromptLoop();
    patchReadinessBaseAndBaselines();
    patchStrainToday();
    patchReadinessUI();
    patchOverviewStrain();
    patchCoachTrends();
    patchAnalytics();

    updateSettingCheckinHint_2x();

    // Update check-in prompt immediately after boot
    try{ maybePromptCheckin_2x(false); }catch(e){}
  }

  
  /**********************
   * Mobile Simulator (desktop dev tool)
   **********************/
  function initMobileSimulator(){
    try{
      const params = new URLSearchParams(location.search || "");
      if(params.get("embed")==="1"){
        document.body.classList.add("embed");
        return;
      }

      const simShell = document.getElementById("simShell");
      const simPanel = document.getElementById("simPanel");
      const simToggle = document.getElementById("simToggle");
      const simClose  = document.getElementById("simClose");
      const simDevice = document.getElementById("simDevice");
      const simOrient = document.getElementById("simOrient");
      const simScale  = document.getElementById("simScale");
      const simPhone  = document.getElementById("simPhone");
      const simFrame  = document.getElementById("simFrame");
      if(!simShell || !simPanel || !simToggle || !simFrame) return;

      const DEVICES = [
        {name:'iPhone 15 Pro (6.1")', w:393, h:852},
        {name:'iPhone 15 Pro Max (6.7")', w:430, h:932},
        {name:'iPhone 14 / 13 (6.1")', w:390, h:844},
        {name:'iPhone SE (2022)', w:375, h:667},
        {name:'Pixel 8', w:412, h:915},
        {name:'Pixel 7a', w:412, h:892},
        {name:'Galaxy S24', w:360, h:780},
        {name:'Galaxy A54', w:360, h:800},
      ];

      // populate
      simDevice.innerHTML = DEVICES.map((d,i)=>`<option value="${i}">${d.name} — ${d.w}×${d.h}</option>`).join("");
      // sensible default
      simDevice.value = "0";

      function buildEmbedURL(){
        const u = new URL(location.href);
        u.searchParams.set("embed","1");
        // preserve current tab/hash
        u.hash = location.hash || "";
        return u.toString();
      }

      function apply(){
        const d = DEVICES[parseInt(simDevice.value||"0",10)] || DEVICES[0];
        const orient = simOrient.value || "portrait";
        const scale = Math.max(40, Math.min(120, parseInt(simScale.value||"72",10)));

        const w = orient==="landscape" ? d.h : d.w;
        const h = orient==="landscape" ? d.w : d.h;

        simPhone.style.width = w + "px";
        simPhone.style.height = h + "px";
        simPhone.style.transform = `scale(${scale/100})`;

        // refresh iframe src if needed
        const target = buildEmbedURL();
        if(simFrame.getAttribute("data-src") !== target){
          simFrame.setAttribute("data-src", target);
          simFrame.src = target;
        }

        // attempt to keep hash synced
        try{
          if(simFrame.contentWindow && simFrame.contentWindow.location){
            if((simFrame.contentWindow.location.hash||"") !== (location.hash||"")){
              simFrame.contentWindow.location.hash = location.hash||"";
            }
          }
        }catch(e){}
      }

      function open(){
        simPanel.classList.add("open");
        apply();
      }
      function close(){
        simPanel.classList.remove("open");
      }

      simToggle.addEventListener("click", ()=> {
        if(simPanel.classList.contains("open")) close();
        else open();
      });
      simClose.addEventListener("click", close);
      simDevice.addEventListener("change", apply);
      simOrient.addEventListener("change", apply);
      simScale.addEventListener("input", apply);

      // Close on Escape
      document.addEventListener("keydown", (e)=>{
        if(e.key==="Escape" && simPanel.classList.contains("open")) close();
      });

      // Keep preview in sync when tab changes (hash/nav)
      window.addEventListener("hashchange", ()=>{
        try{
          if(simPanel.classList.contains("open")) apply();
        }catch(e){}
      });

      // storage updates from main app -> embedded preview can refresh itself
      window.addEventListener("storage", (e)=>{
        try{
          if(!simPanel.classList.contains("open")) return;
          // encourage the iframe to refresh computed UI (same-origin)
          simFrame.contentWindow && simFrame.contentWindow.postMessage({type:"sp_sync"}, "*");
        }catch(err){}
      });

    }catch(e){}
  }

  // In embedded view, listen for sync ping (best-effort, safe)
  window.addEventListener("message", (ev)=>{
    try{
      if(ev && ev.data && ev.data.type==="sp_sync"){
        // If these exist in this build, re-run UI update.
        try{ updateAll(); }catch(e){}
        try{ updateReadinessUI(); }catch(e){}
      }
    }catch(e){}
  });

document.addEventListener("DOMContentLoaded", function(){
    try{ finalize(); }catch(e){}
    try{ initMobileSimulator(); }catch(e){}
  });
})();

</script>
</body>
</html>
